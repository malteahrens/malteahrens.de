<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - app/scripts/lib/mapbox-gl.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app/scripts/lib/mapbox-gl.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.72</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">20872</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">410.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">357.86</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#039;&quot;+o+&quot;&#039;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

// a simple wrapper around a single arraybuffer

    module.exports = Buffer;

    function Buffer(buffer) {
        if (!buffer) {
            this.array = new ArrayBuffer(this.defaultLength);
            this.length = this.defaultLength;
            this.setupViews();

        } else {
            // we only recreate buffers after receiving them from workers for binding to gl,
            // so we only need these 2 properties
            this.array = buffer.array;
            this.pos = buffer.pos;
        }
    }

    Buffer.prototype = {
        pos: 0,
        itemSize: 4, // bytes in one item
        defaultLength: 8192, // initial buffer size
        arrayType: &#039;ARRAY_BUFFER&#039;, // gl buffer type

        get index() {
            return this.pos / this.itemSize;
        },

        setupViews: function() {
            // set up views for each type to add data of different types to the same buffer
            this.ubytes = new Uint8Array(this.array);
            this.bytes = new Int8Array(this.array);
            this.ushorts = new Uint16Array(this.array);
            this.shorts = new Int16Array(this.array);
        },

        // binds the buffer to a webgl context
        bind: function(gl) {
            var type = gl[this.arrayType];
            if (!this.buffer) {
                this.buffer = gl.createBuffer();
                gl.bindBuffer(type, this.buffer);
                gl.bufferData(type, this.array.slice(0, this.pos), gl.STATIC_DRAW);

                // dump array buffer once it&#039;s bound to gl
                this.array = null;
            } else {
                gl.bindBuffer(type, this.buffer);
            }
        },

        destroy: function(gl) {
            if (this.buffer) {
                gl.deleteBuffer(this.buffer);
            }
        },

        // increase the buffer size by 50% if a new item doesn&#039;t fit
        resize: function() {
            if (this.length &lt; this.pos + this.itemSize) {

                while (this.length &lt; this.pos + this.itemSize) {
                    // increase the length by 50% but keep it even
                    this.length = Math.round(this.length * 1.5 / 2) * 2;
                }

                // array buffers can&#039;t be resized, so we create a new one and reset all bytes there
                this.array = new ArrayBuffer(this.length);

                var ubytes = new Uint8Array(this.array);
                ubytes.set(this.ubytes);

                this.setupViews();
            }
        }
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer_set.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var LineVertexBuffer = require(&#039;./line_vertex_buffer&#039;);
    var LineElementBuffer = require(&#039;./line_element_buffer&#039;);
    var FillVertexBuffer = require(&#039;./fill_vertex_buffer&#039;);
    var FillElementBuffer = require(&#039;./triangle_element_buffer&#039;);
    var OutlineElementBuffer = require(&#039;./outline_elements_buffer&#039;);
    var GlyphVertexBuffer = require(&#039;./glyph_vertex_buffer&#039;);
    var GlyphElementBuffer = require(&#039;./triangle_element_buffer&#039;);
    var IconVertexBuffer = require(&#039;./icon_vertex_buffer&#039;);
    var IconElementBuffer = require(&#039;./triangle_element_buffer&#039;);
    var CollisionBoxVertexBuffer = require(&#039;./collision_box_vertex_buffer&#039;);

    module.exports = function(bufferset) {
        bufferset = bufferset || {};
        return {
            glyphVertex: new GlyphVertexBuffer(bufferset.glyphVertex),
            glyphElement: new GlyphElementBuffer(bufferset.glyphElement),
            iconVertex: new IconVertexBuffer(bufferset.iconVertex),
            iconElement: new IconElementBuffer(bufferset.iconElement),
            fillVertex: new FillVertexBuffer(bufferset.fillVertex),
            fillElement: new FillElementBuffer(bufferset.fillElement),
            outlineElement: new OutlineElementBuffer(bufferset.outlineElement),
            lineVertex: new LineVertexBuffer(bufferset.lineVertex),
            lineElement: new LineElementBuffer(bufferset.lineElement),
            collisionBoxVertex: new CollisionBoxVertexBuffer(bufferset.collisionBoxVertex)
        };
    };

},{&quot;./collision_box_vertex_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/collision_box_vertex_buffer.js&quot;,&quot;./fill_vertex_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/fill_vertex_buffer.js&quot;,&quot;./glyph_vertex_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/glyph_vertex_buffer.js&quot;,&quot;./icon_vertex_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/icon_vertex_buffer.js&quot;,&quot;./line_element_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/line_element_buffer.js&quot;,&quot;./line_vertex_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/line_vertex_buffer.js&quot;,&quot;./outline_elements_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/outline_elements_buffer.js&quot;,&quot;./triangle_element_buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/triangle_element_buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/collision_box_vertex_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = CollisionBoxVertexBuffer;

    function CollisionBoxVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    CollisionBoxVertexBuffer.prototype = util.inherit(Buffer, {
        itemSize: 12, // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
        defaultLength: 32768,

        // add a vertex to this buffer;
        // x, y - vertex position
        // ex, ey - extrude normal
        add: function(point, extrude, maxZoom, placementZoom) {
            var pos = this.pos,
                pos2 = pos / 2,
                index = this.index;

            this.resize();

            this.shorts[pos2 + 0] = point.x;
            this.shorts[pos2 + 1] = point.y;

            this.shorts[pos2 + 2] = Math.round(extrude.x);
            this.shorts[pos2 + 3] = Math.round(extrude.y);
            this.ubytes[pos + 8] = Math.floor(maxZoom * 10);
            this.ubytes[pos + 9] = Math.floor(placementZoom * 10);

            this.pos += this.itemSize;
            return index;
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/fill_vertex_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = FillVertexBuffer;

    function FillVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    FillVertexBuffer.prototype = util.inherit(Buffer, {
        itemSize: 4, // bytes per vertex (2 * short == 4 bytes)

        add: function(x, y) {
            var pos2 = this.pos / 2;

            this.resize();

            this.shorts[pos2 + 0] = x;
            this.shorts[pos2 + 1] = y;

            this.pos += this.itemSize;
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/glyph_vertex_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = GlyphVertexBuffer;

    function GlyphVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }


    GlyphVertexBuffer.prototype = util.inherit(Buffer, {
        defaultLength: 2048 * 16,
        itemSize: 16,

        add: function(x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom) {
            var pos = this.pos,
                pos2 = pos / 2;

            this.resize();

            this.shorts[pos2 + 0] = x;
            this.shorts[pos2 + 1] = y;
            this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
            this.shorts[pos2 + 3] = Math.round(oy * 64);

            // a_data1
            this.ubytes[pos + 8] /* tex */ = Math.floor(tx / 4);
            this.ubytes[pos + 9] /* tex */ = Math.floor(ty / 4);
            this.ubytes[pos + 10] /* labelminzoom */ = Math.floor((labelminzoom) * 10);

            // a_data2
            this.ubytes[pos + 12] /* minzoom */ = Math.floor((minzoom) * 10); // 1/10 zoom levels: z16 == 160.
            this.ubytes[pos + 13] /* maxzoom */ = Math.floor(Math.min(maxzoom, 25) * 10); // 1/10 zoom levels: z16 == 160.

            this.pos += this.itemSize;
        },

        bind: function(gl, shader, offset) {
            Buffer.prototype.bind.call(this, gl);

            var stride = this.itemSize;

            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, offset + 0);
            gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, offset + 4);

            gl.vertexAttribPointer(shader.a_data1, 4, gl.UNSIGNED_BYTE, false, stride, offset + 8);
            gl.vertexAttribPointer(shader.a_data2, 2, gl.UNSIGNED_BYTE, false, stride, offset + 12);
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/icon_vertex_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = GlyphVertexBuffer;

    function GlyphVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    GlyphVertexBuffer.prototype = util.inherit(Buffer, {
        defaultLength: 2048 * 16,
        itemSize: 16,

        add: function(x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom) {
            var pos = this.pos,
                pos2 = pos / 2;

            this.resize();

            this.shorts[pos2 + 0] = x;
            this.shorts[pos2 + 1] = y;
            this.shorts[pos2 + 2] = Math.round(ox * 64); // use 1/64 pixels for placement
            this.shorts[pos2 + 3] = Math.round(oy * 64);

            // a_data1
            this.ubytes[pos + 8] /* tex */ = tx / 4;
            this.ubytes[pos + 9] /* tex */ = ty / 4;
            this.ubytes[pos + 10] /* labelminzoom */ = Math.floor((labelminzoom || 0) * 10);

            // a_data2
            this.ubytes[pos + 12] /* minzoom */ = Math.floor((minzoom || 0) * 10); // 1/10 zoom levels: z16 == 160.
            this.ubytes[pos + 13] /* maxzoom */ = Math.floor(Math.min(maxzoom || 25, 25) * 10); // 1/10 zoom levels: z16 == 160.

            this.pos += this.itemSize;
        },

        bind: function(gl, shader, offset) {
            Buffer.prototype.bind.call(this, gl);

            var stride = this.itemSize;

            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, offset + 0);
            gl.vertexAttribPointer(shader.a_offset, 2, gl.SHORT, false, stride, offset + 4);
            gl.vertexAttribPointer(shader.a_data1, 4, gl.UNSIGNED_BYTE, false, stride, offset + 8);
            gl.vertexAttribPointer(shader.a_data2, 2, gl.UNSIGNED_BYTE, false, stride, offset + 12);
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/line_element_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = LineElementBuffer;

    function LineElementBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    LineElementBuffer.prototype = util.inherit(Buffer, {
        itemSize: 6, // bytes per triangle (3 * unsigned short == 6 bytes)
        arrayType: &#039;ELEMENT_ARRAY_BUFFER&#039;,

        add: function(a, b, c) {
            var pos2 = this.pos / 2;

            this.resize();

            this.ushorts[pos2 + 0] = a;
            this.ushorts[pos2 + 1] = b;
            this.ushorts[pos2 + 2] = c;

            this.pos += this.itemSize;
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/line_vertex_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = LineVertexBuffer;

    function LineVertexBuffer(buffer) {
        Buffer.call(this, buffer);
    }

// scale the extrusion vector so that the normal length is this value.
// contains the &quot;texture&quot; normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
    LineVertexBuffer.extrudeScale = 63;

    LineVertexBuffer.prototype = util.inherit(Buffer, {
        itemSize: 8, // bytes per vertex (2 * short + 1 * short + 2 * byte = 8 bytes)
        defaultLength: 32768,

        // add a vertex to this buffer;
        // x, y - vertex position
        // ex, ey - extrude normal
        // tx, ty - texture normal
        add: function(point, extrude, tx, ty, linesofar) {
            var pos = this.pos,
                pos2 = pos / 2,
                index = this.index,
                extrudeScale = LineVertexBuffer.extrudeScale;

            this.resize();

            this.shorts[pos2 + 0] = (Math.floor(point.x) * 2) | tx;
            this.shorts[pos2 + 1] = (Math.floor(point.y) * 2) | ty;

            this.bytes[pos + 4] = Math.round(extrudeScale * extrude.x);
            this.bytes[pos + 5] = Math.round(extrudeScale * extrude.y);
            this.bytes[pos + 6] = (linesofar || 0) / 128;
            this.bytes[pos + 7] = (linesofar || 0) % 128;

            this.pos += this.itemSize;
            return index;
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/outline_elements_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = OutlineElementsBuffer;

    function OutlineElementsBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    OutlineElementsBuffer.prototype = util.inherit(Buffer, {
        itemSize: 4, // bytes per line (2 * unsigned short == 4 bytes)
        arrayType: &#039;ELEMENT_ARRAY_BUFFER&#039;,

        add: function(a, b) {
            var pos2 = this.pos / 2;

            this.resize();

            this.ushorts[pos2 + 0] = a;
            this.ushorts[pos2 + 1] = b;

            this.pos += this.itemSize;
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/triangle_element_buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../../util/util&#039;);
    var Buffer = require(&#039;./buffer&#039;);

    module.exports = TriangleElementsBuffer;

    function TriangleElementsBuffer(buffer) {
        Buffer.call(this, buffer);
    }

    TriangleElementsBuffer.prototype = util.inherit(Buffer, {
        itemSize: 6, // bytes per triangle (3 * unsigned short == 6 bytes)
        arrayType: &#039;ELEMENT_ARRAY_BUFFER&#039;,

        add: function(a, b, c) {
            var pos2 = this.pos / 2;

            this.resize();

            this.ushorts[pos2 + 0] = a;
            this.ushorts[pos2 + 1] = b;
            this.ushorts[pos2 + 2] = c;

            this.pos += this.itemSize;
        }
    });

},{&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/create_bucket.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = createBucket;

    var LineBucket = require(&#039;./line_bucket&#039;);
    var FillBucket = require(&#039;./fill_bucket&#039;);
    var SymbolBucket = require(&#039;./symbol_bucket&#039;);
    var LayoutProperties = require(&#039;../style/layout_properties&#039;);
    var featureFilter = require(&#039;feature-filter&#039;);
    var StyleDeclarationSet = require(&#039;../style/style_declaration_set&#039;);

    function createBucket(layer, buffers, collision, z, overscaling, collisionDebug) {
        var values = new StyleDeclarationSet(&#039;layout&#039;, layer.type, layer.layout, {}).values(),
            fakeZoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 },
            layout = {};

        for (var k in values) {
            layout[k] = values[k].calculate(z, fakeZoomHistory);
        }

        var BucketClass =
                layer.type === &#039;line&#039; ? LineBucket :
                layer.type === &#039;fill&#039; ? FillBucket :
                layer.type === &#039;symbol&#039; ? SymbolBucket : null;

        var bucket = new BucketClass(buffers, new LayoutProperties[layer.type](layout), collision, overscaling, collisionDebug);

        bucket.id = layer.id;
        bucket.type = layer.type;
        bucket[&#039;source-layer&#039;] = layer[&#039;source-layer&#039;];
        bucket.interactive = layer.interactive;
        bucket.minZoom = layer.minzoom;
        bucket.maxZoom = layer.maxzoom;
        bucket.filter = featureFilter(layer.filter);
        bucket.features = [];

        return bucket;
    }

},{&quot;../style/layout_properties&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/layout_properties.js&quot;,&quot;../style/style_declaration_set&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_declaration_set.js&quot;,&quot;./fill_bucket&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/fill_bucket.js&quot;,&quot;./line_bucket&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/line_bucket.js&quot;,&quot;./symbol_bucket&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/symbol_bucket.js&quot;,&quot;feature-filter&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/feature-filter/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/element_groups.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = ElementGroups;

    function ElementGroups(vertexBuffer, elementBuffer, secondElementBuffer) {

        this.vertexBuffer = vertexBuffer;
        this.elementBuffer = elementBuffer;
        this.secondElementBuffer = secondElementBuffer;
        this.groups = [];
    }

    ElementGroups.prototype.makeRoomFor = function(numVertices) {
        if (!this.current || this.current.vertexLength + numVertices &gt; 65535) {
            this.current = new ElementGroup(this.vertexBuffer.index,
                    this.elementBuffer &amp;&amp; this.elementBuffer.index,
                    this.secondElementBuffer &amp;&amp; this.secondElementBuffer.index);
            this.groups.push(this.current);
        }
    };

    function ElementGroup(vertexStartIndex, elementStartIndex, secondElementStartIndex) {
        // the offset into the vertex buffer of the first vertex in this group
        this.vertexStartIndex = vertexStartIndex;
        this.elementStartIndex = elementStartIndex;
        this.secondElementStartIndex = secondElementStartIndex;
        this.elementLength = 0;
        this.vertexLength = 0;
        this.secondElementLength = 0;
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/feature_tree.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var rbush = require(&#039;rbush&#039;);
    var Point = require(&#039;point-geometry&#039;);
    var vt = require(&#039;vector-tile&#039;);
    var util = require(&#039;../util/util&#039;);
    var TileCoord = require(&#039;../source/tile_coord&#039;);

    module.exports = FeatureTree;

    function FeatureTree(tileId) {
        this.coord = TileCoord.fromID(tileId);
        this.rtree = rbush(9);
        this.toBeInserted = [];
    }

    FeatureTree.prototype.insert = function(bbox, layers, feature) {
        bbox.layers = layers;
        bbox.feature = feature;
        this.toBeInserted.push(bbox);
    };

// bulk insert into tree
    FeatureTree.prototype._load = function() {
        this.rtree.load(this.toBeInserted);
        this.toBeInserted = [];
    };

// Finds features in this tile at a particular position.
    FeatureTree.prototype.query = function(args, callback) {
        if (this.toBeInserted.length) this._load();

        var params = args.params || {},
            radius = (params.radius || 0) * 4096 / args.scale,
            x = args.x,
            y = args.y,
            result = [];

        var matching = this.rtree.search([ x - radius, y - radius, x + radius, y + radius ]);
        for (var i = 0; i &lt; matching.length; i++) {
            var feature = matching[i].feature,
                layers = matching[i].layers,
                type = vt.VectorTileFeature.types[feature.type];

            if (params.$type &amp;&amp; type !== params.$type)
                continue;
            if (!geometryContainsPoint(feature.loadGeometry(), type, new Point(x, y), radius))
                continue;

            var geoJSON = feature.toGeoJSON(this.coord.x, this.coord.y, this.coord.z);
            for (var l = 0; l &lt; layers.length; l++) {
                var layer = layers[l];

                if (params.layer &amp;&amp; layer !== params.layer.id)
                    continue;

                result.push(util.extend({layer: layer}, geoJSON));
            }
        }

        callback(null, result);
    };

    function geometryContainsPoint(rings, type, p, radius) {
        return type === &#039;Point&#039; ? pointContainsPoint(rings, p, radius) :
                type === &#039;LineString&#039; ? lineContainsPoint(rings, p, radius) :
                type === &#039;Polygon&#039; ? polyContainsPoint(rings, p) || lineContainsPoint(rings, p, radius) : false;
    }

// Code from http://stackoverflow.com/a/1501725/331379.
    function distToSegmentSquared(p, v, w) {
        var l2 = v.distSqr(w);
        if (l2 === 0) return p.distSqr(v);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t &lt; 0) return p.distSqr(v);
        if (t &gt; 1) return p.distSqr(w);
        return p.distSqr(w.sub(v)._mult(t)._add(v));
    }

    function lineContainsPoint(rings, p, radius) {
        var r = radius * radius;

        for (var i = 0; i &lt; rings.length; i++) {
            var ring = rings[i];
            for (var j = 1; j &lt; ring.length; j++) {
                // Find line segments that have a distance &lt;= radius^2 to p
                // In that case, we treat the line as &quot;containing point p&quot;.
                var v = ring[j - 1], w = ring[j];
                if (distToSegmentSquared(p, v, w) &lt; r) return true;
            }
        }
        return false;
    }

// point in polygon ray casting algorithm
    function polyContainsPoint(rings, p) {
        var c = false,
            ring, p1, p2;

        for (var k = 0; k &lt; rings.length; k++) {
            ring = rings[k];
            for (var i = 0, j = ring.length - 1; i &lt; ring.length; j = i++) {
                p1 = ring[i];
                p2 = ring[j];
                if (((p1.y &gt; p.y) !== (p2.y &gt; p.y)) &amp;&amp; (p.x &lt; (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                    c = !c;
                }
            }
        }
        return c;
    }

    function pointContainsPoint(rings, p, radius) {
        var r = radius * radius;

        for (var i = 0; i &lt; rings.length; i++) {
            var ring = rings[i];
            for (var j = 0; j &lt; ring.length; j++) {
                if (ring[j].distSqr(p) &lt;= r) return true;
            }
        }
        return false;
    }

},{&quot;../source/tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;,&quot;rbush&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/rbush/rbush.js&quot;,&quot;vector-tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/fill_bucket.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var ElementGroups = require(&#039;./element_groups&#039;);

    module.exports = FillBucket;

    function FillBucket(buffers) {
        this.buffers = buffers;
        this.elementGroups = new ElementGroups(buffers.fillVertex, buffers.fillElement, buffers.outlineElement);
    }

    FillBucket.prototype.addFeatures = function() {
        var features = this.features;
        for (var i = 0; i &lt; features.length; i++) {
            var feature = features[i];
            this.addFeature(feature.loadGeometry());
        }
    };

    FillBucket.prototype.addFeature = function(lines) {
        for (var i = 0; i &lt; lines.length; i++) {
            this.addFill(lines[i]);
        }
    };

    FillBucket.prototype.addFill = function(vertices) {
        if (vertices.length &lt; 3) {
            //console.warn(&#039;a fill must have at least three vertices&#039;);
            return;
        }

        // Calculate the total number of vertices we&#039;re going to produce so that we
        // can resize the buffer beforehand, or detect whether the current line
        // won&#039;t fit into the buffer anymore.
        // In order to be able to use the vertex buffer for drawing the antialiased
        // outlines, we separate all polygon vertices with a degenerate (out-of-
        // viewplane) vertex.

        var len = vertices.length;

        // Check whether this geometry buffer can hold all the required vertices.
        this.elementGroups.makeRoomFor(len + 1);
        var elementGroup = this.elementGroups.current;

        var fillVertex = this.buffers.fillVertex;
        var fillElement = this.buffers.fillElement;
        var outlineElement = this.buffers.outlineElement;

        // We&#039;re generating triangle fans, so we always start with the first coordinate in this polygon.
        var firstIndex = fillVertex.index - elementGroup.vertexStartIndex,
            prevIndex, currentIndex, currentVertex;

        for (var i = 0; i &lt; vertices.length; i++) {
            currentIndex = fillVertex.index - elementGroup.vertexStartIndex;
            currentVertex = vertices[i];

            fillVertex.add(currentVertex.x, currentVertex.y);
            elementGroup.vertexLength++;

            // Only add triangles that have distinct vertices.
            if (i &gt;= 2 &amp;&amp; (currentVertex.x !== vertices[0].x || currentVertex.y !== vertices[0].y)) {
                fillElement.add(firstIndex, prevIndex, currentIndex);
                elementGroup.elementLength++;
            }

            if (i &gt;= 1) {
                outlineElement.add(prevIndex, currentIndex);
                elementGroup.secondElementLength++;
            }

            prevIndex = currentIndex;
        }
    };

},{&quot;./element_groups&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/element_groups.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/line_bucket.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var ElementGroups = require(&#039;./element_groups&#039;);

    module.exports = LineBucket;

    function LineBucket(buffers, layoutProperties, _, overscaling) {
        this.buffers = buffers;
        this.elementGroups = new ElementGroups(buffers.lineVertex, buffers.lineElement);
        this.layoutProperties = layoutProperties;
        this.overscaling = overscaling;
    }

    LineBucket.prototype.addFeatures = function() {
        var features = this.features;
        for (var i = 0; i &lt; features.length; i++) {
            var feature = features[i];
            this.addFeature(feature.loadGeometry());
        }
    };

    LineBucket.prototype.addFeature = function(lines) {
        var layoutProperties = this.layoutProperties;
        for (var i = 0; i &lt; lines.length; i++) {
            this.addLine(lines[i],
                layoutProperties[&#039;line-join&#039;],
                layoutProperties[&#039;line-cap&#039;],
                layoutProperties[&#039;line-miter-limit&#039;],
                layoutProperties[&#039;line-round-limit&#039;]);
        }
    };

    LineBucket.prototype.addLine = function(vertices, join, cap, miterLimit, roundLimit) {

        var len = vertices.length;
        // If the line has duplicate vertices at the end, adjust length to remove them.
        while (len &gt; 2 &amp;&amp; vertices[len - 1].equals(vertices[len - 2])) {
            len--;
        }

        if (vertices.length &lt; 2) {
            //console.warn(&#039;a line must have at least two vertices&#039;);
            return;
        }

        if (join === &#039;bevel&#039;) miterLimit = 1.05;

        var firstVertex = vertices[0],
            lastVertex = vertices[len - 1],
            closed = firstVertex.equals(lastVertex);

        var lineVertex = this.buffers.lineVertex;
        var lineElement = this.buffers.lineElement;

        // we could be more precise, but it would only save a negligible amount of space
        this.elementGroups.makeRoomFor(len * 4);
        var elementGroup = this.elementGroups.current;
        var vertexStartIndex = elementGroup.vertexStartIndex;

        if (len === 2 &amp;&amp; closed) {
            // console.warn(&#039;a line may not have coincident points&#039;);
            return;
        }

        var beginCap = cap,
            endCap = closed ? &#039;butt&#039; : cap,
            flip = 1,
            distance = 0,
            currentVertex, prevVertex, nextVertex, prevNormal, nextNormal;

        // the last three vertices added
        var e1, e2, e3;

        if (closed) {
            currentVertex = vertices[len - 2];
            nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
        }

        for (var i = 0; i &lt; len; i++) {

            nextVertex = closed &amp;&amp; i === len - 1 ?
                vertices[1] : // if the line is closed, we treat the last vertex like the first
                vertices[i + 1]; // just the next vertex

            // if two consecutive vertices exist, skip the current one
            if (nextVertex &amp;&amp; vertices[i].equals(nextVertex)) continue;

            if (nextNormal) prevNormal = nextNormal;
            if (currentVertex) prevVertex = currentVertex;

            currentVertex = vertices[i];

            // Calculate how far along the line the currentVertex is
            if (prevVertex) distance += currentVertex.dist(prevVertex) * this.overscaling;

            // Calculate the normal towards the next vertex in this line. In case
            // there is no next vertex, pretend that the line is continuing straight,
            // meaning that we are just using the previous normal.
            nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

            // If we still don&#039;t have a previous normal, this is the beginning of a
            // non-closed line, so we&#039;re doing a straight &quot;join&quot;.
            prevNormal = prevNormal || nextNormal;

            // Determine the normal of the join extrusion. It is the angle bisector
            // of the segments between the previous line and the next line.
            var joinNormal = prevNormal.add(nextNormal)._unit();

            /*  joinNormal     prevNormal
             *             ↖      ↑
             *                .________. prevVertex
             *                |
             * nextNormal  ←  |  currentVertex
             *                |
             *     nextVertex !
             *
             */

            // Calculate the length of the miter (the ratio of the miter to the width).
            // Find the cosine of the angle between the next and join normals
            // using dot product. The inverse of that is the miter length.
            var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
            var miterLength = 1 / cosHalfAngle;

            // Whether any vertices have been
            var startOfLine = e1 === undefined || e2 === undefined;

            // The join if a middle vertex, otherwise the cap.
            var middleVertex = prevVertex &amp;&amp; nextVertex;
            var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

            if (middleVertex &amp;&amp; currentJoin === &#039;round&#039; &amp;&amp; miterLength &lt; roundLimit) {
                currentJoin = &#039;miter&#039;;
            }

            if (currentJoin === &#039;miter&#039; &amp;&amp; miterLength &gt; miterLimit) {
                currentJoin = &#039;bevel&#039;;
            }

            if (currentJoin === &#039;bevel&#039;) {
                // The maximum extrude length is 63 / 256 = 4 times the width of the line
                // so if miterLength &gt;= 4 we need to draw a different type of bevel where.
                if (miterLength &gt; 4) currentJoin = &#039;flipbevel&#039;;

                // If the miterLength is really small and the line bevel wouldn&#039;t be visible,
                // just draw a miter join to save a triangle.
                if (miterLength &lt; miterLimit) currentJoin = &#039;miter&#039;;
            }

            // Mitered joins
            if (currentJoin === &#039;miter&#039;) {
                // scale the unit vector by the miter length
                joinNormal._mult(miterLength);
                addCurrentVertex(joinNormal, 0, 0, false);

            } else if (currentJoin === &#039;flipbevel&#039;) {
                // miter is too big, flip the direction to make a beveled join

                if (miterLength &gt; 100) {
                    // Almost parallel lines
                    flip = -flip;
                    joinNormal = nextNormal;

                } else {
                    var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                    joinNormal._perp()._mult(flip * bevelLength);
                    flip = -flip;
                }
                addCurrentVertex(joinNormal, 0, 0, false);

                // All other types of joins
            } else {

                var offsetA, offsetB;
                if (currentJoin === &#039;bevel&#039;) {
                    var dir = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x;
                    var offset = -Math.sqrt(miterLength * miterLength - 1);
                    if (flip * dir &gt; 0) {
                        offsetB = 0;
                        offsetA = offset;
                    } else {
                        offsetA = 0;
                        offsetB = offset;
                    }
                } else if (currentJoin === &#039;square&#039;) {
                    offsetA = offsetB = 1;
                } else {
                    offsetA = offsetB = 0;
                }

                // Close previous segment with a butt or a square cap or bevel
                if (!startOfLine) {
                    addCurrentVertex(prevNormal, offsetA, offsetB, false);
                }

                // Add round cap or linejoin at end of segment
                if (!startOfLine &amp;&amp; currentJoin === &#039;round&#039;) {
                    addCurrentVertex(prevNormal, 1, 1, true);
                }

                // Segment include cap are done, unset vertices to disconnect segments.
                // Or leave them to create a bevel.
                if (startOfLine || currentJoin !== &#039;bevel&#039;) {
                    e1 = e2 = -1;
                    flip = 1;
                }

                // Add round cap before first segment
                if (startOfLine &amp;&amp; beginCap === &#039;round&#039;) {
                    addCurrentVertex(nextNormal, -1, -1, true);
                }

                // Start next segment with a butt or square cap or bevel
                if (nextVertex) {
                    addCurrentVertex(nextNormal, -offsetA, -offsetB, false);
                }
            }

        }


        /*
         * Adds two vertices to the buffer that are
         * normal and -normal from the currentVertex.
         *
         * endBox moves the extrude one unit in the direction of the line
         * to create square or round cap.
         *
         * endLeft and endRight shifts the extrude along the line
         * endLeft === 1 moves the extrude in the direction of the line
         * endLeft === -1 moves the extrude in the reverse direction
         */
        function addCurrentVertex(normal, endLeft, endRight, round) {

            var tx = round ? 1 : 0;
            var extrude;

            extrude = normal.mult(flip);
            if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
            e3 = lineVertex.add(currentVertex, extrude, tx, 0, distance) - vertexStartIndex;
            if (e1 &gt;= 0 &amp;&amp; e2 &gt;= 0) {
                lineElement.add(e1, e2, e3);
                elementGroup.elementLength++;
            }
            e1 = e2;
            e2 = e3;

            extrude = normal.mult(-flip);
            if (endRight) extrude._sub(normal.perp()._mult(endRight));
            e3 = lineVertex.add(currentVertex, extrude, tx, 1, distance) - vertexStartIndex;
            if (e1 &gt;= 0 &amp;&amp; e2 &gt;= 0) {
                lineElement.add(e1, e2, e3);
                elementGroup.elementLength++;
            }
            e1 = e2;
            e2 = e3;

            elementGroup.vertexLength += 2;
        }
    };

},{&quot;./element_groups&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/element_groups.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/symbol_bucket.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var ElementGroups = require(&#039;./element_groups&#039;);
    var Anchor = require(&#039;../symbol/anchor&#039;);
    var getAnchors = require(&#039;../symbol/get_anchors&#039;);
    var resolveTokens = require(&#039;../util/token&#039;);
    var Quads = require(&#039;../symbol/quads&#039;);
    var Shaping = require(&#039;../symbol/shaping&#039;);
    var resolveText = require(&#039;../symbol/resolve_text&#039;);
    var resolveIcons = require(&#039;../symbol/resolve_icons&#039;);
    var mergeLines = require(&#039;../symbol/mergelines&#039;);
    var shapeText = Shaping.shapeText;
    var shapeIcon = Shaping.shapeIcon;
    var getGlyphQuads = Quads.getGlyphQuads;
    var getIconQuads = Quads.getIconQuads;
    var clipLine = require(&#039;../symbol/clip_line&#039;);
    var Point = require(&#039;point-geometry&#039;);

    var CollisionFeature = require(&#039;../symbol/collision_feature&#039;);

    module.exports = SymbolBucket;

    function SymbolBucket(buffers, layoutProperties, collision, overscaling, collisionDebug) {
        this.buffers = buffers;
        this.layoutProperties = layoutProperties;
        this.collision = collision;
        this.overscaling = overscaling;
        this.collisionDebug = collisionDebug;

        this.symbolInstances = [];

    }

    SymbolBucket.prototype.addFeatures = function() {
        var layout = this.layoutProperties;
        var features = this.features;
        var textFeatures = this.textFeatures;

        var horizontalAlign = 0.5,
            verticalAlign = 0.5;

        switch (layout[&#039;text-anchor&#039;]) {
            case &#039;right&#039;:
            case &#039;top-right&#039;:
            case &#039;bottom-right&#039;:
                horizontalAlign = 1;
                break;
            case &#039;left&#039;:
            case &#039;top-left&#039;:
            case &#039;bottom-left&#039;:
                horizontalAlign = 0;
                break;
        }

        switch (layout[&#039;text-anchor&#039;]) {
            case &#039;bottom&#039;:
            case &#039;bottom-right&#039;:
            case &#039;bottom-left&#039;:
                verticalAlign = 1;
                break;
            case &#039;top&#039;:
            case &#039;top-right&#039;:
            case &#039;top-left&#039;:
                verticalAlign = 0;
                break;
        }

        var justify = layout[&#039;text-justify&#039;] === &#039;right&#039; ? 1 :
                layout[&#039;text-justify&#039;] === &#039;left&#039; ? 0 :
            0.5;

        var oneEm = 24;
        var lineHeight = layout[&#039;text-line-height&#039;] * oneEm;
        var maxWidth = layout[&#039;symbol-placement&#039;] !== &#039;line&#039; ? layout[&#039;text-max-width&#039;] * oneEm : 0;
        var spacing = layout[&#039;text-letter-spacing&#039;] * oneEm;
        var textOffset = [layout[&#039;text-offset&#039;][0] * oneEm, layout[&#039;text-offset&#039;][1] * oneEm];
        var fontstack = layout[&#039;text-font&#039;];

        var geometries = [];
        for (var g = 0; g &lt; features.length; g++) {
            geometries.push(features[g].loadGeometry());
        }

        if (layout[&#039;symbol-placement&#039;] === &#039;line&#039;) {
            // Merge adjacent lines with the same text to improve labelling.
            // It&#039;s better to place labels on one long line than on many short segments.
            var merged = mergeLines(features, textFeatures, geometries);

            geometries = merged.geometries;
            features = merged.features;
            textFeatures = merged.textFeatures;
        }

        var shapedText, shapedIcon;

        for (var k = 0; k &lt; features.length; k++) {
            if (!geometries[k]) continue;

            if (textFeatures[k]) {
                shapedText = shapeText(textFeatures[k], this.stacks[fontstack], maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
            } else {
                shapedText = null;
            }

            if (layout[&#039;icon-image&#039;]) {
                var iconName = resolveTokens(features[k].properties, layout[&#039;icon-image&#039;]);
                var image = this.icons[iconName];
                shapedIcon = shapeIcon(image, layout);

                if (image) {
                    if (this.sdfIcons === undefined) {
                        this.sdfIcons = image.sdf;
                    } else if (this.sdfIcons !== image.sdf) {
                        console.warn(&#039;Style sheet warning: Cannot mix SDF and non-SDF icons in one bucket&#039;);
                    }
                }
            } else {
                shapedIcon = null;
            }

            if (shapedText || shapedIcon) {
                this.addFeature(geometries[k], shapedText, shapedIcon);
            }
        }

        this.placeFeatures(this.buffers, this.collisionDebug);
    };

    SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon) {
        var layout = this.layoutProperties;
        var collision = this.collision;

        var glyphSize = 24;

        var fontScale = layout[&#039;text-max-size&#039;] / glyphSize,
            textBoxScale = collision.tilePixelRatio * fontScale,
            iconBoxScale = collision.tilePixelRatio * layout[&#039;icon-max-size&#039;],
            symbolMinDistance = collision.tilePixelRatio * layout[&#039;symbol-min-distance&#039;],
            avoidEdges = layout[&#039;symbol-avoid-edges&#039;],
            textPadding = layout[&#039;text-padding&#039;] * collision.tilePixelRatio,
            iconPadding = layout[&#039;icon-padding&#039;] * collision.tilePixelRatio,
            textMaxAngle = layout[&#039;text-max-angle&#039;] / 180 * Math.PI,
            textAlongLine = layout[&#039;text-rotation-alignment&#039;] === &#039;map&#039; &amp;&amp; layout[&#039;symbol-placement&#039;] === &#039;line&#039;,
            iconAlongLine = layout[&#039;icon-rotation-alignment&#039;] === &#039;map&#039; &amp;&amp; layout[&#039;symbol-placement&#039;] === &#039;line&#039;;

        if (layout[&#039;symbol-placement&#039;] === &#039;line&#039;) {
            lines = clipLine(lines, 0, 0, 4096, 4096);
        }

        for (var i = 0; i &lt; lines.length; i++) {
            var line = lines[i];

            // Calculate the anchor points around which you want to place labels
            var anchors = layout[&#039;symbol-placement&#039;] === &#039;line&#039; ?
                getAnchors(line, symbolMinDistance, textMaxAngle, shapedText, glyphSize, textBoxScale, this.overscaling) :
                [ new Anchor(line[0].x, line[0].y, 0) ];

            // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
            for (var j = 0, len = anchors.length; j &lt; len; j++) {
                var anchor = anchors[j];

                var inside = !(anchor.x &lt; 0 || anchor.x &gt; 4096 || anchor.y &lt; 0 || anchor.y &gt; 4096);

                if (avoidEdges &amp;&amp; !inside) continue;

                this.symbolInstances.push(new SymbolInstance(anchor, line, shapedText, shapedIcon, layout, inside,
                    textBoxScale, textPadding, textAlongLine,
                    iconBoxScale, iconPadding, iconAlongLine));
            }
        }
    };

    SymbolBucket.prototype.placeFeatures = function(buffers, collisionDebug) {

        // Calculate which labels can be shown and when they can be shown and
        // create the bufers used for rendering.

        this.buffers = buffers;

        var elementGroups = this.elementGroups = {
            text: new ElementGroups(buffers.glyphVertex, buffers.glyphElement),
            icon: new ElementGroups(buffers.iconVertex, buffers.iconElement),
            sdfIcons: this.sdfIcons
        };

        var layout = this.layoutProperties;
        var collision = this.collision;
        var maxScale = this.collision.maxScale;

        var textAlongLine = layout[&#039;text-rotation-alignment&#039;] === &#039;map&#039; &amp;&amp; layout[&#039;symbol-placement&#039;] === &#039;line&#039;;
        var iconAlongLine = layout[&#039;icon-rotation-alignment&#039;] === &#039;map&#039; &amp;&amp; layout[&#039;symbol-placement&#039;] === &#039;line&#039;;

        for (var p = 0; p &lt; this.symbolInstances.length; p++) {
            var symbolInstance = this.symbolInstances[p];
            var hasText = symbolInstance.hasText;
            var hasIcon = symbolInstance.hasIcon;

            var iconWithoutText = layout[&#039;text-optional&#039;] || !hasText,
                textWithoutIcon = layout[&#039;icon-optional&#039;] || !hasIcon;


            // Calculate the scales at which the text and icon can be placed without collision.

            var glyphScale = hasText &amp;&amp; !layout[&#039;text-allow-overlap&#039;] ?
                collision.placeFeature(symbolInstance.textCollisionFeature) : collision.minScale;

            var iconScale = hasIcon &amp;&amp; !layout[&#039;icon-allow-overlap&#039;] ?
                collision.placeFeature(symbolInstance.iconCollisionFeature) : collision.minScale;


            // Combine the scales for icons and text.

            if (!iconWithoutText &amp;&amp; !textWithoutIcon) {
                iconScale = glyphScale = Math.max(iconScale, glyphScale);
            } else if (!textWithoutIcon &amp;&amp; glyphScale) {
                glyphScale = Math.max(iconScale, glyphScale);
            } else if (!iconWithoutText &amp;&amp; iconScale) {
                iconScale = Math.max(iconScale, glyphScale);
            }


            // Insert final placement into collision tree and add glyphs/icons to buffers

            if (hasText) {
                if (!layout[&#039;text-ignore-placement&#039;]) {
                    collision.insertFeature(symbolInstance.textCollisionFeature, glyphScale);
                }
                if (glyphScale &lt;= maxScale) {
                    this.addSymbols(buffers.glyphVertex, buffers.glyphElement, elementGroups.text,
                        symbolInstance.glyphQuads, glyphScale, layout[&#039;text-keep-upright&#039;], textAlongLine);
                }
            }

            if (hasIcon) {
                if (!layout[&#039;icon-ignore-placement&#039;]) {
                    collision.insertFeature(symbolInstance.iconCollisionFeature, iconScale);
                }
                if (iconScale &lt;= maxScale) {
                    this.addSymbols(buffers.iconVertex, buffers.iconElement, elementGroups.icon,
                        symbolInstance.iconQuads, iconScale, layout[&#039;icon-keep-upright&#039;], iconAlongLine);
                }
            }

        }

        if (collisionDebug) this.addToDebugBuffers();
    };

    SymbolBucket.prototype.addSymbols = function(vertex, element, elementGroups, quads, scale, keepUpright, alongLine) {

        elementGroups.makeRoomFor(4 * quads.length);
        var elementGroup = elementGroups.current;

        var zoom = this.collision.zoom;
        var placementZoom = Math.log(scale) / Math.LN2 + zoom;
        var placementAngle = this.collision.angle + Math.PI;

        for (var k = 0; k &lt; quads.length; k++) {

            var symbol = quads[k],
                angle = symbol.angle;

            // drop upside down versions of glyphs
            var a = (angle + placementAngle) % (Math.PI * 2);
            if (keepUpright &amp;&amp; alongLine &amp;&amp; (a &lt;= Math.PI / 2 || a &gt; Math.PI * 3 / 2)) continue;

            var tl = symbol.tl,
                tr = symbol.tr,
                bl = symbol.bl,
                br = symbol.br,
                tex = symbol.tex,
                anchor = symbol.anchor,

                minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
                maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

            if (maxZoom &lt;= minZoom) continue;

            // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
            if (minZoom === placementZoom) minZoom = 0;

            var triangleIndex = vertex.index - elementGroup.vertexStartIndex;

            vertex.add(anchor.x, anchor.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom);
            vertex.add(anchor.x, anchor.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom);
            vertex.add(anchor.x, anchor.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom);
            vertex.add(anchor.x, anchor.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom);
            elementGroup.vertexLength += 4;

            element.add(triangleIndex, triangleIndex + 1, triangleIndex + 2);
            element.add(triangleIndex + 1, triangleIndex + 2, triangleIndex + 3);
            elementGroup.elementLength += 2;
        }

    };

    SymbolBucket.prototype.getDependencies = function(tile, actor, callback) {
        var firstdone = false;
        this.getTextDependencies(tile, actor, done);
        this.getIconDependencies(tile, actor, done);
        function done(err) {
            if (err || firstdone) return callback(err);
            firstdone = true;
        }
    };

    SymbolBucket.prototype.getIconDependencies = function(tile, actor, callback) {
        if (this.layoutProperties[&#039;icon-image&#039;]) {
            var features = this.features;
            var icons = resolveIcons(features, this.layoutProperties);

            if (icons.length) {
                actor.send(&#039;get icons&#039;, { icons: icons }, setIcons.bind(this));
            } else {
                callback();
            }
        } else {
            callback();
        }

        function setIcons(err, newicons) {
            if (err) return callback(err);
            this.icons = newicons;
            callback();
        }
    };

    SymbolBucket.prototype.getTextDependencies = function(tile, actor, callback) {
        var features = this.features;
        var fontstack = this.layoutProperties[&#039;text-font&#039;];

        var stacks = this.stacks = tile.stacks;
        if (stacks[fontstack] === undefined) {
            stacks[fontstack] = {};
        }
        var stack = stacks[fontstack];

        var data = resolveText(features, this.layoutProperties, stack);
        this.textFeatures = data.textFeatures;

        actor.send(&#039;get glyphs&#039;, {
            uid: tile.uid,
            fontstack: fontstack,
            codepoints: data.codepoints
        }, function(err, newstack) {
            if (err) return callback(err);

            for (var codepoint in newstack) {
                stack[codepoint] = newstack[codepoint];
            }

            callback();
        });
    };

    SymbolBucket.prototype.addToDebugBuffers = function() {

        this.elementGroups.collisionBox = new ElementGroups(this.buffers.collisionBoxVertex);
        this.elementGroups.collisionBox.makeRoomFor(0);
        var buffer = this.buffers.collisionBoxVertex;
        var angle = -this.collision.angle;
        var yStretch = this.collision.yStretch;

        for (var j = 0; j &lt; this.symbolInstances.length; j++) {
            for (var i = 0; i &lt; 2; i++) {
                var feature = this.symbolInstances[j][i === 0 ? &#039;textCollisionFeature&#039; : &#039;iconCollisionFeature&#039;];
                if (!feature) continue;
                var boxes = feature.boxes;

                for (var b = 0; b &lt; boxes.length; b++) {
                    var box = boxes[b];
                    var anchor = box.anchor;

                    var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
                    var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
                    var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
                    var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);

                    var maxZoom = Math.max(0, Math.min(25, this.collision.zoom + Math.log(box.maxScale) / Math.LN2));
                    var placementZoom = Math.max(0, Math.min(25, this.collision.zoom + Math.log(box.placementScale) / Math.LN2));

                    buffer.add(anchor, tl, maxZoom, placementZoom);
                    buffer.add(anchor, tr, maxZoom, placementZoom);
                    buffer.add(anchor, tr, maxZoom, placementZoom);
                    buffer.add(anchor, br, maxZoom, placementZoom);
                    buffer.add(anchor, br, maxZoom, placementZoom);
                    buffer.add(anchor, bl, maxZoom, placementZoom);
                    buffer.add(anchor, bl, maxZoom, placementZoom);
                    buffer.add(anchor, tl, maxZoom, placementZoom);

                    this.elementGroups.collisionBox.current.vertexLength += 8;
                }
            }
        }
    };

    function SymbolInstance(anchor, line, shapedText, shapedIcon, layout, inside,
                            textBoxScale, textPadding, textAlongLine,
                            iconBoxScale, iconPadding, iconAlongLine) {

        this.hasText = !!shapedText;
        this.hasIcon = !!shapedIcon;

        if (this.hasText) {
            this.glyphQuads = inside ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layout, textAlongLine) : [];
            this.textCollisionFeature = new CollisionFeature(line, anchor, shapedText, textBoxScale, textPadding, textAlongLine);
        }

        if (this.hasIcon) {
            this.iconQuads = inside ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layout, iconAlongLine) : [];
            this.iconCollisionFeature = new CollisionFeature(line, anchor, shapedIcon, iconBoxScale, iconPadding, iconAlongLine);
        }
    }

},{&quot;../symbol/anchor&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/anchor.js&quot;,&quot;../symbol/clip_line&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/clip_line.js&quot;,&quot;../symbol/collision_feature&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/collision_feature.js&quot;,&quot;../symbol/get_anchors&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/get_anchors.js&quot;,&quot;../symbol/mergelines&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/mergelines.js&quot;,&quot;../symbol/quads&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/quads.js&quot;,&quot;../symbol/resolve_icons&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/resolve_icons.js&quot;,&quot;../symbol/resolve_text&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/resolve_text.js&quot;,&quot;../symbol/shaping&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/shaping.js&quot;,&quot;../util/token&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/token.js&quot;,&quot;./element_groups&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/element_groups.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/coordinate.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = Coordinate;

    /**
     * A coordinate is a column, row, zoom combination, often used
     * as the data component of a tile.
     *
     * @param {Number} column
     * @param {Number} row
     * @param {Number} zoom
     * @private
     */
    function Coordinate(column, row, zoom) {
        this.column = column;
        this.row = row;
        this.zoom = zoom;
    }

    Coordinate.prototype = {

        /**
         * Create a clone of this coordinate that can be mutated without
         * changing the original coordinate
         *
         * @returns {Coordinate} clone
         * @private
         */
        clone: function() {
            return new Coordinate(this.column, this.row, this.zoom);
        },

        /**
         * Zoom this coordinate to a given zoom level.
         *
         * @param {Number} zoom
         * @returns {Coordinate} zoomed coordinate
         * @private
         */
        zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },

        /**
         * Subtract the column and row values of this coordinate from those
         * of another coordinate. The other coordinat will be zoomed to the
         * same level as `this` before the subtraction occurs
         *
         * @param {Coordinate} c other coordinate
         * @returns {Coordinate} result
         * @private
         */
        sub: function(c) { return this.clone()._sub(c); },

        _zoomTo: function(zoom) {
            var scale = Math.pow(2, zoom - this.zoom);
            this.column *= scale;
            this.row *= scale;
            this.zoom = zoom;
            return this;
        },

        _sub: function(c) {
            c = c.zoomTo(this.zoom);
            this.column -= c.column;
            this.row -= c.row;
            return this;
        }
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = LatLng;

    var wrap = require(&#039;../util/util&#039;).wrap;

    /**
     * Create a latitude, longitude object from a given latitude and longitude pair in degrees.
     *
     * @class LatLng
     * @classdesc A representation of a latitude and longitude point, in degrees.
     * @param {number} lat latitude
     * @param {number} lng longitude
     * @example
     * var latlng = new mapboxgl.LatLng(37.76, -122.44);
     */
    function LatLng(lat, lng) {
        if (isNaN(lat) || isNaN(lng)) {
            throw new Error(&#039;Invalid LatLng object: (&#039; + lat + &#039;, &#039; + lng + &#039;)&#039;);
        }
        this.lat = +lat;
        this.lng = +lng;
    }

    /**
     * Return a new `LatLng` object whose longitude is wrapped to the range (-180, 180).
     *
     * @returns {LatLng} wrapped LatLng object
     * @example
     * var point = mapboxgl.LatLng(0, 200);
     * var wrapped = point.wrap();
     * wrapped.lng; // = -160
     */
    LatLng.prototype.wrap = function () {
        return new LatLng(this.lat, wrap(this.lng, -180, 180));
    };

    /**
     * Convert an array to a `LatLng` object, or return an existing `LatLng` object
     * unchanged.
     *
     * @param {Array&lt;number&gt;|LatLng} input `input` to convert
     * @returns {LatLng} LatLng object or original input
     * @example
     * var ll = mapboxgl.LatLng.convert([10, 10]);
     * var ll2 = new mapboxgl.LatLng(10, 10);
     * ll // = ll2
     */
    LatLng.convert = function (input) {
        if (input instanceof LatLng) {
            return input;
        }
        if (Array.isArray(input)) {
            return new LatLng(input[0], input[1]);
        }
        return input;
    };

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng_bounds.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = LatLngBounds;

    var LatLng = require(&#039;./lat_lng&#039;);

    /**
     * Creates a bounding box from the given pair of points. If parameteres are omitted, a `null` bounding box is created.
     *
     * @class LatLngBounds
     * @classdesc A representation of rectangular box on the earth, defined by its southwest and northeast points in latitude and longitude.
     * @param {LatLng} sw southwest
     * @param {LatLng} ne northeast
     * @example
     * var sw = new mapboxgl.LatLng(0, 0);
     * var ne = new mapboxgl.LatLng(10, -10);
     * var bounds = new mapboxgl.LatLngBounds(sw, ne);
     *
     */
    function LatLngBounds(sw, ne) {
        if (!sw) return;

        var latlngs = ne ? [sw, ne] : sw;

        for (var i = 0, len = latlngs.length; i &lt; len; i++) {
            this.extend(latlngs[i]);
        }
    }

    LatLngBounds.prototype = {

        /**
         * Extend the bounds to include a given LatLng or LatLngBounds.
         *
         * @param {LatLng|LatLngBounds} obj object to extend to
         * @returns {LatLngBounds} `this`
         */
        extend: function(obj) {
            var sw = this._sw,
                ne = this._ne,
                sw2, ne2;

            if (obj instanceof LatLng) {
                sw2 = obj;
                ne2 = obj;

            } else if (obj instanceof LatLngBounds) {
                sw2 = obj._sw;
                ne2 = obj._ne;

                if (!sw2 || !ne2) return this;

            } else {
                return obj ? this.extend(LatLng.convert(obj) || LatLngBounds.convert(obj)) : this;
            }

            if (!sw &amp;&amp; !ne) {
                this._sw = new LatLng(sw2.lat, sw2.lng);
                this._ne = new LatLng(ne2.lat, ne2.lng);

            } else {
                sw.lat = Math.min(sw2.lat, sw.lat);
                sw.lng = Math.min(sw2.lng, sw.lng);
                ne.lat = Math.max(ne2.lat, ne.lat);
                ne.lng = Math.max(ne2.lng, ne.lng);
            }

            return this;
        },

        /**
         * Get the point equidistant from this box&#039;s corners
         * @returns {LatLng} centerpoint
         */
        getCenter: function() {
            return new LatLng((this._sw.lat + this._ne.lat) / 2, (this._sw.lng + this._ne.lng) / 2);
        },

        /**
         * Get southwest corner
         * @returns {LatLng} southwest
         */
        getSouthWest: function() { return this._sw; },

        /**
         * Get northeast corner
         * @returns {LatLng} northeast
         */
        getNorthEast: function() { return this._ne; },

        /**
         * Get northwest corner
         * @returns {LatLng} northwest
         */
        getNorthWest: function() { return new LatLng(this.getNorth(), this.getWest()); },

        /**
         * Get southeast corner
         * @returns {LatLng} southeast
         */
        getSouthEast: function() { return new LatLng(this.getSouth(), this.getEast()); },

        /**
         * Get west edge longitude
         * @returns {number} west
         */
        getWest:  function() { return this._sw.lng; },

        /**
         * Get south edge latitude
         * @returns {number} south
         */
        getSouth: function() { return this._sw.lat; },

        /**
         * Get east edge longitude
         * @returns {number} east
         */
        getEast:  function() { return this._ne.lng; },

        /**
         * Get north edge latitude
         * @returns {number} north
         */
        getNorth: function() { return this._ne.lat; }
    };

// constructs LatLngBounds from an array if necessary
    LatLngBounds.convert = function (a) {
        if (!a || a instanceof LatLngBounds) return a;
        return new LatLngBounds(a);
    };

},{&quot;./lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/transform.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var LatLng = require(&#039;./lat_lng&#039;),
        Point = require(&#039;point-geometry&#039;),
        Coordinate = require(&#039;./coordinate&#039;),
        wrap = require(&#039;../util/util&#039;).wrap,
        interp = require(&#039;../util/interpolate&#039;),
        vec4 = require(&#039;gl-matrix&#039;).vec4,
        mat4 = require(&#039;gl-matrix&#039;).mat4;

    module.exports = Transform;

    /*
     * A single transform, generally used for a single tile to be scaled, rotated, and zoomed.
     *
     * @param {Number} minZoom
     * @param {Number} maxZoom
     * @private
     */
    function Transform(minZoom, maxZoom) {
        this.tileSize = 512; // constant

        this._minZoom = minZoom || 0;
        this._maxZoom = maxZoom || 22;

        this.latRange = [-85.05113, 85.05113];

        this.width = 0;
        this.height = 0;
        this.zoom = 0;
        this.center = new LatLng(0, 0);
        this.angle = 0;
        this._altitude = 1.5;
        this._pitch = 0;
    }

    Transform.prototype = {
        get minZoom() { return this._minZoom; },
        set minZoom(zoom) {
            this._minZoom = zoom;
            this.zoom = Math.max(this.zoom, zoom);
        },

        get maxZoom() { return this._maxZoom; },
        set maxZoom(zoom) {
            this._maxZoom = zoom;
            this.zoom = Math.min(this.zoom, zoom);
        },

        get worldSize() {
            return this.tileSize * this.scale;
        },

        get centerPoint() {
            return this.size._div(2);
        },

        get size() {
            return new Point(this.width, this.height);
        },

        get bearing() {
            return -this.angle / Math.PI * 180;
        },
        set bearing(bearing) {
            this.angle = -wrap(bearing, -180, 180) * Math.PI / 180;
        },

        get pitch() {
            return this._pitch / Math.PI * 180;
        },
        set pitch(pitch) {
            this._pitch = Math.min(60, pitch) / 180 * Math.PI;
        },

        get altitude() {
            return this._altitude;
        },
        set altitude(altitude) {
            this._altitude = Math.max(0.75, altitude);
        },

        get zoom() { return this._zoom; },
        set zoom(zoom) {
            zoom = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
            this._zoom = zoom;
            this.scale = this.zoomScale(zoom);
            this.tileZoom = Math.floor(zoom);
            this.zoomFraction = zoom - this.tileZoom;
            this._constrain();
        },

        zoomScale: function(zoom) { return Math.pow(2, zoom); },
        scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

        project: function(latlng, worldSize) {
            return new Point(
                this.lngX(latlng.lng, worldSize),
                this.latY(latlng.lat, worldSize));
        },

        unproject: function(point, worldSize) {
            return new LatLng(
                this.yLat(point.y, worldSize),
                this.xLng(point.x, worldSize));
        },

        get x() { return this.lngX(this.center.lng); },
        get y() { return this.latY(this.center.lat); },

        get point() { return new Point(this.x, this.y); },

        /**
         * lat/lon &lt;-&gt; absolute pixel coords conversion
         * @param {Number} lon
         * @param {Number} [worldSize=this.worldSize]
         * @returns {Number} pixel coordinate
         * @private
         */
        lngX: function(lon, worldSize) {
            return (180 + lon) * (worldSize || this.worldSize) / 360;
        },
        /**
         * latitude to absolute y coord
         *
         * @param {Number} lat
         * @param {Number} [worldSize=this.worldSize]
         * @returns {Number} pixel coordinate
         * @private
         */
        latY: function(lat, worldSize) {
            var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
            return (180 - y) * (worldSize || this.worldSize) / 360;
        },

        xLng: function(x, worldSize) {
            return x * 360 / (worldSize || this.worldSize) - 180;
        },
        yLat: function(y, worldSize) {
            var y2 = 180 - y * 360 / (worldSize || this.worldSize);
            return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
        },

        panBy: function(offset) {
            var point = this.centerPoint._add(offset);
            this.center = this.pointLocation(point);
            this._constrain();
        },

        setLocationAtPoint: function(latlng, point) {
            var c = this.locationCoordinate(latlng);
            var coordAtPoint = this.pointCoordinate(point);
            var coordCenter = this.pointCoordinate(this.centerPoint);

            var translate = coordAtPoint._sub(c);
            this.center = this.coordinateLocation(coordCenter._sub(translate));

            this._constrain();
        },

        setZoomAround: function(zoom, center) {
            var p = this.locationPoint(center);
            this.zoom = zoom;
            this.setLocationAtPoint(center, p);
        },

        setBearingAround: function(bearing, center) {
            var p = this.locationPoint(center);
            this.bearing = bearing;
            this.setLocationAtPoint(center, p);
        },

        locationPoint: function(latlng) {
            return this.coordinatePoint(this.locationCoordinate(latlng));
        },

        pointLocation: function(p) {
            return this.coordinateLocation(this.pointCoordinate(p));
        },

        locationCoordinate: function(latlng) {
            var k = this.zoomScale(this.tileZoom) / this.worldSize;
            return new Coordinate(
                    this.lngX(latlng.lng) * k,
                    this.latY(latlng.lat) * k,
                this.tileZoom);
        },

        coordinateLocation: function(coord) {
            var worldSize = this.zoomScale(coord.zoom);
            return new LatLng(
                this.yLat(coord.row, worldSize),
                this.xLng(coord.column, worldSize));
        },

        pointCoordinate: function(p, targetZ) {

            if (targetZ === undefined) targetZ = 0;

            var matrix = this.coordinatePointMatrix(this.tileZoom);
            var inverted = mat4.invert(new Float64Array(16), matrix);

            if (!inverted) throw &quot;failed to invert matrix&quot;;

            // since we don&#039;t know the correct projected z value for the point,
            // unproject two points to get a line and then find the point on that
            // line with z=0

            var coord0 = vec4.transformMat4([], [p.x, p.y, 0, 1], inverted);
            var coord1 = vec4.transformMat4([], [p.x, p.y, 1, 1], inverted);

            var w0 = coord0[3];
            var w1 = coord1[3];
            var x0 = coord0[0] / w0;
            var x1 = coord1[0] / w1;
            var y0 = coord0[1] / w0;
            var y1 = coord1[1] / w1;
            var z0 = coord0[2] / w0;
            var z1 = coord1[2] / w1;


            var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);

            return new Coordinate(
                interp(x0, x1, t),
                interp(y0, y1, t),
                this.tileZoom);
        },

        coordinatePoint: function(coord) {
            var matrix = this.coordinatePointMatrix(coord.zoom);
            var p = vec4.transformMat4([], [coord.column, coord.row, 0, 1], matrix);
            return new Point(p[0] / p[3], p[1] / p[3]);
        },

        coordinatePointMatrix: function(z) {
            var proj = this.getProjMatrix();
            var scale = this.worldSize / this.zoomScale(z);
            mat4.scale(proj, proj, [scale, scale, 1]);
            mat4.multiply(proj, this.getPixelMatrix(), proj);
            return proj;
        },

        // converts gl coordinates -1..1 to pixels 0..width
        getPixelMatrix: function() {
            var m = mat4.create();
            mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
            mat4.translate(m, m, [1, -1, 0]);
            return m;
        },

        _constrain: function() {
            if (!this.center) return;

            var minY, maxY, minX, maxX, sy, sx, x2, y2,
                size = this.size;

            if (this.latRange) {
                minY = this.latY(this.latRange[1]);
                maxY = this.latY(this.latRange[0]);
                sy = maxY - minY &lt; size.y ? size.y / (maxY - minY) : 0;
            }

            if (this.lngRange) {
                minX = this.lngX(this.lngRange[0]);
                maxX = this.lngX(this.lngRange[1]);
                sx = maxX - minX &lt; size.x ? size.x / (maxX - minX) : 0;
            }

            // how much the map should scale to fit the screen into given latitude/longitude ranges
            var s = Math.max(sx || 0, sy || 0);

            if (s) {
                this.center = this.unproject(new Point(
                    sx ? (maxX + minX) / 2 : this.x,
                    sy ? (maxY + minY) / 2 : this.y));
                this.zoom += this.scaleZoom(s);
                return;
            }

            if (this.latRange) {
                var y = this.y,
                    h2 = size.y / 2;

                if (y - h2 &lt; minY) y2 = minY + h2;
                if (y + h2 &gt; maxY) y2 = maxY - h2;
            }

            if (this.lngRange) {
                var x = this.x,
                    w2 = size.x / 2;

                if (x - w2 &lt; minX) x2 = minX + w2;
                if (x + w2 &gt; maxX) x2 = maxX - w2;
            }

            // pan the map if the screen goes off the range
            if (x2 !== undefined || y2 !== undefined) {
                this.center = this.unproject(new Point(
                        x2 !== undefined ? x2 : this.x,
                        y2 !== undefined ? y2 : this.y));
            }
        },

        getProjMatrix: function() {
            var m = new Float64Array(16);
            mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, this.altitude + 1);

            mat4.translate(m, m, [0, 0, -this.altitude]);

            // After the rotateX, z values are in pixel units. Convert them to
            // altitude unites. 1 altitude unit = the screen height.
            mat4.scale(m, m, [1, -1, 1 / this.height]);

            mat4.rotateX(m, m, this._pitch);
            mat4.rotateZ(m, m, this.angle);
            mat4.translate(m, m, [-this.x, -this.y, 0]);
            return m;
        }
    };

},{&quot;../util/interpolate&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/interpolate.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./coordinate&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/coordinate.js&quot;,&quot;./lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/lib/debugtext.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
    var simplexFont = {
        &quot; &quot;: [16, []],
        &quot;!&quot;: [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        &quot;\&quot;&quot;: [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
        &quot;#&quot;: [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
        &quot;$&quot;: [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
        &quot;%&quot;: [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
        &quot;&amp;&quot;: [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
        &quot;&#039;&quot;: [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
        &quot;(&quot;: [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
        &quot;)&quot;: [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
        &quot;*&quot;: [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
        &quot;+&quot;: [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
        &quot;,&quot;: [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
        &quot;-&quot;: [26, [4, 9, 22, 9]],
        &quot;.&quot;: [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        &quot;/&quot;: [22, [20, 25, 2, -7]],
        &quot;0&quot;: [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
        &quot;1&quot;: [20, [6, 17, 8, 18, 11, 21, 11, 0]],
        &quot;2&quot;: [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
        &quot;3&quot;: [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        &quot;4&quot;: [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
        &quot;5&quot;: [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
        &quot;6&quot;: [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
        &quot;7&quot;: [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
        &quot;8&quot;: [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
        &quot;9&quot;: [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
        &quot;:&quot;: [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
        &quot;;&quot;: [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
        &quot;&lt;&quot;: [24, [20, 18, 4, 9, 20, 0]],
        &quot;=&quot;: [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
        &quot;&gt;&quot;: [24, [4, 18, 20, 9, 4, 0]],
        &quot;?&quot;: [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
        &quot;@&quot;: [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
        &quot;A&quot;: [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
        &quot;B&quot;: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
        &quot;C&quot;: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
        &quot;D&quot;: [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
        &quot;E&quot;: [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
        &quot;F&quot;: [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
        &quot;G&quot;: [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
        &quot;H&quot;: [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
        &quot;I&quot;: [8, [4, 21, 4, 0]],
        &quot;J&quot;: [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
        &quot;K&quot;: [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
        &quot;L&quot;: [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
        &quot;M&quot;: [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
        &quot;N&quot;: [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
        &quot;O&quot;: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
        &quot;P&quot;: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
        &quot;Q&quot;: [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
        &quot;R&quot;: [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
        &quot;S&quot;: [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
        &quot;T&quot;: [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
        &quot;U&quot;: [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
        &quot;V&quot;: [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
        &quot;W&quot;: [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
        &quot;X&quot;: [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
        &quot;Y&quot;: [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
        &quot;Z&quot;: [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
        &quot;[&quot;: [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
        &quot;\\&quot;: [14, [0, 21, 14, -3]],
        &quot;]&quot;: [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
        &quot;^&quot;: [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
        &quot;_&quot;: [16, [0, -2, 16, -2]],
        &quot;`&quot;: [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
        &quot;a&quot;: [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        &quot;b&quot;: [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
        &quot;c&quot;: [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        &quot;d&quot;: [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        &quot;e&quot;: [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        &quot;f&quot;: [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
        &quot;g&quot;: [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        &quot;h&quot;: [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        &quot;i&quot;: [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
        &quot;j&quot;: [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
        &quot;k&quot;: [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
        &quot;l&quot;: [8, [4, 21, 4, 0]],
        &quot;m&quot;: [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
        &quot;n&quot;: [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
        &quot;o&quot;: [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
        &quot;p&quot;: [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
        &quot;q&quot;: [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
        &quot;r&quot;: [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
        &quot;s&quot;: [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
        &quot;t&quot;: [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
        &quot;u&quot;: [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
        &quot;v&quot;: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
        &quot;w&quot;: [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
        &quot;x&quot;: [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
        &quot;y&quot;: [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
        &quot;z&quot;: [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
        &quot;{&quot;: [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
        &quot;|&quot;: [8, [4, 25, 4, -7]],
        &quot;}&quot;: [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
        &quot;~&quot;: [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
    };

    module.exports = function textVertices(text, left, baseline, scale) {
        scale = scale || 1;

        var strokes = [],
            i, len, j, len2, glyph, x, y, prev;

        for (i = 0, len = text.length; i &lt; len; i++) {
            glyph = simplexFont[text[i]];
            if (!glyph) continue;
            prev = null;

            for (j = 0, len2 = glyph[1].length; j &lt; len2; j += 2) {
                if (glyph[1][j] === -1 &amp;&amp; glyph[1][j + 1] === -1) {
                    prev = null;

                } else {
                    x = left + glyph[1][j] * scale;
                    y = baseline - glyph[1][j + 1] * scale;
                    if (prev) {
                        strokes.push(prev.x, prev.y, x, y);
                    }
                    prev = {x: x, y: y};
                }
            }
            left += glyph[0] * scale;
        }

        return strokes;
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/mapbox-gl.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    /**
     * mapboxgl is a A WebGL JavaScript interactive maps library that can render
     * [Mapbox vector tiles](https://www.mapbox.com/blog/vector-tiles/).
     *
     * @module mapboxgl
     * @summary WebGL JavaScript map library
     */
    if (typeof window === &#039;undefined&#039;) {
        new (require(&#039;./source/worker&#039;))(self); /*eslint no-new: 0*/
    } else {
        // jshint -W079
        var mapboxgl = module.exports = window.mapboxgl = {};

        mapboxgl.Map = require(&#039;./ui/map&#039;);
        mapboxgl.Navigation = require(&#039;./ui/control/navigation&#039;);
        mapboxgl.Attribution = require(&#039;./ui/control/attribution&#039;);
        mapboxgl.Popup = require(&#039;./ui/popup&#039;);

        mapboxgl.GeoJSONSource = require(&#039;./source/geojson_source&#039;);
        mapboxgl.VideoSource = require(&#039;./source/video_source&#039;);

        mapboxgl.Style = require(&#039;./style/style&#039;);

        mapboxgl.LatLng = require(&#039;./geo/lat_lng&#039;);
        mapboxgl.LatLngBounds = require(&#039;./geo/lat_lng_bounds&#039;);
        mapboxgl.Point = require(&#039;point-geometry&#039;);

        mapboxgl.Evented = require(&#039;./util/evented&#039;);
        mapboxgl.util = require(&#039;./util/util&#039;);

        mapboxgl.supported = require(&#039;./util/browser&#039;).supported;

        var ajax = require(&#039;./util/ajax&#039;);
        mapboxgl.util.getJSON = ajax.getJSON;
        mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

        var config = require(&#039;./util/config&#039;);
        mapboxgl.config = config;

        Object.defineProperty(mapboxgl, &#039;accessToken&#039;, {
            get: function() { return config.ACCESS_TOKEN; },
            set: function(token) { config.ACCESS_TOKEN = token; }
        });
    }

},{&quot;./geo/lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;,&quot;./geo/lat_lng_bounds&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng_bounds.js&quot;,&quot;./source/geojson_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/geojson_source.js&quot;,&quot;./source/video_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/video_source.js&quot;,&quot;./source/worker&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/worker.js&quot;,&quot;./style/style&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style.js&quot;,&quot;./ui/control/attribution&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/attribution.js&quot;,&quot;./ui/control/navigation&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/navigation.js&quot;,&quot;./ui/map&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/map.js&quot;,&quot;./ui/popup&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/popup.js&quot;,&quot;./util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;./util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;./util/config&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/config.js&quot;,&quot;./util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;./util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_background.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var mat3 = require(&#039;gl-matrix&#039;).mat3;

    module.exports = drawBackground;

    function drawBackground(painter, layer, posMatrix) {
        var gl = painter.gl;
        var color = layer.paint[&#039;background-color&#039;];
        var image = layer.paint[&#039;background-image&#039;];
        var opacity = layer.paint[&#039;background-opacity&#039;];
        var shader;

        var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
        var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;

        if (imagePosA &amp;&amp; imagePosB) {
            // Draw texture fill
            shader = painter.patternShader;
            gl.switchShader(shader, posMatrix);
            gl.uniform1i(shader.u_image, 0);
            gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
            gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
            gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
            gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
            gl.uniform1f(shader.u_opacity, opacity);

            var transform = painter.transform;
            var sizeA = imagePosA.size;
            var sizeB = imagePosB.size;
            var center = transform.locationCoordinate(transform.center);
            var scale = 1 / Math.pow(2, transform.zoomFraction);

            gl.uniform1f(shader.u_mix, image.t);

            var matrixA = mat3.create();
            mat3.scale(matrixA, matrixA, [
                    1 / (sizeA[0] * image.fromScale),
                    1 / (sizeA[1] * image.fromScale)
            ]);
            mat3.translate(matrixA, matrixA, [
                    (center.column * transform.tileSize) % (sizeA[0] * image.fromScale),
                    (center.row    * transform.tileSize) % (sizeA[1] * image.fromScale)
            ]);
            mat3.rotate(matrixA, matrixA, -transform.angle);
            mat3.scale(matrixA, matrixA, [
                    scale * transform.width  / 2,
                    -scale * transform.height / 2
            ]);

            var matrixB = mat3.create();
            mat3.scale(matrixB, matrixB, [
                    1 / (sizeB[0] * image.toScale),
                    1 / (sizeB[1] * image.toScale)
            ]);
            mat3.translate(matrixB, matrixB, [
                    (center.column * transform.tileSize) % (sizeB[0] * image.toScale),
                    (center.row    * transform.tileSize) % (sizeB[1] * image.toScale)
            ]);
            mat3.rotate(matrixB, matrixB, -transform.angle);
            mat3.scale(matrixB, matrixB, [
                    scale * transform.width  / 2,
                    -scale * transform.height / 2
            ]);

            gl.uniformMatrix3fv(shader.u_patternmatrix_a, false, matrixA);
            gl.uniformMatrix3fv(shader.u_patternmatrix_b, false, matrixB);

            painter.spriteAtlas.bind(gl, true);

        } else {
            // Draw filling rectangle.
            shader = painter.fillShader;
            gl.switchShader(shader, posMatrix);
            gl.uniform4fv(shader.u_color, color);
        }

        gl.disable(gl.STENCIL_TEST);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.backgroundBuffer);
        gl.vertexAttribPointer(shader.a_pos, painter.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.backgroundBuffer.itemCount);
        gl.enable(gl.STENCIL_TEST);

        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
    }

},{&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_collision_debug.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = drawPlacementDebug;

    function drawPlacementDebug(painter, layer, posMatrix, tile) {

        var elementGroups = tile.elementGroups[layer.ref || layer.id].collisionBox;
        if (!elementGroups) return;

        var gl = painter.gl;
        var buffer = tile.buffers.collisionBoxVertex;
        var shader = painter.collisionBoxShader;

        gl.enable(gl.STENCIL_TEST);

        gl.switchShader(shader, posMatrix);
        buffer.bind(gl, shader);
        gl.lineWidth(3);

        var stride = 12;
        gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, stride, 0);
        gl.vertexAttribPointer(shader.a_extrude, 2, gl.SHORT, false, stride, 4);
        gl.vertexAttribPointer(shader.a_data, 2, gl.UNSIGNED_BYTE, false, stride, 8);

        gl.uniform1f(shader.u_scale, Math.pow(2, painter.transform.zoom - tile.zoom));
        gl.uniform1f(shader.u_zoom, painter.transform.zoom * 10);
        gl.uniform1f(shader.u_maxzoom, (tile.zoom + 1) * 10);

        var begin = elementGroups.groups[0].vertexStartIndex;
        var len = elementGroups.groups[0].vertexLength;
        gl.drawArrays(gl.LINES, begin, len);

        gl.disable(gl.STENCIL_TEST);
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_debug.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var textVertices = require(&#039;../lib/debugtext&#039;);
    var browser = require(&#039;../util/browser&#039;);
    var TileCoord = require(&#039;../source/tile_coord&#039;);

    module.exports = drawDebug;

    function drawDebug(painter, tile) {
        var gl = painter.gl;
        var pos = TileCoord.fromID(tile.id);

        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        gl.switchShader(painter.debugShader, tile.posMatrix);

        // draw bounding rectangle
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugBuffer);
        gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.uniform4f(painter.debugShader.u_color, 1, 0, 0, 1);
        gl.lineWidth(4);
        gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.itemCount);

        // draw tile coordinate
        var coord = pos.z + &#039;/&#039; + pos.x + &#039;/&#039; + pos.y;

        var vertices = textVertices(coord, 50, 200, 5);

        gl.bindBuffer(gl.ARRAY_BUFFER, painter.debugTextBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Int16Array(vertices), gl.STREAM_DRAW);
        gl.vertexAttribPointer(painter.debugShader.a_pos, painter.debugTextBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.lineWidth(8 * browser.devicePixelRatio);
        gl.uniform4f(painter.debugShader.u_color, 1, 1, 1, 1);
        gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);
        gl.lineWidth(2 * browser.devicePixelRatio);
        gl.uniform4f(painter.debugShader.u_color, 0, 0, 0, 1);
        gl.drawArrays(gl.LINES, 0, vertices.length / painter.debugTextBuffer.itemSize);

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
    }

},{&quot;../lib/debugtext&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/lib/debugtext.js&quot;,&quot;../source/tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_fill.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var browser = require(&#039;../util/browser&#039;);
    var mat3 = require(&#039;gl-matrix&#039;).mat3;

    module.exports = drawFill;

    function drawFill(painter, layer, posMatrix, tile) {
        // No data
        if (!tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        var gl = painter.gl;
        var translatedPosMatrix = painter.translateMatrix(posMatrix, tile, layer.paint[&#039;fill-translate&#039;], layer.paint[&#039;fill-translate-anchor&#039;]);

        var color = layer.paint[&#039;fill-color&#039;];

        var vertex, elements, group, count;

        // Draw the stencil mask.

        // We&#039;re only drawing to the first seven bits (== support a maximum of
        // 127 overlapping polygons in one place before we get rendering errors).
        gl.stencilMask(0x3F);
        gl.clear(gl.STENCIL_BUFFER_BIT);

        // Draw front facing triangles. Wherever the 0x80 bit is 1, we are
        // increasing the lower 7 bits by one if the triangle is a front-facing
        // triangle. This means that all visible polygons should be in CCW
        // orientation, while all holes (see below) are in CW orientation.
        gl.stencilFunc(gl.NOTEQUAL, 0x80, 0x80);

        // When we do a nonzero fill, we count the number of times a pixel is
        // covered by a counterclockwise polygon, and subtract the number of
        // times it is &quot;uncovered&quot; by a clockwise polygon.
        gl.stencilOpSeparate(gl.FRONT, gl.INCR_WRAP, gl.KEEP, gl.KEEP);
        gl.stencilOpSeparate(gl.BACK, gl.DECR_WRAP, gl.KEEP, gl.KEEP);

        // When drawing a shape, we first draw all shapes to the stencil buffer
        // and incrementing all areas where polygons are
        gl.colorMask(false, false, false, false);

        // Draw the actual triangle fan into the stencil buffer.
        gl.switchShader(painter.fillShader, translatedPosMatrix);

        // Draw all buffers
        vertex = tile.buffers.fillVertex;
        vertex.bind(gl);
        elements = tile.buffers.fillElement;
        elements.bind(gl);

        var offset, elementOffset;

        for (var i = 0; i &lt; elementGroups.groups.length; i++) {
            group = elementGroups.groups[i];
            offset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(painter.fillShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

            count = group.elementLength * 3;
            elementOffset = group.elementStartIndex * elements.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

        // Now that we have the stencil mask in the stencil buffer, we can start
        // writing to the color buffer.
        gl.colorMask(true, true, true, true);

        // From now on, we don&#039;t want to update the stencil buffer anymore.
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(0x0);

        var strokeColor = layer.paint[&#039;fill-outline-color&#039;];

        // Because we&#039;re drawing top-to-bottom, and we update the stencil mask
        // below, we have to draw the outline first (!)
        if (layer.paint[&#039;fill-antialias&#039;] === true &amp;&amp; !(layer.paint[&#039;fill-image&#039;] &amp;&amp; !strokeColor)) {
            gl.switchShader(painter.outlineShader, translatedPosMatrix);
            gl.lineWidth(2 * browser.devicePixelRatio);

            if (strokeColor) {
                // If we defined a different color for the fill outline, we are
                // going to ignore the bits in 0x3F and just care about the global
                // clipping mask.
                gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
            } else {
                // Otherwise, we only want to draw the antialiased parts that are
                // *outside* the current shape. This is important in case the fill
                // or stroke color is translucent. If we wouldn&#039;t clip to outside
                // the current shape, some pixels from the outline stroke overlapped
                // the (non-antialiased) fill.
                gl.stencilFunc(gl.EQUAL, 0x80, 0xBF);
            }

            gl.uniform2f(painter.outlineShader.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.uniform4fv(painter.outlineShader.u_color, strokeColor ? strokeColor : color);

            // Draw all buffers
            vertex = tile.buffers.fillVertex;
            elements = tile.buffers.outlineElement;
            elements.bind(gl);

            for (var k = 0; k &lt; elementGroups.groups.length; k++) {
                group = elementGroups.groups[k];
                offset = group.vertexStartIndex * vertex.itemSize;
                gl.vertexAttribPointer(painter.outlineShader.a_pos, 2, gl.SHORT, false, 4, offset + 0);

                count = group.secondElementLength * 2;
                elementOffset = group.secondElementStartIndex * elements.itemSize;
                gl.drawElements(gl.LINES, count, gl.UNSIGNED_SHORT, elementOffset);
            }
        }

        var image = layer.paint[&#039;fill-image&#039;];
        var opacity = layer.paint[&#039;fill-opacity&#039;] || 1;
        var shader;

        if (image) {
            // Draw texture fill
            var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
            var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
            if (!imagePosA || !imagePosB) return;

            shader = painter.patternShader;
            gl.switchShader(shader, posMatrix);
            gl.uniform1i(shader.u_image, 0);
            gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
            gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
            gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
            gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
            gl.uniform1f(shader.u_opacity, opacity);
            gl.uniform1f(shader.u_mix, image.t);

            var factor = (4096 / tile.tileSize) / Math.pow(2, painter.transform.tileZoom - tile.zoom);

            var matrixA = mat3.create();
            mat3.scale(matrixA, matrixA, [
                    1 / (imagePosA.size[0] * factor * image.fromScale),
                    1 / (imagePosA.size[1] * factor * image.fromScale)
            ]);

            var matrixB = mat3.create();
            mat3.scale(matrixB, matrixB, [
                    1 / (imagePosB.size[0] * factor * image.toScale),
                    1 / (imagePosB.size[1] * factor * image.toScale)
            ]);

            gl.uniformMatrix3fv(shader.u_patternmatrix_a, false, matrixA);
            gl.uniformMatrix3fv(shader.u_patternmatrix_b, false, matrixB);

            painter.spriteAtlas.bind(gl, true);

        } else {
            // Draw filling rectangle.
            shader = painter.fillShader;
            gl.switchShader(shader, posMatrix);
            gl.uniform4fv(shader.u_color, color);
        }

        // Only draw regions that we marked
        gl.stencilFunc(gl.NOTEQUAL, 0x0, 0x3F);
        gl.bindBuffer(gl.ARRAY_BUFFER, painter.tileExtentBuffer);
        gl.vertexAttribPointer(shader.a_pos, painter.tileExtentBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.itemCount);

        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
    }

},{&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_line.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var browser = require(&#039;../util/browser&#039;);
    var mat2 = require(&#039;gl-matrix&#039;).mat2;

    module.exports = function drawLine(painter, layer, posMatrix, tile) {
        // No data
        if (!tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        var gl = painter.gl;

        // don&#039;t draw zero-width lines
        if (layer.paint[&#039;line-width&#039;] &lt;= 0) return;

        // the distance over which the line edge fades out.
        // Retina devices need a smaller distance to avoid aliasing.
        var antialiasing = 1 / browser.devicePixelRatio;

        var blur = layer.paint[&#039;line-blur&#039;] + antialiasing;
        var edgeWidth = layer.paint[&#039;line-width&#039;] / 2;
        var inset = -1;
        var offset = 0;
        var shift = 0;

        if (layer.paint[&#039;line-gap-width&#039;] &gt; 0) {
            inset = layer.paint[&#039;line-gap-width&#039;] / 2 + antialiasing * 0.5;
            edgeWidth = layer.paint[&#039;line-width&#039;];

            // shift outer lines half a pixel towards the middle to eliminate the crack
            offset = inset - antialiasing / 2;
        }

        var outset = offset + edgeWidth + antialiasing / 2 + shift;

        var color = layer.paint[&#039;line-color&#039;];
        var ratio = painter.transform.scale / (1 &lt;&lt; tile.zoom) / (4096 / tile.tileSize);
        var vtxMatrix = painter.translateMatrix(posMatrix, tile, layer.paint[&#039;line-translate&#039;], layer.paint[&#039;line-translate-anchor&#039;]);

        var tr = painter.transform;


        var antialiasingMatrix = mat2.create();
        mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
        mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);

        // calculate how much longer the real world distance is at the top of the screen
        // than at the middle of the screen.
        var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
        var x = tr.height / 2 * Math.tan(tr._pitch);
        var extra = (topedgelength + x) / topedgelength - 1;

        var shader;


        var dasharray = layer.paint[&#039;line-dasharray&#039;];
        var image = layer.paint[&#039;line-image&#039;];

        if (dasharray) {

            shader = painter.linesdfpatternShader;
            gl.switchShader(shader, vtxMatrix, tile.exMatrix);

            gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform1f(shader.u_blur, blur);
            gl.uniform4fv(shader.u_color, color);

            var posA = painter.lineAtlas.getDash(dasharray.from, layer.layout[&#039;line-cap&#039;] === &#039;round&#039;);
            var posB = painter.lineAtlas.getDash(dasharray.to, layer.layout[&#039;line-cap&#039;] === &#039;round&#039;);
            painter.lineAtlas.bind(gl);

            var patternratio = Math.pow(2, Math.floor(Math.log(painter.transform.scale) / Math.LN2) - tile.zoom) / 8;
            var scaleA = [patternratio / posA.width / dasharray.fromScale, -posA.height / 2];
            var gammaA = painter.lineAtlas.width / (dasharray.fromScale * posA.width * 256 * browser.devicePixelRatio) / 2;
            var scaleB = [patternratio / posB.width / dasharray.toScale, -posB.height / 2];
            var gammaB = painter.lineAtlas.width / (dasharray.toScale * posB.width * 256 * browser.devicePixelRatio) / 2;

            gl.uniform2fv(shader.u_patternscale_a, scaleA);
            gl.uniform1f(shader.u_tex_y_a, posA.y);
            gl.uniform2fv(shader.u_patternscale_b, scaleB);
            gl.uniform1f(shader.u_tex_y_b, posB.y);

            gl.uniform1i(shader.u_image, 0);
            gl.uniform1f(shader.u_sdfgamma, Math.max(gammaA, gammaB));
            gl.uniform1f(shader.u_mix, dasharray.t);

        } else if (image) {
            var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
            var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
            if (!imagePosA || !imagePosB) return;
            var factor = 4096 / tile.tileSize / Math.pow(2, painter.transform.tileZoom - tile.zoom);

            painter.spriteAtlas.bind(gl, true);

            shader = painter.linepatternShader;
            gl.switchShader(shader, vtxMatrix, tile.exMatrix);

            gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform1f(shader.u_blur, blur);

            gl.uniform2fv(shader.u_pattern_size_a, [imagePosA.size[0] * factor * image.fromScale, imagePosB.size[1] ]);
            gl.uniform2fv(shader.u_pattern_size_b, [imagePosB.size[0] * factor * image.toScale, imagePosB.size[1] ]);
            gl.uniform2fv(shader.u_pattern_tl_a, imagePosA.tl);
            gl.uniform2fv(shader.u_pattern_br_a, imagePosA.br);
            gl.uniform2fv(shader.u_pattern_tl_b, imagePosB.tl);
            gl.uniform2fv(shader.u_pattern_br_b, imagePosB.br);
            gl.uniform1f(shader.u_fade, image.t);
            gl.uniform1f(shader.u_opacity, layer.paint[&#039;line-opacity&#039;]);

        } else {
            shader = painter.lineShader;
            gl.switchShader(shader, vtxMatrix, tile.exMatrix);

            gl.uniform2fv(shader.u_linewidth, [ outset, inset ]);
            gl.uniform1f(shader.u_ratio, ratio);
            gl.uniform1f(shader.u_blur, blur);
            gl.uniform1f(shader.u_extra, extra);
            gl.uniformMatrix2fv(shader.u_antialiasingmatrix, false, antialiasingMatrix);

            gl.uniform4fv(shader.u_color, color);
        }

        var vertex = tile.buffers.lineVertex;
        vertex.bind(gl);
        var element = tile.buffers.lineElement;
        element.bind(gl);

        for (var i = 0; i &lt; elementGroups.groups.length; i++) {
            var group = elementGroups.groups[i];
            var vtxOffset = group.vertexStartIndex * vertex.itemSize;
            gl.vertexAttribPointer(shader.a_pos, 2, gl.SHORT, false, 8, vtxOffset + 0);
            gl.vertexAttribPointer(shader.a_data, 4, gl.BYTE, false, 8, vtxOffset + 4);

            var count = group.elementLength * 3;
            var elementOffset = group.elementStartIndex * element.itemSize;
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
        }

    };

},{&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_raster.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var TileCoord = require(&#039;../source/tile_coord&#039;);
    var util = require(&#039;../util/util&#039;);

    module.exports = drawRaster;

    function drawRaster(painter, layer, posMatrix, tile) {
        var gl = painter.gl;

        gl.disable(gl.STENCIL_TEST);

        var shader = painter.rasterShader;
        gl.switchShader(shader, posMatrix);

        // color parameters
        gl.uniform1f(shader.u_brightness_low, layer.paint[&#039;raster-brightness-min&#039;]);
        gl.uniform1f(shader.u_brightness_high, layer.paint[&#039;raster-brightness-max&#039;]);
        gl.uniform1f(shader.u_saturation_factor, saturationFactor(layer.paint[&#039;raster-saturation&#039;]));
        gl.uniform1f(shader.u_contrast_factor, contrastFactor(layer.paint[&#039;raster-contrast&#039;]));
        gl.uniform3fv(shader.u_spin_weights, spinWeights(layer.paint[&#039;raster-hue-rotate&#039;]));

        var parentTile = tile.source &amp;&amp; tile.source._pyramid.findLoadedParent(tile.id, 0, {}),
            opacities = getOpacities(tile, parentTile, layer, painter.transform);

        var parentScaleBy, parentTL;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tile.texture);

        if (parentTile) {
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);

            var tilePos = TileCoord.fromID(tile.id);
            var parentPos = parentTile &amp;&amp; TileCoord.fromID(parentTile.id);
            parentScaleBy = Math.pow(2, parentPos.z - tilePos.z);
            parentTL = [tilePos.x * parentScaleBy % 1, tilePos.y * parentScaleBy % 1];
        } else {
            opacities[1] = 0;
        }

        // cross-fade parameters
        gl.uniform2fv(shader.u_tl_parent, parentTL || [0, 0]);
        gl.uniform1f(shader.u_scale_parent, parentScaleBy || 1);
        gl.uniform1f(shader.u_buffer_scale, 1);
        gl.uniform1f(shader.u_opacity0, opacities[0]);
        gl.uniform1f(shader.u_opacity1, opacities[1]);
        gl.uniform1i(shader.u_image0, 0);
        gl.uniform1i(shader.u_image1, 1);

        gl.bindBuffer(gl.ARRAY_BUFFER, tile.boundsBuffer || painter.tileExtentBuffer);

        gl.vertexAttribPointer(shader.a_pos,         2, gl.SHORT, false, 8, 0);
        gl.vertexAttribPointer(shader.a_texture_pos, 2, gl.SHORT, false, 8, 4);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.enable(gl.STENCIL_TEST);
    }

    function spinWeights(angle) {
        angle *= Math.PI / 180;
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        return [
                (2 * c + 1) / 3,
                (-Math.sqrt(3) * s - c + 1) / 3,
                (Math.sqrt(3) * s - c + 1) / 3
        ];
    }

    function contrastFactor(contrast) {
        return contrast &gt; 0 ?
            1 / (1 - contrast) :
            1 + contrast;
    }

    function saturationFactor(saturation) {
        return saturation &gt; 0 ?
            1 - 1 / (1.001 - saturation) :
            -saturation;
    }

    function getOpacities(tile, parentTile, layer, transform) {
        if (!tile.source) return [1, 0];

        var now = new Date().getTime();

        var fadeDuration = layer.paint[&#039;raster-fade-duration&#039;];
        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

        var tilePos = TileCoord.fromID(tile.id);
        var parentPos = parentTile &amp;&amp; TileCoord.fromID(parentTile.id);

        var idealZ = tile.source._pyramid.coveringZoomLevel(transform);
        var parentFurther = parentTile ? Math.abs(parentPos.z - idealZ) &gt; Math.abs(tilePos.z - idealZ) : false;

        var opacity = [];
        if (!parentTile || parentFurther) {
            // if no parent or parent is older
            opacity[0] = util.clamp(sinceTile, 0, 1);
            opacity[1] = 1 - opacity[0];
        } else {
            // parent is younger, zooming out
            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
            opacity[1] = 1 - opacity[0];
        }

        var op = layer.paint[&#039;raster-opacity&#039;];
        opacity[0] *= op;
        opacity[1] *= op;

        return opacity;
    }

},{&quot;../source/tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_symbol.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var browser = require(&#039;../util/browser&#039;);
    var mat4 = require(&#039;gl-matrix&#039;).mat4;

    var drawCollisionDebug = require(&#039;./draw_collision_debug&#039;);

    module.exports = drawSymbols;

    function drawSymbols(painter, layer, posMatrix, tile) {
        // No data
        if (!tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        var gl = painter.gl;
        gl.disable(gl.STENCIL_TEST);
        if (elementGroups.text.groups.length) {
            drawSymbol(painter, layer, posMatrix, tile, elementGroups.text, &#039;text&#039;, true);
        }
        if (elementGroups.icon.groups.length) {
            drawSymbol(painter, layer, posMatrix, tile, elementGroups.icon, &#039;icon&#039;, elementGroups.sdfIcons);
        }

        drawCollisionDebug(painter, layer, posMatrix, tile);
        gl.enable(gl.STENCIL_TEST);
    }

    var defaultSizes = {
        icon: 1,
        text: 24
    };

    function drawSymbol(painter, layer, posMatrix, tile, elementGroups, prefix, sdf) {
        var gl = painter.gl;

        posMatrix = painter.translateMatrix(posMatrix, tile, layer.paint[prefix + &#039;-translate&#039;], layer.paint[prefix + &#039;-translate-anchor&#039;]);

        var tr = painter.transform;
        var alignedWithMap = layer.layout[prefix + &#039;-rotation-alignment&#039;] === &#039;map&#039;;
        var skewed = alignedWithMap;
        var exMatrix, s, gammaScale;

        if (skewed) {
            exMatrix = mat4.create();
            s = 4096 / tile.tileSize / Math.pow(2, painter.transform.zoom - tile.zoom);
            gammaScale = 1 / Math.cos(tr._pitch);
        } else {
            exMatrix = mat4.clone(tile.exMatrix);
            s = painter.transform.altitude;
            gammaScale = 1;
        }
        mat4.scale(exMatrix, exMatrix, [s, s, 1]);

        // If layer.paint.size &gt; layer.layout[prefix + &#039;-max-size&#039;] then labels may collide
        var fontSize = layer.paint[prefix + &#039;-size&#039;] || layer.layout[prefix + &#039;-max-size&#039;];
        var fontScale = fontSize / defaultSizes[prefix];
        mat4.scale(exMatrix, exMatrix, [ fontScale, fontScale, 1 ]);

        // calculate how much longer the real world distance is at the top of the screen
        // than at the middle of the screen.
        var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
        var x = tr.height / 2 * Math.tan(tr._pitch);
        var extra = (topedgelength + x) / topedgelength - 1;

        var text = prefix === &#039;text&#039;;
        var shader, vertex, elements, texsize;

        if (!text &amp;&amp; !painter.style.sprite.loaded())
            return;

        gl.activeTexture(gl.TEXTURE0);

        if (sdf) {
            shader = painter.sdfShader;
        } else {
            shader = painter.iconShader;
        }

        if (text) {
            painter.glyphAtlas.updateTexture(gl);
            vertex = tile.buffers.glyphVertex;
            elements = tile.buffers.glyphElement;
            texsize = [painter.glyphAtlas.width / 4, painter.glyphAtlas.height / 4];
        } else {
            painter.spriteAtlas.bind(gl, alignedWithMap || painter.options.rotating ||
                painter.options.zooming || fontScale !== 1 || sdf || painter.transform.pitch);
            vertex = tile.buffers.iconVertex;
            elements = tile.buffers.iconElement;
            texsize = [painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4];
        }

        gl.switchShader(shader, posMatrix, exMatrix);
        gl.uniform1i(shader.u_texture, 0);
        gl.uniform2fv(shader.u_texsize, texsize);
        gl.uniform1i(shader.u_skewed, skewed);
        gl.uniform1f(shader.u_extra, extra);

        // adjust min/max zooms for variable font sies
        var zoomAdjust = Math.log(fontSize / layer.layout[prefix + &#039;-max-size&#039;]) / Math.LN2 || 0;

        gl.uniform1f(shader.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

        var f = painter.frameHistory.getFadeProperties(300);
        gl.uniform1f(shader.u_fadedist, f.fadedist * 10);
        gl.uniform1f(shader.u_minfadezoom, Math.floor(f.minfadezoom * 10));
        gl.uniform1f(shader.u_maxfadezoom, Math.floor(f.maxfadezoom * 10));
        gl.uniform1f(shader.u_fadezoom, (painter.transform.zoom + f.bump) * 10);

        var group, offset, count, elementOffset;

        elements.bind(gl);

        if (sdf) {
            var sdfPx = 8;
            var blurOffset = 1.19;
            var haloOffset = 6;
            var gamma = 0.105 * defaultSizes[prefix] / fontSize / browser.devicePixelRatio;

            gl.uniform1f(shader.u_gamma, gamma * gammaScale);
            gl.uniform4fv(shader.u_color, layer.paint[prefix + &#039;-color&#039;]);
            gl.uniform1f(shader.u_buffer, (256 - 64) / 256);

            for (var i = 0; i &lt; elementGroups.groups.length; i++) {
                group = elementGroups.groups[i];
                offset = group.vertexStartIndex * vertex.itemSize;
                vertex.bind(gl, shader, offset);

                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
            }

            if (layer.paint[prefix + &#039;-halo-color&#039;]) {
                // Draw halo underneath the text.
                gl.uniform1f(shader.u_gamma, (layer.paint[prefix + &#039;-halo-blur&#039;] * blurOffset / fontScale / sdfPx + gamma) * gammaScale);
                gl.uniform4fv(shader.u_color, layer.paint[prefix + &#039;-halo-color&#039;]);
                gl.uniform1f(shader.u_buffer, (haloOffset - layer.paint[prefix + &#039;-halo-width&#039;] / fontScale) / sdfPx);

                for (var j = 0; j &lt; elementGroups.groups.length; j++) {
                    group = elementGroups.groups[j];
                    offset = group.vertexStartIndex * vertex.itemSize;
                    vertex.bind(gl, shader, offset);

                    count = group.elementLength * 3;
                    elementOffset = group.elementStartIndex * elements.itemSize;
                    gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
                }
            }
        } else {
            gl.uniform1f(shader.u_opacity, layer.paint[&#039;icon-opacity&#039;]);
            for (var k = 0; k &lt; elementGroups.groups.length; k++) {
                group = elementGroups.groups[k];
                offset = group.vertexStartIndex * vertex.itemSize;
                vertex.bind(gl, shader, offset);

                count = group.elementLength * 3;
                elementOffset = group.elementStartIndex * elements.itemSize;
                gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, elementOffset);
            }
        }
    }

},{&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;./draw_collision_debug&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_collision_debug.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_vertices.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var browser = require(&#039;../util/browser&#039;);
    var mat4 = require(&#039;gl-matrix&#039;).mat4;

    module.exports = drawVertices;

    function drawVertices(painter, layer, posMatrix, tile) {
        var gl = painter.gl;

        if (!tile || !tile.buffers) return;
        var elementGroups = tile.elementGroups[layer.ref || layer.id];
        if (!elementGroups) return;

        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        // Draw all buffers
        if (layer.type === &#039;fill&#039;) {
            drawPoints(tile.buffers.fillVertex, elementGroups.groups, posMatrix, 4);
        } else if (layer.type === &#039;symbol&#039;) {
            drawPoints(tile.buffers.iconVertex, elementGroups.icon.groups, posMatrix, 16);
            drawPoints(tile.buffers.glyphVertex, elementGroups.text.groups, posMatrix, 16);
        } else if (layer.type === &#039;line&#039;) {
            var newPosMatrix = mat4.clone(posMatrix);
            mat4.scale(newPosMatrix, newPosMatrix, [0.5, 0.5, 1]);
            drawPoints(tile.buffers.lineVertex, elementGroups.groups, newPosMatrix, 8);
        }

        function drawPoints(vertex, groups, matrix, stride) {
            gl.switchShader(painter.dotShader, matrix);

            gl.uniform1f(painter.dotShader.u_size, 4 * browser.devicePixelRatio);
            gl.uniform1f(painter.dotShader.u_blur, 0.25);
            gl.uniform4fv(painter.dotShader.u_color, [0.1, 0, 0, 0.1]);

            vertex.bind(gl, painter.dotShader, 0);
            for (var i = 0; i &lt; groups.length; i++) {
                var group = groups[i];
                var begin = group.vertexStartIndex;
                var count = group.vertexLength;
                gl.vertexAttribPointer(painter.dotShader.a_pos, 2, gl.SHORT, false, stride, 0);
                gl.drawArrays(gl.POINTS, begin, count);
            }
        }

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
    }

},{&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/frame_history.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = FrameHistory;

    function FrameHistory() {
        this.frameHistory = [];
    }

    FrameHistory.prototype.getFadeProperties = function(duration) {
        if (duration === undefined) duration = 300;
        var currentTime = (new Date()).getTime();

        // Remove frames until only one is outside the duration, or until there are only three
        while (this.frameHistory.length &gt; 3 &amp;&amp; this.frameHistory[1].time + duration &lt; currentTime) {
            this.frameHistory.shift();
        }

        if (this.frameHistory[1].time + duration &lt; currentTime) {
            this.frameHistory[0].z = this.frameHistory[1].z;
        }

        var frameLen = this.frameHistory.length;
        if (frameLen &lt; 3) console.warn(&#039;there should never be less than three frames in the history&#039;);

        // Find the range of zoom levels we want to fade between
        var startingZ = this.frameHistory[0].z,
            lastFrame = this.frameHistory[frameLen - 1],
            endingZ = lastFrame.z,
            lowZ = Math.min(startingZ, endingZ),
            highZ = Math.max(startingZ, endingZ);

        // Calculate the speed of zooming, and how far it would zoom in terms of zoom levels in one duration
        var zoomDiff = lastFrame.z - this.frameHistory[1].z,
            timeDiff = lastFrame.time - this.frameHistory[1].time;
        var fadedist = zoomDiff / (timeDiff / duration);

        if (isNaN(fadedist)) console.warn(&#039;fadedist should never be NaN&#039;);

        // At end of a zoom when the zoom stops changing continue pretending to zoom at that speed
        // bump is how much farther it would have been if it had continued zooming at the same rate
        var bump = (currentTime - lastFrame.time) / duration * fadedist;

        return {
            fadedist: fadedist,
            minfadezoom: lowZ,
            maxfadezoom: highZ,
            bump: bump
        };
    };

// Record frame history that will be used to calculate fading params
    FrameHistory.prototype.record = function(zoom) {
        var currentTime = (new Date()).getTime();

        // first frame ever
        if (!this.frameHistory.length) {
            this.frameHistory.push({time: 0, z: zoom }, {time: 0, z: zoom });
        }

        if (this.frameHistory.length === 2 || this.frameHistory[this.frameHistory.length - 1].z !== zoom) {
            this.frameHistory.push({
                time: currentTime,
                z: zoom
            });
        }
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/gl_util.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var shaders = require(&#039;./shaders&#039;);
    var util = require(&#039;../util/util&#039;);

    exports.extend = function(context) {
        var origLineWidth = context.lineWidth,
            lineWidthRange = context.getParameter(context.ALIASED_LINE_WIDTH_RANGE);

        context.lineWidth = function(width) {
            origLineWidth.call(context, util.clamp(width, lineWidthRange[0], lineWidthRange[1]));
        };

        context.getShader = function(name, type) {
            var kind = type === this.FRAGMENT_SHADER ? &#039;fragment&#039; : &#039;vertex&#039;;
            if (!shaders[name] || !shaders[name][kind]) {
                throw new Error(&quot;Could not find shader &quot; + name);
            }

            var shader = this.createShader(type);
            this.shaderSource(shader, shaders[name][kind]);
            this.compileShader(shader);
            if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
                throw new Error(this.getShaderInfoLog(shader));
            }
            return shader;
        };

        context.initializeShader = function(name, attributes, uniforms) {
            var shader = {
                program: this.createProgram(),
                fragment: this.getShader(name, this.FRAGMENT_SHADER),
                vertex: this.getShader(name, this.VERTEX_SHADER),
                attributes: []
            };
            this.attachShader(shader.program, shader.vertex);
            this.attachShader(shader.program, shader.fragment);
            this.linkProgram(shader.program);

            if (!this.getProgramParameter(shader.program, this.LINK_STATUS)) {
                console.error(this.getProgramInfoLog(shader.program));
            } else {
                for (var i = 0; i &lt; attributes.length; i++) {
                    shader[attributes[i]] = this.getAttribLocation(shader.program, attributes[i]);
                    shader.attributes.push(shader[attributes[i]]);
                }
                for (var k = 0; k &lt; uniforms.length; k++) {
                    shader[uniforms[k]] = this.getUniformLocation(shader.program, uniforms[k]);
                }
            }

            return shader;
        };

        // Switches to a different shader program.
        context.switchShader = function(shader, posMatrix, exMatrix) {
            if (!posMatrix) {
                console.trace(&#039;posMatrix does not have required argument&#039;);
            }

            if (this.currentShader !== shader) {
                this.useProgram(shader.program);

                // Disable all attributes from the existing shader that aren&#039;t used in
                // the new shader. Note: attribute indices are *not* program specific!
                var enabled = this.currentShader ? this.currentShader.attributes : [];
                var required = shader.attributes;

                for (var i = 0; i &lt; enabled.length; i++) {
                    if (required.indexOf(enabled[i]) &lt; 0) {
                        this.disableVertexAttribArray(enabled[i]);
                    }
                }

                // Enable all attributes for the new shader.
                for (var j = 0; j &lt; required.length; j++) {
                    if (enabled.indexOf(required[j]) &lt; 0) {
                        this.enableVertexAttribArray(required[j]);
                    }
                }

                this.currentShader = shader;
            }

            // Update the matrices if necessary. Note: This relies on object identity!
            // This means changing the matrix values without the actual matrix object
            // will FAIL to update the matrix properly.
            if (shader.posMatrix !== posMatrix) {
                this.uniformMatrix4fv(shader.u_matrix, false, posMatrix);
                shader.posMatrix = posMatrix;
            }
            if (exMatrix &amp;&amp; shader.exMatrix !== exMatrix &amp;&amp; shader.u_exmatrix) {
                this.uniformMatrix4fv(shader.u_exmatrix, false, exMatrix);
                shader.exMatrix = exMatrix;
            }
        };

        return context;
    };

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./shaders&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/shaders.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/line_atlas.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = LineAtlas;

    function LineAtlas(width, height) {
        this.width = width;
        this.height = height;
        this.nextRow = 0;

        this.bytes = 4;
        this.data = new Uint8Array(this.width * this.height * this.bytes);

        this.positions = {};
    }

    LineAtlas.prototype.setSprite = function(sprite) {
        this.sprite = sprite;
    };

    LineAtlas.prototype.getDash = function(dasharray, round) {
        var key = dasharray.join(&quot;,&quot;) + round;

        if (!this.positions[key]) {
            this.positions[key] = this.addDash(dasharray, round);
        }
        return this.positions[key];
    };

    LineAtlas.prototype.addDash = function(dasharray, round) {

        var n = round ? 7 : 0;
        var height = 2 * n + 1;
        var offset = 128;

        if (this.nextRow + height &gt; this.height) {
            console.warn(&#039;LineAtlas out of space&#039;);
            return null;
        }

        var length = 0;
        for (var i = 0; i &lt; dasharray.length; i++) {
            length += dasharray[i];
        }

        var stretch = this.width / length;
        var halfWidth = stretch / 2;

        // If dasharray has an odd length, both the first and last parts
        // are dashes and should be joined seamlessly.
        var oddLength = dasharray.length % 2 === 1;

        for (var y = -n; y &lt;= n; y++) {
            var row = this.nextRow + n + y;
            var index = this.width * row;

            var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
            var right = dasharray[0];
            var partIndex = 1;

            for (var x = 0; x &lt; this.width; x++) {

                while (right &lt; x / stretch) {
                    left = right;
                    right = right + dasharray[partIndex];

                    if (oddLength &amp;&amp; partIndex === dasharray.length - 1) {
                        right += dasharray[0];
                    }

                    partIndex++;
                }

                var distLeft = Math.abs(x - left * stretch);
                var distRight = Math.abs(x - right * stretch);
                var dist = Math.min(distLeft, distRight);
                var inside = (partIndex % 2) === 1;
                var signedDistance;

                if (round) {
                    // Add circle caps
                    var distMiddle = n ? y / n * (halfWidth + 1) : 0;
                    if (inside) {
                        var distEdge = halfWidth - Math.abs(distMiddle);
                        signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                    } else {
                        signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                    }
                } else {
                    signedDistance = (inside ? 1 : -1) * dist;
                }

                this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
            }
        }

        var pos = {
            y: (this.nextRow + n + 0.5) / this.height,
            height: 2 * n / this.height,
            width: length
        };

        this.nextRow += height;
        this.dirty = true;

        return pos;
    };

    LineAtlas.prototype.bind = function(gl) {
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);

            if (this.dirty) {
                this.dirty = false;
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
            }
        }
    };

    LineAtlas.prototype.debug = function() {

        var canvas = document.createElement(&#039;canvas&#039;);

        document.body.appendChild(canvas);
        canvas.style.position = &#039;absolute&#039;;
        canvas.style.top = 0;
        canvas.style.left = 0;
        canvas.style.background = &#039;#ff0&#039;;

        canvas.width = this.width;
        canvas.height = this.height;

        var ctx = canvas.getContext(&#039;2d&#039;);
        var data = ctx.getImageData(0, 0, this.width, this.height);
        for (var i = 0; i &lt; this.data.length; i++) {
            if (this.sdf) {
                var k = i * 4;
                data.data[k] = data.data[k + 1] = data.data[k + 2] = 0;
                data.data[k + 3] = this.data[i];
            } else {
                data.data[i] = this.data[i];
            }
        }
        ctx.putImageData(data, 0, 0);
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/painter.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var glutil = require(&#039;./gl_util&#039;);
    var browser = require(&#039;../util/browser&#039;);
    var mat4 = require(&#039;gl-matrix&#039;).mat4;
    var FrameHistory = require(&#039;./frame_history&#039;);

    /*
     * Initialize a new painter object.
     *
     * @param {Canvas} gl an experimental-webgl drawing context
     */
    module.exports = GLPainter;
    function GLPainter(gl, transform) {
        this.gl = glutil.extend(gl);
        this.transform = transform;

        this.reusableTextures = {};
        this.preFbos = {};

        this.tileExtent = 4096;
        this.frameHistory = new FrameHistory();

        this.setup();
    }

    /*
     * Update the GL viewport, projection matrix, and transforms to compensate
     * for a new width and height value.
     */
    GLPainter.prototype.resize = function(width, height) {
        var gl = this.gl;

        this.width = width * browser.devicePixelRatio;
        this.height = height * browser.devicePixelRatio;
        gl.viewport(0, 0, this.width, this.height);

    };


    GLPainter.prototype.setup = function() {
        var gl = this.gl;

        gl.verbose = true;

        // We are blending the new pixels *behind* the existing pixels. That way we can
        // draw front-to-back and use then stencil buffer to cull opaque pixels early.
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);

        gl.enable(gl.STENCIL_TEST);

        // Initialize shaders
        this.debugShader = gl.initializeShader(&#039;debug&#039;,
            [&#039;a_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_pointsize&#039;, &#039;u_color&#039;]);

        this.gaussianShader = gl.initializeShader(&#039;gaussian&#039;,
            [&#039;a_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_image&#039;, &#039;u_offset&#039;]);

        this.rasterShader = gl.initializeShader(&#039;raster&#039;,
            [&#039;a_pos&#039;, &#039;a_texture_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_brightness_low&#039;, &#039;u_brightness_high&#039;, &#039;u_saturation_factor&#039;, &#039;u_spin_weights&#039;, &#039;u_contrast_factor&#039;, &#039;u_opacity0&#039;, &#039;u_opacity1&#039;, &#039;u_image0&#039;, &#039;u_image1&#039;, &#039;u_tl_parent&#039;, &#039;u_scale_parent&#039;, &#039;u_buffer_scale&#039;]);

        this.lineShader = gl.initializeShader(&#039;line&#039;,
            [&#039;a_pos&#039;, &#039;a_data&#039;],
            [&#039;u_matrix&#039;, &#039;u_linewidth&#039;, &#039;u_color&#039;, &#039;u_ratio&#039;, &#039;u_blur&#039;, &#039;u_extra&#039;, &#039;u_antialiasingmatrix&#039;]);

        this.linepatternShader = gl.initializeShader(&#039;linepattern&#039;,
            [&#039;a_pos&#039;, &#039;a_data&#039;],
            [&#039;u_matrix&#039;, &#039;u_exmatrix&#039;, &#039;u_linewidth&#039;, &#039;u_ratio&#039;, &#039;u_pattern_size_a&#039;, &#039;u_pattern_size_b&#039;, &#039;u_pattern_tl_a&#039;, &#039;u_pattern_br_a&#039;, &#039;u_pattern_tl_b&#039;, &#039;u_pattern_br_b&#039;, &#039;u_blur&#039;, &#039;u_fade&#039;, &#039;u_opacity&#039;]);

        this.linesdfpatternShader = gl.initializeShader(&#039;linesdfpattern&#039;,
            [&#039;a_pos&#039;, &#039;a_data&#039;],
            [&#039;u_matrix&#039;, &#039;u_exmatrix&#039;, &#039;u_linewidth&#039;, &#039;u_color&#039;, &#039;u_ratio&#039;, &#039;u_blur&#039;, &#039;u_patternscale_a&#039;, &#039;u_tex_y_a&#039;, &#039;u_patternscale_b&#039;, &#039;u_tex_y_b&#039;, &#039;u_image&#039;, &#039;u_sdfgamma&#039;, &#039;u_mix&#039;]);

        this.dotShader = gl.initializeShader(&#039;dot&#039;,
            [&#039;a_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_size&#039;, &#039;u_color&#039;, &#039;u_blur&#039;]);

        this.sdfShader = gl.initializeShader(&#039;sdf&#039;,
            [&#039;a_pos&#039;, &#039;a_offset&#039;, &#039;a_data1&#039;, &#039;a_data2&#039;],
            [&#039;u_matrix&#039;, &#039;u_exmatrix&#039;, &#039;u_texture&#039;, &#039;u_texsize&#039;, &#039;u_color&#039;, &#039;u_gamma&#039;, &#039;u_buffer&#039;, &#039;u_zoom&#039;, &#039;u_fadedist&#039;, &#039;u_minfadezoom&#039;, &#039;u_maxfadezoom&#039;, &#039;u_fadezoom&#039;, &#039;u_skewed&#039;, &#039;u_extra&#039;]);

        this.iconShader = gl.initializeShader(&#039;icon&#039;,
            [&#039;a_pos&#039;, &#039;a_offset&#039;, &#039;a_data1&#039;, &#039;a_data2&#039;],
            [&#039;u_matrix&#039;, &#039;u_exmatrix&#039;, &#039;u_texture&#039;, &#039;u_texsize&#039;, &#039;u_zoom&#039;, &#039;u_fadedist&#039;, &#039;u_minfadezoom&#039;, &#039;u_maxfadezoom&#039;, &#039;u_fadezoom&#039;, &#039;u_opacity&#039;, &#039;u_skewed&#039;, &#039;u_extra&#039;]);

        this.outlineShader = gl.initializeShader(&#039;outline&#039;,
            [&#039;a_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_color&#039;, &#039;u_world&#039;]
        );

        this.patternShader = gl.initializeShader(&#039;pattern&#039;,
            [&#039;a_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_pattern_tl_a&#039;, &#039;u_pattern_br_a&#039;, &#039;u_pattern_tl_b&#039;, &#039;u_pattern_br_b&#039;, &#039;u_mix&#039;, &#039;u_patternmatrix_a&#039;, &#039;u_patternmatrix_b&#039;, &#039;u_opacity&#039;, &#039;u_image&#039;]
        );

        this.fillShader = gl.initializeShader(&#039;fill&#039;,
            [&#039;a_pos&#039;],
            [&#039;u_matrix&#039;, &#039;u_color&#039;]
        );

        this.collisionBoxShader = gl.initializeShader(&#039;collisionbox&#039;,
            [&#039;a_pos&#039;, &#039;a_extrude&#039;, &#039;a_data&#039;],
            [&#039;u_matrix&#039;, &#039;u_scale&#039;, &#039;u_zoom&#039;, &#039;u_maxzoom&#039;]
        );

        this.identityMatrix = mat4.create();

        // The backgroundBuffer is used when drawing to the full *canvas*
        this.backgroundBuffer = gl.createBuffer();
        this.backgroundBuffer.itemSize = 2;
        this.backgroundBuffer.itemCount = 4;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

        // The tileExtentBuffer is used when drawing to a full *tile*
        this.tileExtentBuffer = gl.createBuffer();
        this.tileExtentBuffer.itemSize = 4;
        this.tileExtentBuffer.itemCount = 4;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([
            // tile coord x, tile coord y, texture coord x, texture coord y
            0, 0,                    0, 0,
            this.tileExtent, 0,                32767, 0,
            0, this.tileExtent,      0, 32767,
            this.tileExtent, this.tileExtent,  32767, 32767
        ]), gl.STATIC_DRAW);

        // The debugBuffer is used to draw tile outlines for debugging
        this.debugBuffer = gl.createBuffer();
        this.debugBuffer.itemSize = 2;
        this.debugBuffer.itemCount = 5;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.debugBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Int16Array([0, 0, 4095, 0, 4095, 4095, 0, 4095, 0, 0]), gl.STATIC_DRAW);

        // The debugTextBuffer is used to draw tile IDs for debugging
        this.debugTextBuffer = gl.createBuffer();
        this.debugTextBuffer.itemSize = 2;
    };

    /*
     * Reset the color buffers of the drawing canvas.
     */
    GLPainter.prototype.clearColor = function() {
        var gl = this.gl;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
    };

    /*
     * Reset the drawing canvas by clearing the stencil buffer so that we can draw
     * new tiles at the same location, while retaining previously drawn pixels.
     */
    GLPainter.prototype.clearStencil = function() {
        var gl = this.gl;
        gl.clearStencil(0x0);
        gl.stencilMask(0xFF);
        gl.clear(gl.STENCIL_BUFFER_BIT);
    };

    GLPainter.prototype.drawClippingMask = function(tile) {
        var gl = this.gl;
        gl.switchShader(this.fillShader, tile.posMatrix);
        gl.colorMask(false, false, false, false);

        // Clear the entire stencil buffer, except for the 7th bit, which stores
        // the global clipping mask that allows us to avoid drawing in regions of
        // tiles we&#039;ve already painted in.
        gl.clearStencil(0x0);
        gl.stencilMask(0xBF);
        gl.clear(gl.STENCIL_BUFFER_BIT);

        // The stencil test will fail always, meaning we set all pixels covered
        // by this geometry to 0x80. We use the highest bit 0x80 to mark the regions
        // we want to draw in. All pixels that have this bit *not* set will never be
        // drawn in.
        gl.stencilFunc(gl.EQUAL, 0xC0, 0x40);
        gl.stencilMask(0xC0);
        gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);

        // Draw the clipping mask
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tileExtentBuffer);
        gl.vertexAttribPointer(this.fillShader.a_pos, this.tileExtentBuffer.itemSize, gl.SHORT, false, 8, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.itemCount);

        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
        gl.stencilMask(0x00);
        gl.colorMask(true, true, true, true);
    };

// Overridden by headless tests.
    GLPainter.prototype.prepareBuffers = function() {};
    GLPainter.prototype.bindDefaultFramebuffer = function() {
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    };

    var draw = {
        symbol: require(&#039;./draw_symbol&#039;),
        line: require(&#039;./draw_line&#039;),
        fill: require(&#039;./draw_fill&#039;),
        raster: require(&#039;./draw_raster&#039;),
        background: require(&#039;./draw_background&#039;),
        debug: require(&#039;./draw_debug&#039;),
        vertices: require(&#039;./draw_vertices&#039;)
    };

    GLPainter.prototype.render = function(style, options) {
        this.style = style;
        this.options = options;

        this.lineAtlas = style.lineAtlas;

        this.spriteAtlas = style.spriteAtlas;
        this.spriteAtlas.setSprite(style.sprite);

        this.glyphAtlas = style.glyphAtlas;
        this.glyphAtlas.bind(this.gl);

        this.frameHistory.record(this.transform.zoom);

        this.prepareBuffers();
        this.clearColor();

        for (var i = style._groups.length - 1; i &gt;= 0; i--) {
            var group = style._groups[i];
            var source = style.sources[group.source];

            if (source) {
                this.clearStencil();
                source.render(group, this);

            } else if (group.source === undefined) {
                this.drawLayers(group, this.identityMatrix);
            }
        }
    };

    GLPainter.prototype.drawTile = function(tile, layers) {
        this.drawClippingMask(tile);
        this.drawLayers(layers, tile.posMatrix, tile);

        if (this.options.debug) {
            draw.debug(this, tile);
        }
    };

    GLPainter.prototype.drawLayers = function(layers, matrix, tile) {
        for (var i = layers.length - 1; i &gt;= 0; i--) {
            var layer = layers[i];

            if (layer.hidden)
                continue;

            draw[layer.type](this, layer, matrix, tile);

            if (this.options.vertices) {
                draw.vertices(this, layer, matrix, tile);
            }
        }
    };

// Draws non-opaque areas. This is for debugging purposes.
    GLPainter.prototype.drawStencilBuffer = function() {
        var gl = this.gl;
        gl.switchShader(this.fillShader, this.identityMatrix);

        // Blend to the front, not the back.
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.stencilMask(0x00);
        gl.stencilFunc(gl.EQUAL, 0x80, 0x80);

        // Drw the filling quad where the stencil buffer isn&#039;t set.
        gl.bindBuffer(gl.ARRAY_BUFFER, this.backgroundBuffer);
        gl.vertexAttribPointer(this.fillShader.a_pos, this.backgroundBuffer.itemSize, gl.SHORT, false, 0, 0);
        gl.uniform4fv(this.fillShader.u_color, [0, 0, 0, 0.5]);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.backgroundBuffer.itemCount);

        // Revert blending mode to blend to the back.
        gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);
    };

    GLPainter.prototype.translateMatrix = function(matrix, tile, translate, anchor) {
        if (!translate[0] &amp;&amp; !translate[1]) return matrix;

        if (anchor === &#039;viewport&#039;) {
            var sinA = Math.sin(-this.transform.angle);
            var cosA = Math.cos(-this.transform.angle);
            translate = [
                    translate[0] * cosA - translate[1] * sinA,
                    translate[0] * sinA + translate[1] * cosA
            ];
        }

        var tilePixelRatio = this.transform.scale / (1 &lt;&lt; tile.zoom) / (tile.tileExtent / tile.tileSize);
        var translation = [
                translate[0] / tilePixelRatio,
                translate[1] / tilePixelRatio,
            0
        ];

        var translatedMatrix = new Float32Array(16);
        mat4.translate(translatedMatrix, matrix, translation);
        return translatedMatrix;
    };

    GLPainter.prototype.saveTexture = function(texture) {
        var textures = this.reusableTextures[texture.size];
        if (!textures) {
            this.reusableTextures[texture.size] = [texture];
        } else {
            textures.push(texture);
        }
    };


    GLPainter.prototype.getTexture = function(size) {
        var textures = this.reusableTextures[size];
        return textures &amp;&amp; textures.length &gt; 0 ? textures.pop() : null;
    };

},{&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;./draw_background&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_background.js&quot;,&quot;./draw_debug&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_debug.js&quot;,&quot;./draw_fill&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_fill.js&quot;,&quot;./draw_line&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_line.js&quot;,&quot;./draw_raster&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_raster.js&quot;,&quot;./draw_symbol&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_symbol.js&quot;,&quot;./draw_vertices&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/draw_vertices.js&quot;,&quot;./frame_history&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/frame_history.js&quot;,&quot;./gl_util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/gl_util.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/shaders.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var glify = undefined;

    module.exports = {
        &quot;debug&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nuniform float u_pointsize;\nuniform mat4 u_matrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = a_pos;\n  tmpvar_1.z = float((a_pos.x &gt;= 32767.0));\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = u_pointsize;\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n&quot;},
        &quot;dot&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nuniform mat4 u_matrix;\nuniform float u_size;\nattribute vec2 a_pos;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = u_size;\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec4 u_color;\nuniform float u_blur;\nvoid main ()\n{\n  mediump vec2 x_1;\n  x_1 = (gl_PointCoord - 0.5);\n  mediump float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 0.5) / (\n    (0.5 - u_blur)\n   - 0.5)), 0.0, 1.0);\n  gl_FragColor = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n}\n\n&quot;},
        &quot;fill&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  gl_PointSize = 2.0;\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec4 u_color;\nvoid main ()\n{\n  gl_FragColor = u_color;\n}\n\n&quot;},
        &quot;gaussian&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_offset;\nvarying highp vec2 a[3];\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_matrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = ((tmpvar_2.xy / 2.0) + 0.5);\n  a[0] = tmpvar_3;\n  vec2 cse_4;\n  cse_4 = (u_offset * 1.18243);\n  a[1] = (tmpvar_3 + cse_4);\n  a[2] = (tmpvar_3 - cse_4);\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform sampler2D u_image;\nvarying vec2 a[3];\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (((texture2D (u_image, a[0]) * 0.40262) + (texture2D (u_image, a[1]) * 0.29869)) + (texture2D (u_image, a[2]) * 0.29869));\n  gl_FragColor = tmpvar_1;\n}\n\n&quot;},
        &quot;line&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_data;\nuniform mat4 u_matrix;\nuniform float u_ratio;\nuniform float u_extra;\nuniform vec2 u_linewidth;\nuniform mat2 u_antialiasingmatrix;\nvarying vec2 a;\nvarying highp float c;\nvoid main ()\n{\n  vec2 e_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  e_1.x = tmpvar_2.x;\n  e_1.y = sign((tmpvar_2.y - 0.5));\n  a = e_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 0.0);\n  tmpvar_3.xy = ((u_linewidth.x * a_data.xy) * 0.015873);\n  vec4 tmpvar_4;\n  tmpvar_4.zw = vec2(0.0, 1.0);\n  tmpvar_4.xy = (floor((a_pos * 0.5)) + (tmpvar_3.xy / u_ratio));\n  vec4 tmpvar_5;\n  tmpvar_5 = (u_matrix * tmpvar_4);\n  gl_Position = tmpvar_5;\n  vec2 x_6;\n  x_6 = (u_antialiasingmatrix * a_data.xy);\n  c = ((1.0/((1.0 - \n    ((tmpvar_5.y / tmpvar_5.w) * u_extra)\n  ))) * (sqrt(\n    dot (a_data.xy, a_data.xy)\n  ) / sqrt(\n    dot (x_6, x_6)\n  )));\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_blur;\nvarying vec2 a;\nvarying float c;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (sqrt(dot (a, a)) * u_linewidth.x);\n  float tmpvar_2;\n  tmpvar_2 = (u_blur * c);\n  gl_FragColor = (u_color * clamp ((\n    min ((tmpvar_1 - (u_linewidth.y - tmpvar_2)), (u_linewidth.x - tmpvar_1))\n   / tmpvar_2), 0.0, 1.0));\n}\n\n&quot;},
        &quot;linepattern&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_data;\nuniform mat4 u_matrix;\nuniform float u_ratio;\nuniform vec2 u_linewidth;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  vec2 e_1;\n  vec2 tmpvar_2;\n  tmpvar_2 = (vec2(mod (a_pos, 2.0)));\n  e_1.x = tmpvar_2.x;\n  e_1.y = sign((tmpvar_2.y - 0.5));\n  a = e_1;\n  vec4 tmpvar_3;\n  tmpvar_3.zw = vec2(0.0, 1.0);\n  tmpvar_3.xy = (floor((a_pos * 0.5)) + ((u_linewidth.x * \n    (a_data.xy * 0.015873)\n  ) / u_ratio));\n  gl_Position = (u_matrix * tmpvar_3);\n  b = ((a_data.z * 128.0) + a_data.w);\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_blur;\nuniform float u_fade;\nuniform float u_opacity;\nuniform sampler2D u_image;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (sqrt(dot (a, a)) * u_linewidth.x);\n  vec2 tmpvar_2;\n  tmpvar_2.x = (float(mod ((b / u_pattern_size_a.x), 1.0)));\n  float cse_3;\n  cse_3 = (a.y * u_linewidth.x);\n  tmpvar_2.y = (0.5 + (cse_3 / u_pattern_size_a.y));\n  vec2 tmpvar_4;\n  tmpvar_4.x = (float(mod ((b / u_pattern_size_b.x), 1.0)));\n  tmpvar_4.y = (0.5 + (cse_3 / u_pattern_size_b.y));\n  lowp vec4 tmpvar_5;\n  tmpvar_5 = (mix (texture2D (u_image, mix (u_pattern_tl_a, u_pattern_br_a, tmpvar_2)), texture2D (u_image, mix (u_pattern_tl_b, u_pattern_br_b, tmpvar_4)), u_fade) * (clamp (\n    (min ((tmpvar_1 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_1)) / u_blur)\n  , 0.0, 1.0) * u_opacity));\n  gl_FragColor = tmpvar_5;\n}\n\n&quot;},
        &quot;linesdfpattern&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_data;\nuniform mat4 u_matrix;\nuniform vec2 u_linewidth;\nuniform vec2 u_patternscale_a;\nuniform vec2 u_patternscale_b;\nuniform float u_ratio;\nuniform float u_tex_y_a;\nuniform float u_tex_y_b;\nvarying vec2 a;\nvarying vec2 b;\nvarying vec2 c;\nvoid main ()\n{\n  vec2 f_1;\n  float tmpvar_2;\n  tmpvar_2 = ((a_data.z * 128.0) + a_data.w);\n  vec2 tmpvar_3;\n  tmpvar_3 = (vec2(mod (a_pos, 2.0)));\n  f_1.x = tmpvar_3.x;\n  f_1.y = sign((tmpvar_3.y - 0.5));\n  a = f_1;\n  vec4 tmpvar_4;\n  tmpvar_4.zw = vec2(0.0, 0.0);\n  tmpvar_4.xy = ((u_linewidth.x * a_data.xy) * 0.015873);\n  vec4 tmpvar_5;\n  tmpvar_5.zw = vec2(0.0, 1.0);\n  tmpvar_5.xy = (floor((a_pos * 0.5)) + (tmpvar_4.xy / u_ratio));\n  gl_Position = (u_matrix * tmpvar_5);\n  vec2 tmpvar_6;\n  tmpvar_6.x = (tmpvar_2 * u_patternscale_a.x);\n  tmpvar_6.y = ((f_1.y * u_patternscale_a.y) + u_tex_y_a);\n  b = tmpvar_6;\n  vec2 tmpvar_7;\n  tmpvar_7.x = (tmpvar_2 * u_patternscale_b.x);\n  tmpvar_7.y = ((f_1.y * u_patternscale_b.y) + u_tex_y_b);\n  c = tmpvar_7;\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec2 u_linewidth;\nuniform vec4 u_color;\nuniform float u_blur;\nuniform float u_sdfgamma;\nuniform float u_mix;\nuniform sampler2D u_image;\nvarying vec2 a;\nvarying vec2 b;\nvarying vec2 c;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (sqrt(dot (a, a)) * u_linewidth.x);\n  float edge0_2;\n  edge0_2 = (0.5 - u_sdfgamma);\n  lowp float tmpvar_3;\n  tmpvar_3 = clamp (((\n    mix (texture2D (u_image, b).w, texture2D (u_image, c).w, u_mix)\n   - edge0_2) / (\n    (0.5 + u_sdfgamma)\n   - edge0_2)), 0.0, 1.0);\n  lowp vec4 tmpvar_4;\n  tmpvar_4 = (u_color * (clamp (\n    (min ((tmpvar_1 - (u_linewidth.y - u_blur)), (u_linewidth.x - tmpvar_1)) / u_blur)\n  , 0.0, 1.0) * (tmpvar_3 * \n    (tmpvar_3 * (3.0 - (2.0 * tmpvar_3)))\n  )));\n  gl_FragColor = tmpvar_4;\n}\n\n&quot;},
        &quot;outline&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nuniform mat4 u_matrix;\nuniform vec2 u_world;\nvarying highp vec2 a;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  vec4 tmpvar_2;\n  tmpvar_2 = (u_matrix * tmpvar_1);\n  gl_Position = tmpvar_2;\n  a = (((\n    (tmpvar_2.xy / tmpvar_2.w)\n   + 1.0) / 2.0) * u_world);\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform vec4 u_color;\nvarying vec2 a;\nvoid main ()\n{\n  highp vec2 x_1;\n  x_1 = (a - gl_FragCoord.xy);\n  highp float tmpvar_2;\n  tmpvar_2 = clamp (((\n    sqrt(dot (x_1, x_1))\n   - 1.0) / -1.0), 0.0, 1.0);\n  highp vec4 tmpvar_3;\n  tmpvar_3 = (u_color * (tmpvar_2 * (tmpvar_2 * \n    (3.0 - (2.0 * tmpvar_2))\n  )));\n  gl_FragColor = tmpvar_3;\n}\n\n&quot;},
        &quot;pattern&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nuniform mat4 u_matrix;\nuniform mat3 u_patternmatrix_a;\nuniform mat3 u_patternmatrix_b;\nattribute vec2 a_pos;\nvarying vec2 a;\nvarying vec2 b;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  vec3 tmpvar_2;\n  tmpvar_2.z = 1.0;\n  tmpvar_2.xy = a_pos;\n  a = (u_patternmatrix_a * tmpvar_2).xy;\n  vec3 tmpvar_3;\n  tmpvar_3.z = 1.0;\n  tmpvar_3.xy = a_pos;\n  b = (u_patternmatrix_b * tmpvar_3).xy;\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform float u_opacity;\nuniform float u_mix;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform sampler2D u_image;\nvarying vec2 a;\nvarying vec2 b;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (mix (texture2D (u_image, mix (u_pattern_tl_a, u_pattern_br_a, \n    (vec2(mod (a, 1.0)))\n  )), texture2D (u_image, mix (u_pattern_tl_b, u_pattern_br_b, \n    (vec2(mod (b, 1.0)))\n  )), u_mix) * u_opacity);\n  gl_FragColor = tmpvar_1;\n}\n\n&quot;},
        &quot;raster&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\nvarying vec2 a;\nvarying vec2 b;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = a_pos;\n  gl_Position = (u_matrix * tmpvar_1);\n  vec2 tmpvar_2;\n  tmpvar_2 = (((\n    (a_texture_pos / 32767.0)\n   - 0.5) / u_buffer_scale) + 0.5);\n  a = tmpvar_2;\n  b = ((tmpvar_2 * u_scale_parent) + u_tl_parent);\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform float u_brightness_low;\nuniform float u_brightness_high;\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 a;\nvarying vec2 b;\nuniform vec3 u_spin_weights;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = ((texture2D (u_image0, a) * u_opacity0) + (texture2D (u_image1, b) * u_opacity1));\n  lowp vec3 tmpvar_2;\n  tmpvar_2.x = dot (tmpvar_1.xyz, u_spin_weights);\n  tmpvar_2.y = dot (tmpvar_1.xyz, u_spin_weights.zxy);\n  tmpvar_2.z = dot (tmpvar_1.xyz, u_spin_weights.yzx);\n  lowp vec4 tmpvar_3;\n  tmpvar_3.xyz = mix (vec3(u_brightness_low), vec3(u_brightness_high), ((\n    ((tmpvar_2 + ((\n      (((tmpvar_1.x + tmpvar_1.y) + tmpvar_1.z) / 3.0)\n     - tmpvar_2) * u_saturation_factor)) - 0.5)\n   * u_contrast_factor) + 0.5));\n  tmpvar_3.w = tmpvar_1.w;\n  gl_FragColor = tmpvar_3;\n}\n\n&quot;},
        &quot;icon&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_zoom;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform float u_opacity;\nuniform bool u_skewed;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = ((2.0 - float(\n    (u_zoom &gt;= a_data2.x)\n  )) - (1.0 - float(\n    (u_zoom &gt;= a_data2.y)\n  )));\n  float tmpvar_2;\n  tmpvar_2 = clamp (((u_fadezoom - a_data1.z) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist &gt;= 0.0)) {\n    b = tmpvar_2;\n  } else {\n    b = (1.0 - tmpvar_2);\n  };\n  if ((u_maxfadezoom &lt; a_data1.z)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom &gt;= a_data1.z)) {\n    b = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (tmpvar_1 + float((0.0 &gt;= b)));\n  if (u_skewed) {\n    vec4 tmpvar_4;\n    tmpvar_4.zw = vec2(0.0, 0.0);\n    tmpvar_4.xy = (a_offset / 64.0);\n    vec4 tmpvar_5;\n    tmpvar_5.zw = vec2(0.0, 1.0);\n    tmpvar_5.xy = (a_pos + (u_exmatrix * tmpvar_4).xy);\n    vec4 tmpvar_6;\n    tmpvar_6 = (u_matrix * tmpvar_5);\n    gl_Position.xyw = tmpvar_6.xyw;\n    gl_Position.z = (tmpvar_6.z + (tmpvar_3 * tmpvar_6.w));\n  } else {\n    vec4 tmpvar_7;\n    tmpvar_7.w = 0.0;\n    tmpvar_7.xy = (a_offset / 64.0);\n    tmpvar_7.z = tmpvar_3;\n    vec4 tmpvar_8;\n    tmpvar_8.zw = vec2(0.0, 1.0);\n    tmpvar_8.xy = a_pos;\n    gl_Position = ((u_matrix * tmpvar_8) + (u_exmatrix * tmpvar_7));\n  };\n  a = (a_data1.xy / u_texsize);\n  b = (b * u_opacity);\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform sampler2D u_texture;\nvarying vec2 a;\nvarying float b;\nvoid main ()\n{\n  lowp vec4 tmpvar_1;\n  tmpvar_1 = (texture2D (u_texture, a) * b);\n  gl_FragColor = tmpvar_1;\n}\n\n&quot;},
        &quot;sdf&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec4 a_data1;\nattribute vec4 a_data2;\nuniform mat4 u_matrix;\nuniform mat4 u_exmatrix;\nuniform float u_zoom;\nuniform float u_fadedist;\nuniform float u_minfadezoom;\nuniform float u_maxfadezoom;\nuniform float u_fadezoom;\nuniform float u_extra;\nuniform bool u_skewed;\nuniform vec2 u_texsize;\nvarying vec2 a;\nvarying float b;\nvarying highp float c;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = ((2.0 - float(\n    (u_zoom &gt;= a_data2.x)\n  )) - (1.0 - float(\n    (u_zoom &gt;= a_data2.y)\n  )));\n  float tmpvar_2;\n  tmpvar_2 = clamp (((u_fadezoom - a_data1.z) / u_fadedist), 0.0, 1.0);\n  if ((u_fadedist &gt;= 0.0)) {\n    b = tmpvar_2;\n  } else {\n    b = (1.0 - tmpvar_2);\n  };\n  if ((u_maxfadezoom &lt; a_data1.z)) {\n    b = 0.0;\n  };\n  if ((u_minfadezoom &gt;= a_data1.z)) {\n    b = 1.0;\n  };\n  float tmpvar_3;\n  tmpvar_3 = (tmpvar_1 + float((0.0 &gt;= b)));\n  if (u_skewed) {\n    vec4 tmpvar_4;\n    tmpvar_4.zw = vec2(0.0, 0.0);\n    tmpvar_4.xy = (a_offset / 64.0);\n    vec4 tmpvar_5;\n    tmpvar_5.zw = vec2(0.0, 1.0);\n    tmpvar_5.xy = (a_pos + (u_exmatrix * tmpvar_4).xy);\n    vec4 tmpvar_6;\n    tmpvar_6 = (u_matrix * tmpvar_5);\n    gl_Position.xyw = tmpvar_6.xyw;\n    gl_Position.z = (tmpvar_6.z + (tmpvar_3 * tmpvar_6.w));\n  } else {\n    vec4 tmpvar_7;\n    tmpvar_7.w = 0.0;\n    tmpvar_7.xy = (a_offset / 64.0);\n    tmpvar_7.z = tmpvar_3;\n    vec4 tmpvar_8;\n    tmpvar_8.zw = vec2(0.0, 1.0);\n    tmpvar_8.xy = a_pos;\n    gl_Position = ((u_matrix * tmpvar_8) + (u_exmatrix * tmpvar_7));\n  };\n  c = (1.0/((1.0 - (\n    (gl_Position.y / gl_Position.w)\n   * u_extra))));\n  a = (a_data1.xy / u_texsize);\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform sampler2D u_texture;\nuniform vec4 u_color;\nuniform float u_buffer;\nuniform float u_gamma;\nvarying vec2 a;\nvarying float b;\nvarying float c;\nvoid main ()\n{\n  float tmpvar_1;\n  tmpvar_1 = (u_gamma * c);\n  float edge0_2;\n  edge0_2 = (u_buffer - tmpvar_1);\n  lowp float tmpvar_3;\n  tmpvar_3 = clamp (((texture2D (u_texture, a).w - edge0_2) / (\n    (u_buffer + tmpvar_1)\n   - edge0_2)), 0.0, 1.0);\n  lowp vec4 tmpvar_4;\n  tmpvar_4 = (u_color * ((tmpvar_3 * \n    (tmpvar_3 * (3.0 - (2.0 * tmpvar_3)))\n  ) * b));\n  gl_FragColor = tmpvar_4;\n}\n\n&quot;},
        &quot;collisionbox&quot;: {&quot;vertex&quot;:&quot;precision mediump float;\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\nuniform mat4 u_matrix;\nuniform float u_scale;\nvarying float a;\nvarying float b;\nvoid main ()\n{\n  vec4 tmpvar_1;\n  tmpvar_1.zw = vec2(0.0, 1.0);\n  tmpvar_1.xy = (a_pos + (a_extrude / u_scale));\n  gl_Position = (u_matrix * tmpvar_1);\n  a = a_data.x;\n  b = a_data.y;\n}\n\n&quot;,&quot;fragment&quot;:&quot;precision mediump float;\nuniform float u_zoom;\nuniform float u_maxzoom;\nvarying float a;\nvarying float b;\nvoid main ()\n{\n  gl_FragColor = vec4(0.0, 0.5, 0.0, 0.5);\n  if ((b &gt; u_zoom)) {\n    gl_FragColor = vec4(0.5, 0.0, 0.0, 0.5);\n  };\n  if ((u_zoom &gt;= a)) {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.125);\n  };\n  if ((b &gt;= u_maxzoom)) {\n    gl_FragColor = vec4(0.0, 0.0, 0.1, 0.1);\n  };\n}\n\n&quot;}
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/geojson_source.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var Evented = require(&#039;../util/evented&#039;);
    var TilePyramid = require(&#039;./tile_pyramid&#039;);
    var Source = require(&#039;./source&#039;);

    module.exports = GeoJSONSource;

    /**
     * Create a GeoJSON data source instance given an options object
     * @class GeoJSONSource
     * @param {Object} [options]
     * @param {Object|String} options.data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
     * @param {Number} [options.maxzoom=14] Maximum zoom to preserve detail at.
     * @example
     * var sourceObj = new mapboxgl.GeoJSONSource({
 *    data: {
 *        &quot;type&quot;: &quot;FeatureCollection&quot;,
 *        &quot;features&quot;: [{
 *            &quot;type&quot;: &quot;Feature&quot;,
 *            &quot;geometry&quot;: {
 *                &quot;type&quot;: &quot;Point&quot;,
 *                &quot;coordinates&quot;: [
 *                    -76.53063297271729,
 *                    39.18174077994108
 *                ]
 *            }
 *        }]
 *    }
 * });
     * map.addSource(&#039;some id&#039;, sourceObj); // add
     * map.removeSource(&#039;some id&#039;);  // remove
     */
    function GeoJSONSource(options) {
        options = options || {};

        this._data = options.data;

        if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;

        this._pyramid = new TilePyramid({
            tileSize: 512,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            cacheSize: 20,
            load: this._loadTile.bind(this),
            abort: this._abortTile.bind(this),
            unload: this._unloadTile.bind(this),
            add: this._addTile.bind(this),
            remove: this._removeTile.bind(this)
        });
    }

    GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */{
        minzoom: 0,
        maxzoom: 14,
        _dirty: true,

        /**
         * Update source geojson data and rerender map
         *
         * @param {Object|String} data A GeoJSON data object or URL to it. The latter is preferable in case of large GeoJSON files.
         * @returns {GeoJSONSource} this
         */
        setData: function(data) {
            this._data = data;
            this._dirty = true;

            this.fire(&#039;change&#039;);

            if (this.map)
                this.update(this.map.transform);

            return this;
        },

        onAdd: function(map) {
            this.map = map;
        },

        loaded: function() {
            return this._loaded &amp;&amp; this._pyramid.loaded();
        },

        update: function(transform) {
            if (this._dirty) {
                this._updateData();
            }

            if (this._loaded) {
                this._pyramid.update(this.used, transform);
            }
        },

        reload: function() {
            this._pyramid.reload();
        },

        render: Source._renderTiles,
        featuresAt: Source._vectorFeaturesAt,

        _updateData: function() {
            this._dirty = false;

            this.workerID = this.dispatcher.send(&#039;parse geojson&#039;, {
                data: this._data,
                tileSize: 512,
                source: this.id,
                maxZoom: this.maxzoom
            }, function(err) {

                if (err) {
                    this.fire(&#039;error&#039;, {error: err});
                    return;
                }
                this._loaded = true;
                this._pyramid.reload();

                this.fire(&#039;change&#039;);
            }.bind(this));
        },

        _loadTile: function(tile) {
            var overscaling = tile.zoom &gt; this.maxzoom ? Math.pow(2, tile.zoom - this.maxzoom) : 1;
            var params = {
                uid: tile.uid,
                id: tile.id,
                zoom: tile.zoom,
                maxZoom: this.maxzoom,
                tileSize: 512,
                source: this.id,
                overscaling: overscaling,
                angle: this.map.transform.angle,
                pitch: this.map.transform.pitch,
                collisionDebug: this.map.collisionDebug
            };

            tile.workerID = this.dispatcher.send(&#039;load geojson tile&#039;, params, function(err, data) {

                tile.unloadVectorData(this.map.painter);

                if (tile.aborted)
                    return;

                if (err) {
                    this.fire(&#039;tile.error&#039;, {tile: tile});
                    return;
                }

                tile.loadVectorData(data);
                this.fire(&#039;tile.load&#039;, {tile: tile});

            }.bind(this), this.workerID);
        },

        _abortTile: function(tile) {
            tile.aborted = true;
        },

        _addTile: function(tile) {
            this.fire(&#039;tile.add&#039;, {tile: tile});
        },

        _removeTile: function(tile) {
            this.fire(&#039;tile.remove&#039;, {tile: tile});
        },

        _unloadTile: function(tile) {
            tile.unloadVectorData(this.map.painter);
            this.glyphAtlas.removeGlyphs(tile.uid);
            this.dispatcher.send(&#039;remove tile&#039;, { uid: tile.uid, source: this.id }, null, tile.workerID);
        }
    });

},{&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/source.js&quot;,&quot;./tile_pyramid&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_pyramid.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/geojson_wrapper.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Point = require(&#039;point-geometry&#039;);
    var VectorTileFeature = require(&#039;vector-tile&#039;).VectorTileFeature;

    module.exports = GeoJSONWrapper;

// conform to vectortile api
    function GeoJSONWrapper(features) {
        this.features = features;
        this.length = features.length;
    }

    GeoJSONWrapper.prototype.feature = function(i) {
        return new FeatureWrapper(this.features[i]);
    };

    function FeatureWrapper(feature) {
        this.type = feature.type;
        this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry;
        this.properties = feature.tags;
        this.extent = 4096;
    }

    FeatureWrapper.prototype.loadGeometry = function() {
        var rings = this.rawGeometry;
        this.geometry = [];

        for (var i = 0; i &lt; rings.length; i++) {
            var ring = rings[i],
                newRing = [];
            for (var j = 0; j &lt; ring.length; j++) {
                newRing.push(new Point(ring[j][0], ring[j][1]));
            }
            this.geometry.push(newRing);
        }
        return this.geometry;
    };

    FeatureWrapper.prototype.bbox = function() {
        if (!this.geometry) this.loadGeometry();

        var rings = this.geometry,
            x1 = Infinity,
            x2 = -Infinity,
            y1 = Infinity,
            y2 = -Infinity;

        for (var i = 0; i &lt; rings.length; i++) {
            var ring = rings[i];

            for (var j = 0; j &lt; ring.length; j++) {
                var coord = ring[j];

                x1 = Math.min(x1, coord.x);
                x2 = Math.max(x2, coord.x);
                y1 = Math.min(y1, coord.y);
                y2 = Math.max(y2, coord.y);
            }
        }

        return [x1, y1, x2, y2];
    };

    FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

},{&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;,&quot;vector-tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/raster_tile_source.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var ajax = require(&#039;../util/ajax&#039;);
    var Evented = require(&#039;../util/evented&#039;);
    var TileCoord = require(&#039;./tile_coord&#039;);
    var Source = require(&#039;./source&#039;);
    var normalizeURL = require(&#039;../util/mapbox&#039;).normalizeTileURL;

    module.exports = RasterTileSource;

    function RasterTileSource(options) {
        util.extend(this, util.pick(options, [&#039;url&#039;, &#039;tileSize&#039;]));

        Source._loadTileJSON.call(this, options);
    }

    RasterTileSource.prototype = util.inherit(Evented, {
        minzoom: 0,
        maxzoom: 22,
        tileSize: 512,
        _loaded: false,

        onAdd: function(map) {
            this.map = map;
        },

        loaded: function() {
            return this._pyramid &amp;&amp; this._pyramid.loaded();
        },

        update: function(transform) {
            if (this._pyramid) {
                this._pyramid.update(this.used, transform, this.map.style.rasterFadeDuration);
            }
        },

        render: Source._renderTiles,

        _loadTile: function(tile) {
            ajax.getImage(normalizeURL(TileCoord.url(tile.id, this.tiles), this.url), function(err, img) {
                if (tile.aborted)
                    return;

                if (err) {
                    this.fire(&#039;tile.error&#039;, {tile: tile});
                    return;
                }

                var gl = this.map.painter.gl;
                tile.texture = this.map.painter.getTexture(img.width);
                if (tile.texture) {
                    gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
                } else {
                    tile.texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    tile.texture.size = img.width;
                }
                gl.generateMipmap(gl.TEXTURE_2D);

                tile.timeAdded = new Date().getTime();
                this.map.animationLoop.set(this.style.rasterFadeDuration);

                tile.source = this;
                tile.loaded = true;

                this.fire(&#039;tile.load&#039;, {tile: tile});
            }.bind(this));
        },

        _abortTile: function(tile) {
            tile.aborted = true;
        },

        _addTile: function(tile) {
            this.fire(&#039;tile.add&#039;, {tile: tile});
        },

        _removeTile: function(tile) {
            this.fire(&#039;tile.remove&#039;, {tile: tile});
        },

        _unloadTile: function(tile) {
            if (tile.texture) this.map.painter.saveTexture(tile.texture);
        },

        featuresAt: function(point, params, callback) {
            callback(null, []);
        }
    });

},{&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/mapbox&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mapbox.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/source.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/source.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var ajax = require(&#039;../util/ajax&#039;);
    var browser = require(&#039;../util/browser&#039;);
    var TileCoord = require(&#039;./tile_coord&#039;);
    var TilePyramid = require(&#039;./tile_pyramid&#039;);
    var normalizeURL = require(&#039;../util/mapbox&#039;).normalizeSourceURL;

    exports._loadTileJSON = function(options) {
        var loaded = function(err, tileJSON) {
            if (err) {
                this.fire(&#039;error&#039;, {error: err});
                return;
            }

            util.extend(this, util.pick(tileJSON,
                [&#039;tiles&#039;, &#039;minzoom&#039;, &#039;maxzoom&#039;, &#039;attribution&#039;]));

            this._pyramid = new TilePyramid({
                tileSize: this.tileSize,
                cacheSize: 20,
                minzoom: this.minzoom,
                maxzoom: this.maxzoom,
                reparseOverscaled: this.reparseOverscaled,
                load: this._loadTile.bind(this),
                abort: this._abortTile.bind(this),
                unload: this._unloadTile.bind(this),
                add: this._addTile.bind(this),
                remove: this._removeTile.bind(this),
                redoPlacement: this._redoTilePlacement ? this._redoTilePlacement.bind(this) : undefined
            });

            this.fire(&#039;load&#039;);
        }.bind(this);

        if (options.url) {
            ajax.getJSON(normalizeURL(options.url), loaded);
        } else {
            browser.frame(loaded.bind(this, null, options));
        }
    };

    exports._renderTiles = function(layers, painter) {
        if (!this._pyramid)
            return;

        var ids = this._pyramid.renderedIDs();
        for (var i = 0; i &lt; ids.length; i++) {
            var pos = TileCoord.fromID(ids[i]),
                tile = this._pyramid.getTile(ids[i]),
                z = pos.z,
                x = pos.x,
                y = pos.y,
                w = pos.w;

            // if z &gt; maxzoom then the tile is actually a overscaled maxzoom tile,
            // so calculate the matrix the maxzoom tile would use.
            z = Math.min(z, this.maxzoom);

            x += w * (1 &lt;&lt; z);
            tile.calculateMatrices(z, x, y, painter.transform, painter);

            painter.drawTile(tile, layers);
        }
    };

    exports._vectorFeaturesAt = function(coord, params, callback) {
        if (!this._pyramid)
            return callback(null, []);

        var result = this._pyramid.tileAt(coord);
        if (!result)
            return callback(null, []);

        this.dispatcher.send(&#039;query features&#039;, {
            uid: result.tile.uid,
            x: result.x,
            y: result.y,
            scale: result.scale,
            source: this.id,
            params: params
        }, callback, result.tile.workerID);
    };

    /*
     * Create a tiled data source instance given an options object
     *
     * @param {Object} options
     * @param {String} options.type Either `raster` or `vector`.
     * @param {String} options.url A tile source URL. This should either be `mapbox://{mapid}` or a full `http[s]` url that points to a TileJSON endpoint.
     * @param {Array} options.tiles An array of tile sources. If `url` is not specified, `tiles` can be used instead to specify tile sources, as in the TileJSON spec. Other TileJSON keys such as `minzoom` and `maxzoom` can be specified in a source object if `tiles` is used.
     * @param {String} options.id An optional `id` to assign to the source
     * @param {Number} [options.tileSize=512] Optional tile size (width and height in pixels, assuming tiles are square). This option is only configurable for raster sources
     * @param {Number} options.cacheSize Optional max number of tiles to cache at any given time
     * @example
     * var sourceObj = new mapboxgl.Source.create({
     *    type: &#039;vector&#039;,
     *    url: &#039;mapbox://mapbox.mapbox-streets-v5&#039;
     * });
     * map.addSource(&#039;some id&#039;, sourceObj); // add
     * map.removeSource(&#039;some id&#039;);  // remove
     */
    exports.create = function(source) {
        // This is not at file scope in order to avoid a circular require.
        var sources = {
            vector: require(&#039;./vector_tile_source&#039;),
            raster: require(&#039;./raster_tile_source&#039;),
            geojson: require(&#039;./geojson_source&#039;),
            video: require(&#039;./video_source&#039;)
        };

        for (var type in sources) {
            if (source instanceof sources[type]) {
                return source;
            }
        }

        return new sources[source.type](source);
    };

},{&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;../util/mapbox&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mapbox.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./geojson_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/geojson_source.js&quot;,&quot;./raster_tile_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/raster_tile_source.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;./tile_pyramid&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_pyramid.js&quot;,&quot;./vector_tile_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/vector_tile_source.js&quot;,&quot;./video_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/video_source.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var glmatrix = require(&#039;gl-matrix&#039;);
    var mat2 = glmatrix.mat2;
    var mat4 = glmatrix.mat4;
    var TileCoord = require(&#039;./tile_coord&#039;);
    var util = require(&#039;../util/util&#039;);
    var BufferSet = require(&#039;../data/buffer/buffer_set&#039;);

    module.exports = Tile;

    function Tile(id, size) {
        this.id = id;
        this.uid = util.uniqueId();
        this.loaded = false;
        this.zoom = TileCoord.fromID(id).z;
        this.uses = 0;
        this.tileSize = size;
    }

    Tile.prototype = {
        // todo unhardcode
        tileExtent: 4096,

        calculateMatrices: function(z, x, y, transform) {

            // Initialize model-view matrix that converts from the tile coordinates
            // to screen coordinates.
            var tileScale = Math.pow(2, z);
            var scale = transform.worldSize / tileScale;

            // TODO: remove
            this.scale = scale;

            // The position matrix
            this.posMatrix = new Float64Array(16);
            mat4.identity(this.posMatrix);
            mat4.translate(this.posMatrix, this.posMatrix, [x * scale, y * scale, 0]);

            mat4.scale(this.posMatrix, this.posMatrix, [ scale / this.tileExtent, scale / this.tileExtent, 1 ]);
            mat4.multiply(this.posMatrix, transform.getProjMatrix(), this.posMatrix);

            // The extrusion matrix.
            this.exMatrix = mat4.create();
            mat4.ortho(this.exMatrix, 0, transform.width, transform.height, 0, 0, -1);
            //mat4.rotateZ(this.exMatrix, this.exMatrix, -transform.angle);

            // 2x2 matrix for rotating points
            this.rotationMatrix = mat2.create();
            mat2.rotate(this.rotationMatrix, this.rotationMatrix, transform.angle);

            this.posMatrix = new Float32Array(this.posMatrix);
        },

        positionAt: function(coord) {
            coord = coord.zoomTo(this.zoom);
            var pos = TileCoord.fromID(this.id);
            return {
                x: (coord.column - pos.x) * 4096,
                y: (coord.row - pos.y) * 4096,
                scale: this.scale
            };
        },

        loadVectorData: function(data) {
            this.loaded = true;

            // empty GeoJSON tile
            if (!data) return;

            this.buffers = new BufferSet(data.buffers);
            this.elementGroups = data.elementGroups;
        },

        reloadSymbolData: function(data, painter) {

            if (!this.buffers) {
                // the tile has been destroyed
                return;
            }

            this.buffers.glyphVertex.destroy(painter.gl);
            this.buffers.glyphElement.destroy(painter.gl);
            this.buffers.iconVertex.destroy(painter.gl);
            this.buffers.iconElement.destroy(painter.gl);
            this.buffers.collisionBoxVertex.destroy(painter.gl);

            var buffers = new BufferSet(data.buffers);
            this.buffers.glyphVertex = buffers.glyphVertex;
            this.buffers.glyphElement = buffers.glyphElement;
            this.buffers.iconVertex = buffers.iconVertex;
            this.buffers.iconElement = buffers.iconElement;
            this.buffers.collisionBoxVertex = buffers.collisionBoxVertex;

            for (var id in data.elementGroups) {
                this.elementGroups[id] = data.elementGroups[id];
            }
        },

        unloadVectorData: function(painter) {
            for (var b in this.buffers) {
                this.buffers[b].destroy(painter.gl);
            }
            this.buffers = null;
        }
    };

},{&quot;../data/buffer/buffer_set&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer_set.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;gl-matrix&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    /*
     * Tiles are generally represented as packed integer ids constructed by
     * `TileCoord.toID(x, y, z)`
     */

    var TileCoord = exports;

    TileCoord.toID = function(z, x, y, w) {
        w = w || 0;
        w *= 2;
        if (w &lt; 0) w = w * -1 - 1;
        var dim = 1 &lt;&lt; z;
        return ((dim * dim * w + dim * y + x) * 32) + z;
    };

    TileCoord.asString = function(id) {
        var pos = TileCoord.fromID(id);
        return pos.z + &quot;/&quot; + pos.x + &quot;/&quot; + pos.y;
    };

    /*
     * Parse a packed integer id into an object with x, y, and z properties
     */
    TileCoord.fromID = function(id) {
        var z = id % 32, dim = 1 &lt;&lt; z;
        var xy = ((id - z) / 32);
        var x = xy % dim, y = ((xy - x) / dim) % dim;
        var w = Math.floor(xy / (dim * dim));
        if (w % 2 !== 0) w = w * -1 - 1;
        w /= 2;
        return { z: z, x: x, y: y, w: w };
    };

    /*
     * Given a packed integer id, return its zoom level
     */
    TileCoord.zoom = function(id) {
        return id % 32;
    };

// Given an id and a list of urls, choose a url template and return a tile URL
    TileCoord.url = function(id, urls, sourceMaxZoom) {
        var pos = TileCoord.fromID(id);

        return urls[(pos.x + pos.y) % urls.length]
            .replace(&#039;{prefix}&#039;, (pos.x % 16).toString(16) + (pos.y % 16).toString(16))
            .replace(&#039;{z}&#039;, Math.min(pos.z, sourceMaxZoom || pos.z))
            .replace(&#039;{x}&#039;, pos.x)
            .replace(&#039;{y}&#039;, pos.y);
    };

    /*
     * Given a packed integer id, return the id of its parent tile
     */
    TileCoord.parent = function(id, sourceMaxZoom) {
        var pos = TileCoord.fromID(id);
        if (pos.z === 0) return null;

        // the id represents an overscaled tile, return the same coordinates with a lower z
        if (pos.z &gt; sourceMaxZoom) {
            return TileCoord.toID(pos.z - 1, pos.x, pos.y, pos.w);
        }

        return TileCoord.toID(pos.z - 1, Math.floor(pos.x / 2), Math.floor(pos.y / 2), pos.w);
    };

    TileCoord.parentWithZoom = function(id, zoom) {
        var pos = TileCoord.fromID(id);
        while (pos.z &gt; zoom) {
            pos.z--;
            pos.x = Math.floor(pos.x / 2);
            pos.y = Math.floor(pos.y / 2);
        }
        return TileCoord.toID(pos.z, pos.x, pos.y, pos.w);
    };

    /*
     * Given a packed integer id, return an array of integer ids representing
     * its four children.
     */
    TileCoord.children = function(id, sourceMaxZoom) {
        var pos = TileCoord.fromID(id);

        if (pos.z &gt;= sourceMaxZoom) {
            // return a single tile id representing a an overscaled tile
            return [TileCoord.toID(pos.z + 1, pos.x, pos.y, pos.w)];
        }

        pos.z += 1;
        pos.x *= 2;
        pos.y *= 2;
        return [
            TileCoord.toID(pos.z, pos.x, pos.y, pos.w),
            TileCoord.toID(pos.z, pos.x + 1, pos.y, pos.w),
            TileCoord.toID(pos.z, pos.x, pos.y + 1, pos.w),
            TileCoord.toID(pos.z, pos.x + 1, pos.y + 1, pos.w)
        ];
    };

    TileCoord.zoomTo = function(c, z) {
        c.column = c.column * Math.pow(2, z - c.zoom);
        c.row = c.row * Math.pow(2, z - c.zoom);
        c.zoom = z;
        return c;
    };

// Taken from polymaps src/Layer.js
// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

    function edge(a, b) {
        if (a.row &gt; b.row) { var t = a; a = b; b = t; }
        return {
            x0: a.column,
            y0: a.row,
            x1: b.column,
            y1: b.row,
            dx: b.column - a.column,
            dy: b.row - a.row
        };
    }

    function scanSpans(e0, e1, ymin, ymax, scanLine) {
        var y0 = Math.max(ymin, Math.floor(e1.y0));
        var y1 = Math.min(ymax, Math.ceil(e1.y1));

        // sort edges by x-coordinate
        if ((e0.x0 === e1.x0 &amp;&amp; e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx &lt; e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx &lt; e1.x0)) {
            var t = e0; e0 = e1; e1 = t;
        }

        // scan lines!
        var m0 = e0.dx / e0.dy;
        var m1 = e1.dx / e1.dy;
        var d0 = e0.dx &gt; 0; // use y + 1 to compute x0
        var d1 = e1.dx &lt; 0; // use y + 1 to compute x1
        for (var y = y0; y &lt; y1; y++) {
            var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
            var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
            scanLine(Math.floor(x1), Math.ceil(x0), y);
        }
    }

    function scanTriangle(a, b, c, ymin, ymax, scanLine) {
        var ab = edge(a, b),
            bc = edge(b, c),
            ca = edge(c, a);

        var t;

        // sort edges by y-length
        if (ab.dy &gt; bc.dy) { t = ab; ab = bc; bc = t; }
        if (ab.dy &gt; ca.dy) { t = ab; ab = ca; ca = t; }
        if (bc.dy &gt; ca.dy) { t = bc; bc = ca; ca = t; }

        // scan span! scan span!
        if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
        if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
    }

    TileCoord.cover = function(z, bounds, actualZ) {
        var tiles = 1 &lt;&lt; z;
        var t = {};

        function scanLine(x0, x1, y) {
            var x, wx;
            if (y &gt;= 0 &amp;&amp; y &lt;= tiles) {
                for (x = x0; x &lt; x1; x++) {
                    wx = (x + tiles) % tiles;
                    t[TileCoord.toID(actualZ, wx, y, Math.floor(x / tiles))] = {x: wx, y: y};
                }
            }
        }

        // Divide the screen up in two triangles and scan each of them:
        // +---/
        // | / |
        // /---+
        scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
        scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);

        return Object.keys(t);
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_pyramid.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Tile = require(&#039;./tile&#039;);
    var TileCoord = require(&#039;./tile_coord&#039;);
    var Point = require(&#039;point-geometry&#039;);
    var Cache = require(&#039;../util/mru_cache&#039;);
    var util = require(&#039;../util/util&#039;);

    module.exports = TilePyramid;

    function TilePyramid(options) {
        this.tileSize = options.tileSize;
        this.minzoom = options.minzoom;
        this.maxzoom = options.maxzoom;
        this.reparseOverscaled = options.reparseOverscaled;

        this._load = options.load;
        this._abort = options.abort;
        this._unload = options.unload;
        this._add = options.add;
        this._remove = options.remove;
        this._redoPlacement = options.redoPlacement;

        this._tiles = {};
        this._cache = new Cache(options.cacheSize, function(tile) { return this._unload(tile); }.bind(this));
    }

    TilePyramid.prototype = {
        loaded: function() {
            for (var t in this._tiles) {
                if (!this._tiles[t].loaded)
                    return false;
            }
            return true;
        },

        orderedIDs: function() {
            return Object.keys(this._tiles)
                .sort(function(a, b) { return (b % 32) - (a % 32); }) // z-order
                .map(function(id) { return +id; });
        },

        renderedIDs: function() {
            return this.orderedIDs().filter(function(id) {
                return this._tiles[id].loaded &amp;&amp; !this._coveredTiles[id];
            }.bind(this));
        },

        reload: function() {
            this._cache.reset();
            for (var i in this._tiles) {
                this._load(this._tiles[i]);
            }
        },

        getTile: function(id) {
            return this._tiles[id];
        },

        // get the zoom level adjusted for the difference in map and source tilesizes
        getZoom: function(transform) {
            return transform.zoom + Math.log(transform.tileSize / this.tileSize) / Math.LN2;
        },

        coveringZoomLevel: function(transform) {
            return Math.floor(this.getZoom(transform));
        },

        coveringTiles: function(transform) {
            var z = this.coveringZoomLevel(transform);
            var actualZ = z;

            if (z &lt; this.minzoom) return [];
            if (z &gt; this.maxzoom) z = this.maxzoom;

            var tr = transform,
                tileCenter = TileCoord.zoomTo(tr.locationCoordinate(tr.center), z),
                centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);

            return TileCoord.cover(z, [
                TileCoord.zoomTo(tr.pointCoordinate(new Point(0, 0)), z),
                TileCoord.zoomTo(tr.pointCoordinate(new Point(tr.width, 0)), z),
                TileCoord.zoomTo(tr.pointCoordinate(new Point(tr.width, tr.height)), z),
                TileCoord.zoomTo(tr.pointCoordinate(new Point(0, tr.height)), z)
            ], this.reparseOverscaled ? actualZ : z).sort(function(a, b) {
                return centerPoint.dist(TileCoord.fromID(a)) -
                    centerPoint.dist(TileCoord.fromID(b));
            });
        },

        // Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
        // adds found tiles to retain object; returns true if children completely cover the tile
        findLoadedChildren: function(id, maxCoveringZoom, retain) {
            var complete = true;
            var z = TileCoord.fromID(id).z;
            var ids = TileCoord.children(id, this.maxzoom);
            for (var i = 0; i &lt; ids.length; i++) {
                if (this._tiles[ids[i]] &amp;&amp; this._tiles[ids[i]].loaded) {
                    retain[ids[i]] = true;
                } else {
                    complete = false;
                    if (z &lt; maxCoveringZoom) {
                        // Go further down the hierarchy to find more unloaded children.
                        this.findLoadedChildren(ids[i], maxCoveringZoom, retain);
                    }
                }
            }
            return complete;
        },

        // Find a loaded parent of the given tile (up to minCoveringZoom);
        // adds the found tile to retain object and returns the tile if found
        findLoadedParent: function(id, minCoveringZoom, retain) {
            for (var z = TileCoord.fromID(id).z; z &gt;= minCoveringZoom; z--) {
                id = TileCoord.parent(id, this.maxzoom);
                var tile = this._tiles[id];
                if (tile &amp;&amp; tile.loaded) {
                    retain[id] = true;
                    return tile;
                }
            }
        },

        // Removes tiles that are outside the viewport and adds new tiles that are inside the viewport.
        update: function(used, transform, fadeDuration) {
            var i;
            var id;
            var tile;

            // Determine the overzooming/underzooming amounts.
            var zoom = Math.floor(this.getZoom(transform));
            var minCoveringZoom = util.clamp(zoom - 10, this.minzoom, this.maxzoom);
            var maxCoveringZoom = util.clamp(zoom + 1,  this.minzoom, this.maxzoom);

            // Retain is a list of tiles that we shouldn&#039;t delete, even if they are not
            // the most ideal tile for the current viewport. This may include tiles like
            // parent or child tiles that are *already* loaded.
            var retain = {};
            var now = new Date().getTime();

            // Covered is a list of retained tiles who&#039;s areas are full covered by other,
            // better, retained tiles. They are not drawn separately.
            this._coveredTiles = {};

            var required = used ? this.coveringTiles(transform) : [];
            for (i = 0; i &lt; required.length; i++) {
                id = +required[i];
                tile = this.addTile(id);

                retain[id] = true;

                if (tile.loaded)
                    continue;

                // The tile we require is not yet loaded.
                // Retain child or parent tiles that cover the same area.
                if (!this.findLoadedChildren(id, maxCoveringZoom, retain)) {
                    this.findLoadedParent(id, minCoveringZoom, retain);
                }
            }

            for (id in retain) {
                tile = this._tiles[id];
                if (tile &amp;&amp; tile.timeAdded &gt; now - (fadeDuration || 0)) {
                    // This tile is still fading in. Find tiles to cross-fade with it.
                    if (this.findLoadedChildren(id, maxCoveringZoom, retain)) {
                        this._coveredTiles[id] = true;
                        retain[id] = true;
                    } else {
                        this.findLoadedParent(id, minCoveringZoom, retain);
                    }
                }
            }

            // Remove the tiles we don&#039;t need anymore.
            var remove = util.keysDifference(this._tiles, retain);
            for (i = 0; i &lt; remove.length; i++) {
                this.removeTile(+remove[i]);
            }
        },

        addTile: function(id) {
            var tile = this._tiles[id];
            if (tile)
                return tile;

            var wrapped = this._wrappedID(id);
            tile = this._tiles[wrapped];

            if (!tile) {
                tile = this._cache.get(wrapped);
                if (tile &amp;&amp; this._redoPlacement) {
                    this._redoPlacement(tile);
                }
            }

            if (!tile) {
                var zoom = TileCoord.fromID(id).z;
                var overscaling = zoom &gt; this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
                tile = new Tile(wrapped, this.tileSize * overscaling);
                this._load(tile);
            }

            tile.uses++;
            this._tiles[id] = tile;
            this._add(tile, id);

            return tile;
        },

        removeTile: function(id) {
            var tile = this._tiles[id];
            if (!tile)
                return;

            tile.uses--;
            delete this._tiles[id];
            this._remove(tile, id);

            if (tile.uses &gt; 0)
                return;

            if (tile.loaded) {
                this._cache.add(this._wrappedID(id), tile);
            } else {
                this._abort(tile);
                this._unload(tile);
            }
        },

        clearTiles: function() {
            for (var id in this._tiles)
                this.removeTile(id);
            this._cache.reset();
        },

        tileAt: function(coord) {
            var ids = this.orderedIDs();
            for (var i = 0; i &lt; ids.length; i++) {
                var tile = this._tiles[ids[i]];
                var pos = tile.positionAt(coord);
                if (pos &amp;&amp; pos.x &gt;= 0 &amp;&amp; pos.x &lt; 4096 &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; 4096) {
                    // The click is within the viewport. There is only ever one tile in
                    // a layer that has this property.
                    return {
                        tile: tile,
                        x: pos.x,
                        y: pos.y,
                        scale: pos.scale
                    };
                }
            }
        },

        _wrappedID: function(id) {
            var pos = TileCoord.fromID(id);
            return pos.w === 0 ? id : TileCoord.toID(pos.z, pos.x, pos.y, 0);
        }
    };

},{&quot;../util/mru_cache&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mru_cache.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/vector_tile_source.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var Evented = require(&#039;../util/evented&#039;);
    var TileCoord = require(&#039;./tile_coord&#039;);
    var Source = require(&#039;./source&#039;);

    module.exports = VectorTileSource;

    function VectorTileSource(options) {
        util.extend(this, util.pick(options, [&#039;url&#039;, &#039;tileSize&#039;]));

        if (this.tileSize !== 512) {
            throw new Error(&#039;vector tile sources must have a tileSize of 512&#039;);
        }

        Source._loadTileJSON.call(this, options);
    }

    VectorTileSource.prototype = util.inherit(Evented, {
        minzoom: 0,
        maxzoom: 22,
        tileSize: 512,
        reparseOverscaled: true,
        _loaded: false,

        onAdd: function(map) {
            this.map = map;
        },

        loaded: function() {
            return this._pyramid &amp;&amp; this._pyramid.loaded();
        },

        update: function(transform) {
            if (this._pyramid) {
                this._pyramid.update(this.used, transform);
            }
        },

        reload: function() {
            this._pyramid.reload();
        },

        redoPlacement: function() {
            if (!this._pyramid) {
                return;
            }

            var ids = this._pyramid.orderedIDs();
            for (var i = 0; i &lt; ids.length; i++) {
                var tile = this._pyramid.getTile(ids[i]);
                this._redoTilePlacement(tile);
            }
        },

        render: Source._renderTiles,
        featuresAt: Source._vectorFeaturesAt,

        _loadTile: function(tile) {
            var overscaling = tile.zoom &gt; this.maxzoom ? Math.pow(2, tile.zoom - this.maxzoom) : 1;
            var params = {
                url: TileCoord.url(tile.id, this.tiles, this.maxzoom),
                uid: tile.uid,
                id: tile.id,
                zoom: tile.zoom,
                maxZoom: this.maxzoom,
                tileSize: this.tileSize * overscaling,
                source: this.id,
                overscaling: overscaling,
                angle: this.map.transform.angle,
                pitch: this.map.transform.pitch,
                collisionDebug: this.map.collisionDebug
            };

            if (tile.workerID) {
                this.dispatcher.send(&#039;reload tile&#039;, params, this._tileLoaded.bind(this, tile), tile.workerID);
            } else {
                tile.workerID = this.dispatcher.send(&#039;load tile&#039;, params, this._tileLoaded.bind(this, tile));
            }
        },

        _tileLoaded: function(tile, err, data) {
            if (tile.aborted)
                return;

            if (err) {
                this.fire(&#039;tile.error&#039;, {tile: tile});
                return;
            }

            tile.loadVectorData(data);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                this._redoTilePlacement(tile);
            }

            this.fire(&#039;tile.load&#039;, {tile: tile});
        },

        _abortTile: function(tile) {
            tile.aborted = true;
            this.dispatcher.send(&#039;abort tile&#039;, { uid: tile.uid, source: this.id }, null, tile.workerID);
        },

        _addTile: function(tile) {
            this.fire(&#039;tile.add&#039;, {tile: tile});
        },

        _removeTile: function(tile) {
            this.fire(&#039;tile.remove&#039;, {tile: tile});
        },

        _unloadTile: function(tile) {
            tile.unloadVectorData(this.map.painter);
            this.glyphAtlas.removeGlyphs(tile.uid);
            this.dispatcher.send(&#039;remove tile&#039;, { uid: tile.uid, source: this.id }, null, tile.workerID);
        },

        _redoTilePlacement: function(tile) {

            if (!tile.loaded || tile.redoingPlacement) {
                tile.redoWhenDone = true;
                return;
            }

            tile.redoingPlacement = true;

            this.dispatcher.send(&#039;redo placement&#039;, {
                uid: tile.uid,
                source: this.id,
                angle: this.map.transform.angle,
                pitch: this.map.transform.pitch,
                collisionDebug: this.map.collisionDebug
            }, done.bind(this), tile.workerID);

            function done(_, data) {
                tile.reloadSymbolData(data, this.map.painter);
                this.fire(&#039;tile.load&#039;, {tile: tile});

                tile.redoingPlacement = false;
                if (tile.redoWhenDone) {
                    this._redoTilePlacement(tile);
                    tile.redoWhenDone = false;
                }
            }
        }
    });

},{&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/source.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/video_source.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var Tile = require(&#039;./tile&#039;);
    var TileCoord = require(&#039;./tile_coord&#039;);
    var LatLng = require(&#039;../geo/lat_lng&#039;);
    var Point = require(&#039;point-geometry&#039;);
    var Evented = require(&#039;../util/evented&#039;);
    var ajax = require(&#039;../util/ajax&#039;);

    module.exports = VideoSource;

    /**
     * Create a Video data source instance given an options object
     * @class VideoSource
     * @param {Object} [options]
     * @param {String|Array} options.url A string or array of URL(s) to video files
     * @param {Array} options.coordinates lat,lng coordinates in order clockwise starting at the top left: tl, tr, br, bl
     * @example
     * var sourceObj = new mapboxgl.VideoSource({
 *    url: [
 *        &#039;https://www.mapbox.com/videos/baltimore-smoke.mp4&#039;,
 *        &#039;https://www.mapbox.com/videos/baltimore-smoke.webm&#039;
 *    ],
 *    coordinates: [
 *        [39.18579907229748, -76.54335737228394],
 *        [39.1838364847587, -76.52803659439087],
 *        [39.17683392507606, -76.5295386314392],
 *        [39.17876344106642, -76.54520273208618]
 *    ]
 * });
     * map.addSource(&#039;some id&#039;, sourceObj); // add
     * map.removeSource(&#039;some id&#039;);  // remove
     */
    function VideoSource(options) {
        this.coordinates = options.coordinates;

        ajax.getVideo(options.url, function(err, video) {
            // @TODO handle errors via event.
            if (err) return;

            this.video = video;
            this.video.loop = true;

            var loopID;

            // start repainting when video starts playing
            this.video.addEventListener(&#039;playing&#039;, function() {
                loopID = this.map.style.animationLoop.set(Infinity);
                this.map._rerender();
            }.bind(this));

            // stop repainting when video stops
            this.video.addEventListener(&#039;pause&#039;, function() {
                this.map.style.animationLoop.cancel(loopID);
            }.bind(this));

            this._loaded = true;

            if (this.map) {
                this.video.play();
                this.createTile();
                this.fire(&#039;change&#039;);
            }
        }.bind(this));
    }

    VideoSource.prototype = util.inherit(Evented, {
        onAdd: function(map) {
            this.map = map;
            if (this.video) {
                this.video.play();
                this.createTile();
            }
        },

        createTile: function() {
            /*
             * Calculate which mercator tile is suitable for rendering the video in
             * and create a buffer with the corner coordinates. These coordinates
             * may be outside the tile, because raster tiles aren&#039;t clipped when rendering.
             */
            var map = this.map;
            var coords = this.coordinates.map(function(latlng) {
                var loc = LatLng.convert(latlng);
                return TileCoord.zoomTo(map.transform.locationCoordinate(loc), 0);
            });

            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;

            for (var i = 0; i &lt; coords.length; i++) {
                minX = Math.min(minX, coords[i].column);
                minY = Math.min(minY, coords[i].row);
                maxX = Math.max(maxX, coords[i].column);
                maxY = Math.max(maxY, coords[i].row);
            }

            var dx = maxX - minX;
            var dy = maxY - minY;
            var dMax = Math.max(dx, dy);
            var center = TileCoord.zoomTo({
                column: (minX + maxX) / 2,
                row: (minY + maxY) / 2,
                zoom: 0
            }, Math.floor(-Math.log(dMax) / Math.LN2));

            var tileExtent = 4096;
            var tileCoords = coords.map(function(coord) {
                var zoomedCoord = TileCoord.zoomTo(coord, center.zoom);
                return new Point(
                    Math.round((zoomedCoord.column - center.column) * tileExtent),
                    Math.round((zoomedCoord.row - center.row) * tileExtent));
            });

            var gl = map.painter.gl;
            var maxInt16 = 32767;
            var array = new Int16Array([
                tileCoords[0].x, tileCoords[0].y, 0, 0,
                tileCoords[1].x, tileCoords[1].y, maxInt16, 0,
                tileCoords[3].x, tileCoords[3].y, 0, maxInt16,
                tileCoords[2].x, tileCoords[2].y, maxInt16, maxInt16
            ]);

            this.tile = new Tile();
            this.tile.buckets = {};

            this.tile.boundsBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tile.boundsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);

            this.center = center;
        },

        loaded: function() {
            return this.video &amp;&amp; this.video.readyState &gt;= 2;
        },

        update: function() {
            // noop
        },

        render: function(layers, painter) {
            if (!this._loaded) return;
            if (this.video.readyState &lt; 2) return; // not enough data for current position

            var c = this.center;
            this.tile.calculateMatrices(c.zoom, c.column, c.row, this.map.transform, painter);

            var gl = painter.gl;
            if (!this.tile.texture) {
                this.tile.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
            } else {
                gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
            }

            painter.drawLayers(layers, this.tile.posMatrix, this.tile);
        },

        featuresAt: function(point, params, callback) {
            return callback(null, []);
        }
    });

},{&quot;../geo/lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;,&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/worker.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Actor = require(&#039;../util/actor&#039;);
    var WorkerTile = require(&#039;./worker_tile&#039;);
    var util = require(&#039;../util/util&#039;);
    var ajax = require(&#039;../util/ajax&#039;);
    var vt = require(&#039;vector-tile&#039;);
    var Protobuf = require(&#039;pbf&#039;);
    var TileCoord = require(&#039;./tile_coord&#039;);

    var geojsonvt = require(&#039;geojson-vt&#039;);
    var GeoJSONWrapper = require(&#039;./geojson_wrapper&#039;);

    module.exports = Worker;

    function Worker(self) {
        this.self = self;
        this.actor = new Actor(self, this);
        this.loading = {};

        this.loaded = {};
        this.layers = [];
        this.geoJSONIndexes = {};
    }

    util.extend(Worker.prototype, {
        &#039;set layers&#039;: function(layers) {
            this.layers = layers;
        },

        &#039;load tile&#039;: function(params, callback) {
            var source = params.source,
                uid = params.uid;

            if (!this.loading[source])
                this.loading[source] = {};


            var tile = this.loading[source][uid] = new WorkerTile(params);

            tile.xhr = ajax.getArrayBuffer(params.url, done.bind(this));

            function done(err, data) {
                delete this.loading[source][uid];

                if (err) return callback(err);

                tile.data = new vt.VectorTile(new Protobuf(new Uint8Array(data)));
                tile.parse(tile.data, this.layers, this.actor, callback);

                this.loaded[source] = this.loaded[source] || {};
                this.loaded[source][uid] = tile;
            }
        },

        &#039;reload tile&#039;: function(params, callback) {
            var loaded = this.loaded[params.source],
                uid = params.uid;
            if (loaded &amp;&amp; loaded[uid]) {
                var tile = loaded[uid];
                tile.parse(tile.data, this.layers, this.actor, callback);
            }
        },

        &#039;abort tile&#039;: function(params) {
            var loading = this.loading[params.source],
                uid = params.uid;
            if (loading &amp;&amp; loading[uid]) {
                loading[uid].xhr.abort();
                delete loading[uid];
            }
        },

        &#039;remove tile&#039;: function(params) {
            var loaded = this.loaded[params.source],
                uid = params.uid;
            if (loaded &amp;&amp; loaded[uid]) {
                delete loaded[uid];
            }
        },

        &#039;redo placement&#039;: function(params, callback) {
            var loaded = this.loaded[params.source],
                loading = this.loading[params.source],
                uid = params.uid;

            if (loaded &amp;&amp; loaded[uid]) {
                var tile = loaded[uid];
                var result = tile.redoPlacement(params.angle, params.pitch, params.collisionDebug);

                if (result.result) {
                    callback(null, result.result, result.transferables);
                }

            } else if (loading &amp;&amp; loading[uid]) {
                loading[uid].angle = params.angle;
            }
        },

        &#039;parse geojson&#039;: function(params, callback) {
            var indexData = function(err, data) {
                if (err) return callback(err);
                this.geoJSONIndexes[params.source] = geojsonvt(data, {baseZoom: params.maxZoom});
                callback(null);
            }.bind(this);

            // TODO accept params.url for urls instead
            if (typeof params.data === &#039;string&#039;) ajax.getJSON(params.data, indexData);
            else indexData(null, params.data);
        },

        &#039;load geojson tile&#039;: function(params, callback) {
            var source = params.source,
                coord = TileCoord.fromID(params.id);

            // console.time(&#039;tile &#039; + coord.z + &#039; &#039; + coord.x + &#039; &#039; + coord.y);

            var geoJSONTile = this.geoJSONIndexes[source].getTile(coord.z, coord.x, coord.y);

            // console.timeEnd(&#039;tile &#039; + coord.z + &#039; &#039; + coord.x + &#039; &#039; + coord.y);

            // if (!geoJSONTile) console.log(&#039;not found&#039;, this.geoJSONIndexes[source], coord);

            if (!geoJSONTile) return callback(null, null); // nothing in the given tile

            var tile = new WorkerTile(params);
            tile.parse(new GeoJSONWrapper(geoJSONTile.features), this.layers, this.actor, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][params.uid] = tile;
        },

        &#039;query features&#039;: function(params, callback) {
            var tile = this.loaded[params.source] &amp;&amp; this.loaded[params.source][params.uid];
            if (tile) {
                tile.featureTree.query(params, callback);
            } else {
                callback(null, []);
            }
        }
    });

},{&quot;../util/actor&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/actor.js&quot;,&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./geojson_wrapper&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/geojson_wrapper.js&quot;,&quot;./tile_coord&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/tile_coord.js&quot;,&quot;./worker_tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/worker_tile.js&quot;,&quot;geojson-vt&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/index.js&quot;,&quot;pbf&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/index.js&quot;,&quot;vector-tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/worker_tile.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var FeatureTree = require(&#039;../data/feature_tree&#039;);
    var Collision = require(&#039;../symbol/collision_tile&#039;);
    var BufferSet = require(&#039;../data/buffer/buffer_set&#039;);
    var createBucket = require(&#039;../data/create_bucket&#039;);

    module.exports = WorkerTile;

    function WorkerTile(params) {
        this.id = params.id;
        this.uid = params.uid;
        this.zoom = params.zoom;
        this.maxZoom = params.maxZoom;
        this.tileSize = params.tileSize;
        this.source = params.source;
        this.overscaling = params.overscaling;
        this.angle = params.angle;
        this.pitch = params.pitch;
        this.collisionDebug = params.collisionDebug;

        this.stacks = {};
    }

    WorkerTile.prototype.parse = function(data, layers, actor, callback) {

        this.status = &#039;parsing&#039;;

        this.featureTree = new FeatureTree(this.id);

        var i, k,
            tile = this,
            layer,
            bucket,
            buffers = new BufferSet(),
            collision = this.collision = new Collision(this.zoom, 4096, this.tileSize),
            buckets = {},
            bucketsInOrder = this.bucketsInOrder = [],
            bucketsBySourceLayer = {};

        collision.reset(this.angle, this.pitch);

        // Map non-ref layers to buckets.
        for (i = 0; i &lt; layers.length; i++) {
            layer = layers[i];

            if (layer.source !== this.source)
                continue;

            if (layer.ref)
                continue;

            var minzoom = layer.minzoom;
            if (minzoom &amp;&amp; this.zoom &lt; minzoom &amp;&amp; minzoom &lt; this.maxZoom)
                continue;

            var maxzoom = layer.maxzoom;
            if (maxzoom &amp;&amp; this.zoom &gt;= maxzoom)
                continue;

            var visibility = layer.layout.visibility;
            if (visibility === &#039;none&#039;)
                continue;

            bucket = createBucket(layer, buffers, collision, this.zoom, this.overscaling, this.collisionDebug);
            bucket.layers = [layer.id];

            buckets[bucket.id] = bucket;
            bucketsInOrder.push(bucket);

            if (data.layers) {
                // vectortile
                var sourceLayer = layer[&#039;source-layer&#039;];
                if (!bucketsBySourceLayer[sourceLayer])
                    bucketsBySourceLayer[sourceLayer] = {};
                bucketsBySourceLayer[sourceLayer][bucket.id] = bucket;
            } else {
                // geojson tile
                bucketsBySourceLayer[bucket.id] = bucket;
            }
        }

        // Index ref layers.
        for (i = 0; i &lt; layers.length; i++) {
            layer = layers[i];

            if (layer.source !== this.source)
                continue;

            if (!layer.ref)
                continue;

            bucket = buckets[layer.ref];
            if (!bucket)
                continue;

            bucket.layers.push(layer.id);
        }

        // read each layer, and sort its features into buckets
        if (data.layers) {
            // vectortile
            for (k in bucketsBySourceLayer) {
                layer = data.layers[k];
                if (!layer) continue;
                sortLayerIntoBuckets(layer, bucketsBySourceLayer[k]);
            }
        } else {
            // geojson
            sortLayerIntoBuckets(data, bucketsBySourceLayer);
        }

        function sortLayerIntoBuckets(layer, buckets) {
            for (var i = 0; i &lt; layer.length; i++) {
                var feature = layer.feature(i);
                for (var key in buckets) {
                    var bucket = buckets[key];
                    if (bucket.filter(feature)) {
                        bucket.features.push(feature);
                    }
                }
            }
        }

        var prevPlacementBucket;
        var remaining = bucketsInOrder.length;

        /*
         *  The async parsing here is a bit tricky.
         *  Some buckets depend on resources that may need to be loaded async (glyphs).
         *  Some buckets need to be parsed in order (to get collision priorities right).
         *
         *  Dependencies calls are initiated first to get those rolling.
         *  Buckets that don&#039;t need to be parsed in order, aren&#039;t to save time.
         */

        for (i = 0; i &lt; bucketsInOrder.length; i++) {
            bucket = bucketsInOrder[i];

            // Link buckets that need to be parsed in order
            if (bucket.collision) {
                if (prevPlacementBucket) {
                    prevPlacementBucket.next = bucket;
                } else {
                    bucket.previousPlaced = true;
                }
                prevPlacementBucket = bucket;
            }

            if (bucket.getDependencies) {
                bucket.getDependencies(this, actor, dependenciesDone(bucket));
            }

            // immediately parse buckets where order doesn&#039;t matter and no dependencies
            if (!bucket.collision &amp;&amp; !bucket.getDependencies) {
                parseBucket(tile, bucket);
            }
        }

        function dependenciesDone(bucket) {
            return function(err) {
                bucket.dependenciesLoaded = true;
                parseBucket(tile, bucket, err);
            };
        }

        function parseBucket(tile, bucket, skip) {
            if (bucket.getDependencies &amp;&amp; !bucket.dependenciesLoaded) return;
            if (bucket.collision &amp;&amp; !bucket.previousPlaced) return;

            if (!skip) {
                var now = Date.now();
                if (bucket.features.length) bucket.addFeatures();
                var time = Date.now() - now;
                if (bucket.interactive) {
                    for (var i = 0; i &lt; bucket.features.length; i++) {
                        var feature = bucket.features[i];
                        tile.featureTree.insert(feature.bbox(), bucket.layers, feature);
                    }
                }
                if (typeof self !== &#039;undefined&#039;) {
                    self.bucketStats = self.bucketStats || {_total: 0};
                    self.bucketStats._total += time;
                    self.bucketStats[bucket.id] = (self.bucketStats[bucket.id] || 0) + time;
                }
            }

            remaining--;

            if (!remaining) {
                done();
                return;
            }

            // try parsing the next bucket, if it is ready
            if (bucket.next) {
                bucket.next.previousPlaced = true;
                parseBucket(tile, bucket.next);
            }
        }

        function done() {

            tile.status = &#039;done&#039;;

            if (tile.redoPlacementAfterDone) {
                var result = tile.redoPlacement(tile.angle, tile.pitch).result;
                buffers.glyphVertex = result.buffers.glyphVertex;
                buffers.iconVertex = result.buffers.iconVertex;
                buffers.collisionBoxVertex = result.buffers.collisionBoxVertex;
            }

            var transferables = [],
                elementGroups = {};

            for (k in buffers) {
                transferables.push(buffers[k].array);
            }

            for (k in buckets) {
                elementGroups[k] = buckets[k].elementGroups;
            }

            callback(null, {
                elementGroups: elementGroups,
                buffers: buffers
            }, transferables);
        }
    };

    WorkerTile.prototype.redoPlacement = function(angle, pitch, collisionDebug) {

        if (this.status !== &#039;done&#039;) {
            this.redoPlacementAfterDone = true;
            this.angle = angle;
            return {};
        }

        var buffers = new BufferSet();
        var transferables = [];
        var elementGroups = {};
        var collision = this.collision;

        collision.reset(angle, pitch);

        var bucketsInOrder = this.bucketsInOrder;
        for (var i = 0; i &lt; bucketsInOrder.length; i++) {
            var bucket = bucketsInOrder[i];

            if (bucket.type === &#039;symbol&#039;) {
                bucket.placeFeatures(buffers, collisionDebug);
                elementGroups[bucket.id] = bucket.elementGroups;
            }
        }

        for (var k in buffers) {
            transferables.push(buffers[k].array);
        }

        return {
            result: {
                elementGroups: elementGroups,
                buffers: buffers
            },
            transferables: transferables
        };

    };

},{&quot;../data/buffer/buffer_set&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/buffer/buffer_set.js&quot;,&quot;../data/create_bucket&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/create_bucket.js&quot;,&quot;../data/feature_tree&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/data/feature_tree.js&quot;,&quot;../symbol/collision_tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/collision_tile.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/animation_loop.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = AnimationLoop;

    function AnimationLoop() {
        this.n = 0;
        this.times = [];
    }

// Are all animations done?
    AnimationLoop.prototype.stopped = function() {
        this.times = this.times.filter(function(t) {
            return t.time &gt;= (new Date()).getTime();
        });
        return !this.times.length;
    };

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
    AnimationLoop.prototype.set = function(t) {
        this.times.push({ id: this.n, time: t + (new Date()).getTime() });
        return this.n++;
    };

// Cancel an animation
    AnimationLoop.prototype.cancel = function(n) {
        this.times = this.times.filter(function(t) {
            return t.id !== n;
        });
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/image_sprite.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Evented = require(&#039;../util/evented&#039;);
    var ajax = require(&#039;../util/ajax&#039;);
    var browser = require(&#039;../util/browser&#039;);

    module.exports = ImageSprite;

    function ImageSprite(base) {
        this.base = base;
        this.retina = browser.devicePixelRatio &gt; 1;

        base = this.base + (this.retina ? &#039;@2x&#039; : &#039;&#039;);

        ajax.getJSON(base + &#039;.json&#039;, function(err, data) {
            if (err) {
                this.fire(&#039;error&#039;, {error: err});
                return;
            }

            this.data = data;
            if (this.img) this.fire(&#039;load&#039;);
        }.bind(this));

        ajax.getImage(base + &#039;.png&#039;, function(err, img) {
            if (err) {
                this.fire(&#039;error&#039;, {error: err});
                return;
            }

            // premultiply the sprite
            var data = img.getData();
            var newdata = img.data = new Uint8Array(data.length);
            for (var i = 0; i &lt; data.length; i += 4) {
                var alpha = data[i + 3] / 255;
                newdata[i + 0] = data[i + 0] * alpha;
                newdata[i + 1] = data[i + 1] * alpha;
                newdata[i + 2] = data[i + 2] * alpha;
                newdata[i + 3] = data[i + 3];
            }

            this.img = img;
            if (this.data) this.fire(&#039;load&#039;);
        }.bind(this));
    }

    ImageSprite.prototype = Object.create(Evented);

    ImageSprite.prototype.toJSON = function() {
        return this.base;
    };

    ImageSprite.prototype.loaded = function() {
        return !!(this.data &amp;&amp; this.img);
    };

    ImageSprite.prototype.resize = function(/*gl*/) {
        if (browser.devicePixelRatio &gt; 1 !== this.retina) {
            var newSprite = new ImageSprite(this.base);
            newSprite.on(&#039;load&#039;, function() {
                this.img = newSprite.img;
                this.data = newSprite.data;
                this.retina = newSprite.retina;
            }.bind(this));
        }
    };

    function SpritePosition() {}
    SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };

    ImageSprite.prototype.getSpritePosition = function(name) {
        if (!this.loaded()) return new SpritePosition();

        var pos = this.data &amp;&amp; this.data[name];
        if (pos &amp;&amp; this.img) return pos;

        return new SpritePosition();
    };

},{&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/layout_properties.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var reference = require(&#039;./reference&#039;);

    module.exports = {};

    reference.layout.forEach(function(className) {
        var Properties = function(props) {
            for (var p in props) {
                this[p] = props[p];
            }
        };

        var properties = reference[className];
        for (var prop in properties) {
            if (properties[prop].default === undefined) continue;
            Properties.prototype[prop] = properties[prop].default;
        }
        module.exports[className.replace(&#039;layout_&#039;, &#039;&#039;)] = Properties;
    });

},{&quot;./reference&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/reference.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/paint_properties.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var reference = require(&#039;./reference&#039;);
    var parseCSSColor = require(&#039;csscolorparser&#039;).parseCSSColor;

    module.exports = {};

    reference.paint.forEach(function(className) {
        var Calculated = function() {};

        var properties = reference[className];
        for (var p in properties) {
            var prop = properties[p],
                value = prop.default;

            if (value === undefined) continue;
            if (prop.type === &#039;color&#039;) value = parseCSSColor(value);

            Calculated.prototype[p] = value;
        }

        Calculated.prototype.hidden = false;
        module.exports[className.replace(&#039;paint_&#039;, &#039;&#039;)] = Calculated;
    });

},{&quot;./reference&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/reference.js&quot;,&quot;csscolorparser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/csscolorparser/csscolorparser.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/reference.js&quot;:[function(require,module,exports){
    module.exports = require(&#039;mapbox-gl-style-spec/reference/latest&#039;);

},{&quot;mapbox-gl-style-spec/reference/latest&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/reference/latest.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Evented = require(&#039;../util/evented&#039;);
    var Source = require(&#039;../source/source&#039;);
    var StyleLayer = require(&#039;./style_layer&#039;);
    var ImageSprite = require(&#039;./image_sprite&#039;);
    var GlyphSource = require(&#039;../symbol/glyph_source&#039;);
    var GlyphAtlas = require(&#039;../symbol/glyph_atlas&#039;);
    var SpriteAtlas = require(&#039;../symbol/sprite_atlas&#039;);
    var LineAtlas = require(&#039;../render/line_atlas&#039;);
    var util = require(&#039;../util/util&#039;);
    var ajax = require(&#039;../util/ajax&#039;);
    var normalizeURL = require(&#039;../util/mapbox&#039;).normalizeStyleURL;
    var browser = require(&#039;../util/browser&#039;);
    var Dispatcher = require(&#039;../util/dispatcher&#039;);
    var AnimationLoop = require(&#039;./animation_loop&#039;);
    var validate = require(&#039;mapbox-gl-style-spec/lib/validate/latest&#039;);

    module.exports = Style;

    function Style(stylesheet, animationLoop) {
        this.animationLoop = animationLoop || new AnimationLoop();
        this.dispatcher = new Dispatcher(Math.max(browser.hardwareConcurrency - 1, 1), this);
        this.glyphAtlas = new GlyphAtlas(1024, 1024);
        this.spriteAtlas = new SpriteAtlas(512, 512);
        this.spriteAtlas.resize(browser.devicePixelRatio);
        this.lineAtlas = new LineAtlas(256, 512);

        this._layers = {};
        this._order  = [];
        this._groups = [];
        this.sources = {};

        this.zoomHistory = {};

        util.bindAll([
            &#039;_forwardSourceEvent&#039;,
            &#039;_forwardTileEvent&#039;,
            &#039;_redoPlacement&#039;
        ], this);

        var loaded = function(err, stylesheet) {
            if (err) {
                this.fire(&#039;error&#039;, {error: err});
                return;
            }

            var valid = validate(stylesheet);
            if (valid.length) {
                valid.forEach(function(e) {
                    throw new Error(e.message);
                });
            }

            this._loaded = true;
            this.stylesheet = stylesheet;

            var sources = stylesheet.sources;
            for (var id in sources) {
                this.addSource(id, sources[id]);
            }

            if (stylesheet.sprite) {
                this.sprite = new ImageSprite(stylesheet.sprite);
                this.sprite.on(&#039;load&#039;, this.fire.bind(this, &#039;change&#039;));
            }

            this.glyphSource = new GlyphSource(stylesheet.glyphs, this.glyphAtlas);
            this._resolve();
            this.fire(&#039;load&#039;);
        }.bind(this);

        if (typeof stylesheet === &#039;string&#039;) {
            ajax.getJSON(normalizeURL(stylesheet), loaded);
        } else {
            browser.frame(loaded.bind(this, null, stylesheet));
        }
    }

    Style.prototype = util.inherit(Evented, {
        _loaded: false,

        loaded: function() {
            if (!this._loaded)
                return false;

            for (var id in this.sources)
                if (!this.sources[id].loaded())
                    return false;

            if (this.sprite &amp;&amp; !this.sprite.loaded())
                return false;

            return true;
        },

        _resolve: function() {
            var id, layer;

            this._layers = {};
            this._order  = [];

            for (var i = 0; i &lt; this.stylesheet.layers.length; i++) {
                layer = new StyleLayer(this.stylesheet.layers[i], this.stylesheet.constants || {});
                this._layers[layer.id] = layer;
                this._order.push(layer.id);
            }

            // Resolve layout properties.
            for (id in this._layers) {
                this._layers[id].resolveLayout();
            }

            // Resolve reference and paint properties.
            for (id in this._layers) {
                this._layers[id].resolveReference(this._layers);
                this._layers[id].resolvePaint();
            }

            this._groupLayers();
            this._broadcastLayers();
        },

        _groupLayers: function() {
            var group;

            this._groups = [];

            // Split into groups of consecutive top-level layers with the same source.
            for (var i = 0; i &lt; this._order.length; ++i) {
                var layer = this._layers[this._order[i]];

                if (!group || layer.source !== group.source) {
                    group = [];
                    group.source = layer.source;
                    this._groups.push(group);
                }

                group.push(layer);
            }
        },

        _broadcastLayers: function() {
            var ordered = [];

            for (var id in this._layers) {
                ordered.push(this._layers[id].json());
            }

            this.dispatcher.broadcast(&#039;set layers&#039;, ordered);
        },

        _cascade: function(classes, options) {
            if (!this._loaded) return;

            options = options || {
                transition: true
            };

            for (var id in this._layers) {
                this._layers[id].cascade(classes, options,
                        this.stylesheet.transition || {},
                    this.animationLoop);
            }

            this.fire(&#039;change&#039;);
        },

        _recalculate: function(z) {
            for (var id in this.sources)
                this.sources[id].used = false;

            this._updateZoomHistory(z);

            this.rasterFadeDuration = 300;
            for (id in this._layers) {
                var layer = this._layers[id];

                if (layer.recalculate(z, this.zoomHistory) &amp;&amp; layer.source) {
                    this.sources[layer.source].used = true;
                }
            }

            var maxZoomTransitionDuration = 300;
            if (Math.floor(this.z) !== Math.floor(z)) {
                this.animationLoop.set(maxZoomTransitionDuration);
            }

            this.z = z;
            this.fire(&#039;zoom&#039;);
        },

        _updateZoomHistory: function(z) {

            var zh = this.zoomHistory;

            if (zh.lastIntegerZoom === undefined) {
                // first time
                zh.lastIntegerZoom = Math.floor(z);
                zh.lastIntegerZoomTime = 0;
                zh.lastZoom = z;
            }

            // check whether an integer zoom level as passed since the last frame
            // and if yes, record it with the time. Used for transitioning patterns.
            if (Math.floor(zh.lastZoom) &lt; Math.floor(z)) {
                zh.lastIntegerZoom = Math.floor(z);
                zh.lastIntegerZoomTime = Date.now();

            } else if (Math.floor(zh.lastZoom) &gt; Math.floor(z)) {
                zh.lastIntegerZoom = Math.floor(z + 1);
                zh.lastIntegerZoomTime = Date.now();
            }

            zh.lastZoom = z;
        },

        addSource: function(id, source) {
            if (this.sources[id] !== undefined) {
                throw new Error(&#039;There is already a source with this ID&#039;);
            }
            source = Source.create(source);
            this.sources[id] = source;
            source.id = id;
            source.style = this;
            source.dispatcher = this.dispatcher;
            source.glyphAtlas = this.glyphAtlas;
            source
                .on(&#039;load&#039;, this._forwardSourceEvent)
                .on(&#039;error&#039;, this._forwardSourceEvent)
                .on(&#039;change&#039;, this._forwardSourceEvent)
                .on(&#039;tile.add&#039;, this._forwardTileEvent)
                .on(&#039;tile.load&#039;, this._forwardTileEvent)
                .on(&#039;tile.error&#039;, this._forwardTileEvent)
                .on(&#039;tile.remove&#039;, this._forwardTileEvent);
            this.fire(&#039;source.add&#039;, {source: source});
            return this;
        },

        /**
         * Remove a source from this stylesheet, given its id.
         * @param {String} id id of the source to remove
         * @returns {Style} this style
         * @throws {Error} if no source is found with the given ID
         * @private
         */
        removeSource: function(id) {
            if (this.sources[id] === undefined) {
                throw new Error(&#039;There is no source with this ID&#039;);
            }
            var source = this.sources[id];
            delete this.sources[id];
            source
                .off(&#039;load&#039;, this._forwardSourceEvent)
                .off(&#039;error&#039;, this._forwardSourceEvent)
                .off(&#039;change&#039;, this._forwardSourceEvent)
                .off(&#039;tile.add&#039;, this._forwardTileEvent)
                .off(&#039;tile.load&#039;, this._forwardTileEvent)
                .off(&#039;tile.error&#039;, this._forwardTileEvent)
                .off(&#039;tile.remove&#039;, this._forwardTileEvent);
            this.fire(&#039;source.remove&#039;, {source: source});
            return this;
        },

        /**
         * Get a source by id.
         * @param {String} id id of the desired source
         * @returns {Object} source
         * @private
         */
        getSource: function(id) {
            return this.sources[id];
        },

        addLayer: function(layer, before) {
            if (this._layers[layer.id] !== undefined) {
                throw new Error(&#039;There is already a layer with this ID&#039;);
            }
            layer = new StyleLayer(layer, this.stylesheet.constants || {});
            this._layers[layer.id] = layer;
            this._order.splice(before ? this._order.indexOf(before) : Infinity, 0, layer.id);
            layer.resolveLayout();
            layer.resolveReference(this._layers);
            layer.resolvePaint();
            this._groupLayers();
            this._broadcastLayers();
            this.fire(&#039;layer.add&#039;, {layer: layer});
            return this;
        },

        /**
         * Remove a layer from this stylesheet, given its id.
         * @param {String} id id of the layer to remove
         * @returns {Style} this style
         * @throws {Error} if no layer is found with the given ID
         * @private
         */
        removeLayer: function(id) {
            var layer = this._layers[id];
            if (layer === undefined) {
                throw new Error(&#039;There is no layer with this ID&#039;);
            }
            for (var i in this._layers) {
                if (this._layers[i].ref === id) {
                    this.removeLayer(i);
                }
            }
            delete this._layers[id];
            this._order.splice(this._order.indexOf(id), 1);
            this._groupLayers();
            this._broadcastLayers();
            this.fire(&#039;layer.remove&#039;, {layer: layer});
            return this;
        },

        /**
         * Get a layer by id.
         * @param {String} id id of the desired layer
         * @returns {Layer} layer
         * @private
         */
        getLayer: function(id) {
            return this._layers[id];
        },

        /**
         * If a layer has a `ref` property that makes it derive some values
         * from another layer, return that referent layer. Otherwise,
         * returns the layer itself.
         * @param {String} id the layer&#039;s id
         * @returns {Layer} the referent layer or the layer itself
         * @private
         */
        getReferentLayer: function(id) {
            var layer = this.getLayer(id);
            if (layer.ref) {
                layer = this.getLayer(layer.ref);
            }
            return layer;
        },

        setFilter: function(layer, filter) {
            layer = this.getReferentLayer(layer);
            layer.filter = filter;
            this._broadcastLayers();
            this.sources[layer.source].reload();
        },

        /**
         * Get a layer&#039;s filter object
         * @param {String} layer the layer to inspect
         * @returns {*} the layer&#039;s filter, if any
         * @private
         */
        getFilter: function(layer) {
            return this.getReferentLayer(layer).filter;
        },

        setLayoutProperty: function(layer, name, value) {
            layer = this.getReferentLayer(layer);
            layer.setLayoutProperty(name, value);
            this._broadcastLayers();
            this.sources[layer.source].reload();
        },

        /**
         * Get a layout property&#039;s value from a given layer
         * @param {String} layer the layer to inspect
         * @param {String} name the name of the layout property
         * @returns {*} the property value
         * @private
         */
        getLayoutProperty: function(layer, name) {
            return this.getReferentLayer(layer).getLayoutProperty(name);
        },

        setPaintProperty: function(layer, name, value, klass) {
            this.getLayer(layer).setPaintProperty(name, value, klass);
        },

        getPaintProperty: function(layer, name, klass) {
            return this.getLayer(layer).getPaintProperty(name, klass);
        },

        featuresAt: function(coord, params, callback) {
            var features = [];
            var error = null;

            if (params.layer) {
                params.layer = { id: params.layer };
            }

            util.asyncEach(Object.keys(this.sources), function(id, callback) {
                var source = this.sources[id];
                source.featuresAt(coord, params, function(err, result) {
                    if (result) features = features.concat(result);
                    if (err) error = err;
                    callback();
                });
            }.bind(this), function() {
                if (error) return callback(error);

                features.forEach(function(feature) {
                    feature.layer = this._layers[feature.layer].json();
                }.bind(this));

                callback(null, features);
            }.bind(this));
        },

        _remove: function() {
            this.dispatcher.remove();
        },

        _updateSources: function(transform) {
            for (var id in this.sources) {
                this.sources[id].update(transform);
            }
        },

        _redoPlacement: function() {
            for (var id in this.sources) {
                if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
            }
        },

        _forwardSourceEvent: function(e) {
            this.fire(&#039;source.&#039; + e.type, util.extend({source: e.target}, e));
        },

        _forwardTileEvent: function(e) {
            this.fire(e.type, util.extend({source: e.target}, e));
        },

        // Callbacks from web workers

        &#039;get sprite json&#039;: function(params, callback) {
            var sprite = this.sprite;
            if (sprite.loaded()) {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            } else {
                sprite.on(&#039;load&#039;, function() {
                    callback(null, { sprite: sprite.data, retina: sprite.retina });
                });
            }
        },

        &#039;get icons&#039;: function(params, callback) {
            var sprite = this.sprite;
            var spriteAtlas = this.spriteAtlas;
            if (sprite.loaded()) {
                spriteAtlas.setSprite(sprite);
                spriteAtlas.addIcons(params.icons, callback);
            } else {
                sprite.on(&#039;load&#039;, function() {
                    spriteAtlas.setSprite(sprite);
                    spriteAtlas.addIcons(params.icons, callback);
                });
            }
        },

        &#039;get glyphs&#039;: function(params, callback) {
            this.glyphSource.getSimpleGlyphs(params.fontstack, params.codepoints, params.uid, callback);
        }
    });

},{&quot;../render/line_atlas&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/line_atlas.js&quot;,&quot;../source/source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/source/source.js&quot;,&quot;../symbol/glyph_atlas&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/glyph_atlas.js&quot;,&quot;../symbol/glyph_source&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/glyph_source.js&quot;,&quot;../symbol/sprite_atlas&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/sprite_atlas.js&quot;,&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;../util/dispatcher&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dispatcher.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/mapbox&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mapbox.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./animation_loop&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/animation_loop.js&quot;,&quot;./image_sprite&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/image_sprite.js&quot;,&quot;./style_layer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_layer.js&quot;,&quot;mapbox-gl-style-spec/lib/validate/latest&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/lib/validate/latest.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_constant.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);

    exports.resolve = function(value, constants) {
        function resolve(value) {
            return typeof value === &#039;string&#039; &amp;&amp; value[0] === &#039;@&#039; ? constants[value] : value;
        }

        var i;

        value = resolve(value);

        if (Array.isArray(value)) {
            value = value.slice();

            for (i = 0; i &lt; value.length; i++) {
                if (value[i] in constants) {
                    value[i] = resolve(value[i]);
                }
            }
        }

        if (value.stops) {
            value = util.extend({}, value);
            value.stops = value.stops.slice();

            for (i = 0; i &lt; value.stops.length; i++) {
                if (value.stops[i][1] in constants) {
                    value.stops[i] = [
                        value.stops[i][0],
                        resolve(value.stops[i][1])
                    ];
                }
            }
        }

        return value;
    };

    exports.resolveAll = function (properties, constants) {
        if (!constants)
            return properties;

        var result = {};

        for (var key in properties) {
            result[key] = exports.resolve(properties[key], constants);
        }

        return result;
    };

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_declaration.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var parseCSSColor = require(&#039;csscolorparser&#039;).parseCSSColor;
    var mapboxGLFunction = require(&#039;mapbox-gl-function&#039;);
    var util = require(&#039;../util/util&#039;);

    module.exports = StyleDeclaration;

    function StyleDeclaration(reference, value) {
        this.type = reference.type;
        this.transitionable = reference.transition;

        // immutable representation of value. used for comparison
        this.json = JSON.stringify(value);

        if (this.type !== &#039;color&#039;) {
            this.value = value;
        } else if (value.stops) {
            this.value = prepareColorFunction(value);
        } else {
            this.value = parseColor(value);
        }

        if (reference.function === &#039;interpolated&#039;) {
            this.calculate = mapboxGLFunction.interpolated(this.value);
        } else {
            this.calculate = mapboxGLFunction[&#039;piecewise-constant&#039;](this.value);
            if (reference.transition) {
                this.calculate = transitioned(this.calculate);
            }
        }
    }

    function transitioned(calculate) {
        return function(z, zh, duration) {
            var fraction = z % 1;
            var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
            var fromScale = 1;
            var toScale = 1;
            var mix, from, to;

            if (z &gt; zh.lastIntegerZoom) {
                mix = fraction + (1 - fraction) * t;
                fromScale *= 2;
                from = calculate(z - 1);
                to = calculate(z);
            } else {
                mix = 1 - (1 - t) * fraction;
                to = calculate(z);
                from = calculate(z + 1);
                fromScale /= 2;
            }

            return {
                from: from,
                fromScale: fromScale,
                to: to,
                toScale: toScale,
                t: mix
            };
        };
    }

    var colorCache = {};

    function parseColor(value) {
        if (colorCache[value]) return colorCache[value];
        var color = prepareColor(parseCSSColor(value));
        colorCache[value] = color;
        return color;
    }

    function prepareColor(c) {
        return [c[0] / 255, c[1] / 255, c[2] / 255, c[3] / 1];
    }

    function prepareColorFunction(f) {
        return util.extend({}, f, {stops: f.stops.map(function(stop) {
            return [stop[0], parseColor(stop[1])];
        })});
    }

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;csscolorparser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/csscolorparser/csscolorparser.js&quot;,&quot;mapbox-gl-function&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-function/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_declaration_set.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var reference = require(&#039;./reference&#039;);
    var StyleConstant = require(&#039;./style_constant&#039;);
    var StyleDeclaration = require(&#039;./style_declaration&#039;);

    var lookup = {
        paint: {},
        layout: {}
    };

    reference.layer.type.values.forEach(function(type) {
        lookup.paint[type] = makeConstructor(reference[&#039;paint_&#039; + type]);
        lookup.layout[type] = makeConstructor(reference[&#039;layout_&#039; + type]);
    });

    function makeConstructor(reference) {
        function StyleDeclarationSet(properties, constants) {
            this._values = {};
            this._transitions = {};

            this._constants = constants;

            for (var k in properties) {
                this[k] = StyleConstant.resolve(properties[k], this._constants);
            }
        }

        Object.keys(reference).forEach(function(k) {
            var property = reference[k];

            Object.defineProperty(StyleDeclarationSet.prototype, k, {
                set: function(v) {
                    this._values[k] = new StyleDeclaration(property, StyleConstant.resolve(v, this._constants));
                },
                get: function() {
                    return this._values[k].value;
                }
            });

            if (property.transition) {
                Object.defineProperty(StyleDeclarationSet.prototype, k + &#039;-transition&#039;, {
                    set: function(v) {
                        this._transitions[k] = v;
                    },
                    get: function() {
                        return this._transitions[k];
                    }
                });
            }
        });

        StyleDeclarationSet.prototype.values = function() {
            return this._values;
        };

        StyleDeclarationSet.prototype.transition = function(k, global) {
            var t = this._transitions[k] || {};
            return {
                duration: util.coalesce(t.duration, global.duration, 300),
                delay: util.coalesce(t.delay, global.delay, 0)
            };
        };

        StyleDeclarationSet.prototype.json = function() {
            var result = {};

            for (var v in this._values) {
                result[v] = this._values[v].value;
            }

            for (var t in this._transitions) {
                result[t + &#039;-transition&#039;] = this._transitions[v];
            }

            return result;
        };

        return StyleDeclarationSet;
    }

    module.exports = function(renderType, layerType, properties, constants) {
        return new lookup[renderType][layerType](properties, constants);
    };

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./reference&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/reference.js&quot;,&quot;./style_constant&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_constant.js&quot;,&quot;./style_declaration&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_declaration.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_layer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var StyleConstant = require(&#039;./style_constant&#039;);
    var StyleTransition = require(&#039;./style_transition&#039;);
    var StyleDeclarationSet = require(&#039;./style_declaration_set&#039;);
    var LayoutProperties = require(&#039;./layout_properties&#039;);
    var PaintProperties = require(&#039;./paint_properties&#039;);

    module.exports = StyleLayer;

    function StyleLayer(layer, constants) {
        this._layer = layer;
        this._constants = constants;

        this.id = layer.id;
        this.ref = layer.ref;

        // Resolved and cascaded paint properties.
        this._resolved = {}; // class name -&gt; StyleDeclarationSet
        this._cascaded = {}; // property name -&gt; StyleTransition

        this.assign(layer);
    }

    StyleLayer.prototype = {
        resolveLayout: function() {
            if (!this.ref) {
                this.layout = new LayoutProperties[this.type](
                    StyleConstant.resolveAll(this._layer.layout, this._constants));

                if (this.layout[&#039;symbol-placement&#039;] === &#039;line&#039;) {
                    if (!this.layout.hasOwnProperty(&#039;text-rotation-alignment&#039;)) {
                        this.layout[&#039;text-rotation-alignment&#039;] = &#039;map&#039;;
                    }
                    if (!this.layout.hasOwnProperty(&#039;icon-rotation-alignment&#039;)) {
                        this.layout[&#039;icon-rotation-alignment&#039;] = &#039;map&#039;;
                    }
                    this.layout[&#039;symbol-avoid-edges&#039;] = true;
                }
            }
        },

        setLayoutProperty: function(name, value) {
            this.layout[name] = StyleConstant.resolve(value, this._constants);
        },

        getLayoutProperty: function(name) {
            return this.layout[name];
        },

        resolveReference: function(layers) {
            if (this.ref) {
                this.assign(layers[this.ref]);
            }
        },

        resolvePaint: function() {
            for (var p in this._layer) {
                var match = p.match(/^paint(?:\.(.*))?$/);
                if (!match)
                    continue;
                this._resolved[match[1] || &#039;&#039;] =
                    new StyleDeclarationSet(&#039;paint&#039;, this.type, this._layer[p], this._constants);
            }
        },

        setPaintProperty: function(name, value, klass) {
            var declarations = this._resolved[klass || &#039;&#039;];
            if (!declarations) {
                declarations = this._resolved[klass || &#039;&#039;] =
                    new StyleDeclarationSet(&#039;paint&#039;, this.type, {}, this._constants);
            }
            declarations[name] = value;
        },

        getPaintProperty: function(name, klass) {
            var declarations = this._resolved[klass || &#039;&#039;];
            if (!declarations)
                return undefined;
            return declarations[name];
        },

        cascade: function(classes, options, globalTrans, animationLoop) {
            for (var klass in this._resolved) {
                if (klass !== &quot;&quot; &amp;&amp; !classes[klass])
                    continue;

                var declarations = this._resolved[klass],
                    values = declarations.values();

                for (var k in values) {
                    var newDeclaration = values[k];
                    var oldTransition = options.transition ? this._cascaded[k] : undefined;

                    // Only create a new transition if the declaration changed
                    if (!oldTransition || oldTransition.declaration.json !== newDeclaration.json) {
                        var newStyleTrans = declarations.transition(k, globalTrans);
                        var newTransition = this._cascaded[k] =
                            new StyleTransition(newDeclaration, oldTransition, newStyleTrans);

                        // Run the animation loop until the end of the transition
                        if (!newTransition.instant()) {
                            newTransition.loopID = animationLoop.set(newTransition.endTime - (new Date()).getTime());
                        }

                        if (oldTransition) {
                            animationLoop.cancel(oldTransition.loopID);
                        }
                    }
                }
            }
        },

        recalculate: function(z, zoomHistory) {
            var type = this.type,
                calculated = this.paint = new PaintProperties[type]();

            for (var k in this._cascaded) {
                calculated[k] = this._cascaded[k].at(z, zoomHistory);
            }

            this.hidden = (this.minzoom &amp;&amp; z &lt; this.minzoom) ||
                (this.maxzoom &amp;&amp; z &gt;= this.maxzoom) ||
                // include visibility check for non-bucketed background layers
                (this.layout.visibility === &#039;none&#039;);

            if (type === &#039;symbol&#039;) {
                if ((calculated[&#039;text-opacity&#039;] === 0 || !this.layout[&#039;text-field&#039;]) &amp;&amp;
                    (calculated[&#039;icon-opacity&#039;] === 0 || !this.layout[&#039;icon-image&#039;])) {
                    this.hidden = true;
                } else {
                    premultiplyLayer(calculated, &#039;text&#039;);
                    premultiplyLayer(calculated, &#039;icon&#039;);
                }

            } else if (calculated[type + &#039;-opacity&#039;] === 0) {
                this.hidden = true;
            } else {
                premultiplyLayer(calculated, type);
            }

            if (this._cascaded[&#039;line-dasharray&#039;]) {
                // If the line is dashed, scale the dash lengths by the line
                // width at the previous round zoom level.
                var dashArray = calculated[&#039;line-dasharray&#039;];
                var lineWidth = this._cascaded[&#039;line-width&#039;] ?
                    this._cascaded[&#039;line-width&#039;].at(Math.floor(z), Infinity) :
                    calculated[&#039;line-width&#039;];

                dashArray.fromScale *= lineWidth;
                dashArray.toScale *= lineWidth;
            }

            return !this.hidden;
        },

        assign: function(layer) {
            util.extend(this, util.pick(layer,
                [&#039;type&#039;, &#039;source&#039;, &#039;source-layer&#039;,
                    &#039;minzoom&#039;, &#039;maxzoom&#039;, &#039;filter&#039;,
                    &#039;layout&#039;]));
        },

        json: function() {
            return util.extend({},
                this._layer,
                util.pick(this,
                    [&#039;type&#039;, &#039;source&#039;, &#039;source-layer&#039;,
                        &#039;minzoom&#039;, &#039;maxzoom&#039;, &#039;filter&#039;,
                        &#039;layout&#039;, &#039;paint&#039;]));
        }
    };

    function premultiplyLayer(layer, type) {
        var colorProp = type + &#039;-color&#039;,
            haloProp = type + &#039;-halo-color&#039;,
            outlineProp = type + &#039;-outline-color&#039;,
            color = layer[colorProp],
            haloColor = layer[haloProp],
            outlineColor = layer[outlineProp],
            opacity = layer[type + &#039;-opacity&#039;];

        var colorOpacity = color &amp;&amp; (opacity * color[3]);
        var haloOpacity = haloColor &amp;&amp; (opacity * haloColor[3]);
        var outlineOpacity = outlineColor &amp;&amp; (opacity * outlineColor[3]);

        if (colorOpacity !== undefined &amp;&amp; colorOpacity &lt; 1) {
            layer[colorProp] = util.premultiply([color[0], color[1], color[2], colorOpacity]);
        }
        if (haloOpacity !== undefined &amp;&amp; haloOpacity &lt; 1) {
            layer[haloProp] = util.premultiply([haloColor[0], haloColor[1], haloColor[2], haloOpacity]);
        }
        if (outlineOpacity !== undefined &amp;&amp; outlineOpacity &lt; 1) {
            layer[outlineProp] = util.premultiply([outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity]);
        }
    }

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./layout_properties&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/layout_properties.js&quot;,&quot;./paint_properties&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/paint_properties.js&quot;,&quot;./style_constant&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_constant.js&quot;,&quot;./style_declaration_set&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_declaration_set.js&quot;,&quot;./style_transition&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_transition.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style_transition.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var interpolate = require(&#039;../util/interpolate&#039;);

    module.exports = StyleTransition;

    /*
     * Represents a transition between two declarations
     */
    function StyleTransition(declaration, oldTransition, value) {

        this.declaration = declaration;
        this.startTime = this.endTime = (new Date()).getTime();

        var type = declaration.type;
        if ((type === &#039;string&#039; || type === &#039;array&#039;) &amp;&amp; declaration.transitionable) {
            this.interp = interpZoomTransitioned;
        } else {
            this.interp = interpolate[type];
        }

        this.oldTransition = oldTransition;
        this.duration = value.duration || 0;
        this.delay = value.delay || 0;

        if (!this.instant()) {
            this.endTime = this.startTime + this.duration + this.delay;
            this.ease = util.easeCubicInOut;
        }

        if (oldTransition &amp;&amp; oldTransition.endTime &lt;= this.startTime) {
            // Old transition is done running, so we can
            // delete its reference to its old transition.

            delete oldTransition.oldTransition;
        }
    }

    StyleTransition.prototype.instant = function() {
        return !this.oldTransition || !this.interp || (this.duration === 0 &amp;&amp; this.delay === 0);
    };

    /*
     * Return the value of the transitioning property at zoom level `z` and optional time `t`
     */
    StyleTransition.prototype.at = function(z, zoomHistory, t) {

        var value = this.declaration.calculate(z, zoomHistory, this.duration);

        if (this.instant()) return value;

        t = t || Date.now();

        if (t &lt; this.endTime) {
            var oldValue = this.oldTransition.at(z, zoomHistory, this.startTime);
            var eased = this.ease((t - this.startTime - this.delay) / this.duration);
            value = this.interp(oldValue, value, eased);
        }

        return value;

    };

    function interpZoomTransitioned(from, to, t) {
        return {
            from: from.to,
            fromScale: from.toScale,
            to: to.to,
            toScale: to.toScale,
            t: t
        };
    }

},{&quot;../util/interpolate&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/interpolate.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/anchor.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Point = require(&#039;point-geometry&#039;);

    module.exports = Anchor;

    function Anchor(x, y, angle, segment) {
        this.x = x;
        this.y = y;
        this.angle = angle;

        if (segment !== undefined) {
            this.segment = segment;
        }
    }

    Anchor.prototype = Object.create(Point.prototype);

    Anchor.prototype.clone = function() {
        return new Anchor(this.x, this.y, this.angle, this.segment);
    };

},{&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/bin_pack.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = BinPack;
    function BinPack(width, height) {
        this.width = width;
        this.height = height;
        this.free = [{ x: 0, y: 0, w: width, h: height }];
    }

    /**
     * Simple algorithm to recursively merge the newly released cell with its
     * neighbor. This doesn&#039;t merge more than two cells at a time, and fails
     * for complicated merges.
     * @private
     */
    BinPack.prototype.release = function(rect) {
        for (var i = 0; i &lt; this.free.length; i++) {
            var free = this.free[i];

            if (free.y === rect.y &amp;&amp; free.h === rect.h &amp;&amp; free.x + free.w === rect.x) {
                free.w += rect.w;

            } else if (free.x === rect.x &amp;&amp; free.w === rect.w &amp;&amp; free.y + free.h === rect.y) {
                free.h += rect.h;

            } else if (rect.y === free.y &amp;&amp; rect.h === free.h &amp;&amp; rect.x + rect.w === free.x) {
                free.x = rect.x;
                free.w += rect.w;

            } else if (rect.x === free.x &amp;&amp; rect.w === free.w &amp;&amp; rect.y + rect.h === free.y) {
                free.y = rect.y;
                free.h += rect.h;

            } else continue;

            this.free.splice(i, 1);
            this.release(free);
            return;

        }
        this.free.push(rect);
    };

    BinPack.prototype.allocate = function(width, height) {
        // Find the smallest free rect angle
        var rect = { x: Infinity, y: Infinity, w: Infinity, h: Infinity };
        var smallest = -1;
        for (var i = 0; i &lt; this.free.length; i++) {
            var ref = this.free[i];
            if (width &lt;= ref.w &amp;&amp; height &lt;= ref.h &amp;&amp; ref.y &lt;= rect.y &amp;&amp; ref.x &lt;= rect.x) {
                rect = ref;
                smallest = i;
            }
        }

        if (smallest &lt; 0) {
            // There&#039;s no space left for this char.
            return { x: -1, y: -1 };
        }

        this.free.splice(smallest, 1);

        // Shorter/Longer Axis Split Rule (SAS)
        // http://clb.demon.fi/files/RectangleBinPack.pdf p. 15
        // Ignore the dimension of R and just split long the shorter dimension
        // See Also: http://www.cs.princeton.edu/~chazelle/pubs/blbinpacking.pdf
        if (rect.w &lt; rect.h) {
            // split horizontally
            // +--+---+
            // |__|___|  &lt;-- b1
            // +------+  &lt;-- b2
            if (rect.w &gt; width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: height });
            if (rect.h &gt; height) this.free.push({ x: rect.x, y: rect.y + height, w: rect.w, h: rect.h - height });
        } else {
            // split vertically
            // +--+---+
            // |__|   | &lt;-- b1
            // +--|---+ &lt;-- b2
            if (rect.w &gt; width) this.free.push({ x: rect.x + width, y: rect.y, w: rect.w - width, h: rect.h });
            if (rect.h &gt; height) this.free.push({ x: rect.x, y: rect.y + height, w: width, h: rect.h - height });
        }

        return { x: rect.x, y: rect.y, w: width, h: height };
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/check_max_angle.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = checkMaxAngle;

    function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {

        // horizontal labels always pass
        if (anchor.segment === undefined) return true;

        var p = anchor;
        var index = anchor.segment + 1;
        var anchorDistance = 0;

        // move backwards along the line to the first segment the label appears on
        while (anchorDistance &gt; -labelLength / 2) {
            index--;

            // there isn&#039;t enough room for the label after the beginning of the line
            if (index &lt; 0) return false;

            anchorDistance -= line[index].dist(p);
            p = line[index];
        }

        anchorDistance += line[index].dist(line[index + 1]);
        index++;

        // store recent corners and their total angle difference
        var recentCorners = [];
        var recentAngleDelta = 0;

        // move forwards by the length of the label and check angles along the way
        while (anchorDistance &lt; labelLength / 2) {
            var prev = line[index - 1];
            var current = line[index];
            var next = line[index + 1];

            // there isn&#039;t enough room for the label before the end of the line
            if (!next) return false;

            var angleDelta = prev.angleTo(current) - current.angleTo(next);
            // restrict angle to -pi..pi range
            angleDelta = ((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI;

            recentCorners.push({
                distance: anchorDistance,
                angleDelta: angleDelta
            });
            recentAngleDelta += angleDelta;

            // remove corners that are far enough away from the list of recent anchors
            while (anchorDistance - recentCorners[0].distance &gt; windowSize) {
                recentAngleDelta -= recentCorners.shift().angleDelta;
            }

            // the sum of angles within the window area exceeds the maximum allowed value. check fails.
            if (Math.abs(recentAngleDelta) &gt; maxAngle) return false;

            index++;
            anchorDistance += current.dist(next);
        }

        // no part of the line had an angle greater than the maximum allowed. check passes.
        return true;
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/clip_line.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Point = require(&#039;point-geometry&#039;);

    module.exports = clipLine;

    function clipLine(lines, x1, y1, x2, y2) {
        var clippedLines = [];

        for (var l = 0; l &lt; lines.length; l++) {
            var line = lines[l];
            var clippedLine;

            for (var i = 0; i &lt; line.length - 1; i++) {
                var p0 = line[i];
                var p1 = line[i + 1];


                if (p0.x &lt; x1 &amp;&amp; p1.x &lt; x1) {
                    continue;
                } else if (p0.x &lt; x1) {
                    p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)));
                } else if (p1.x &lt; x1) {
                    p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)));
                }

                if (p0.y &lt; y1 &amp;&amp; p1.y &lt; y1) {
                    continue;
                } else if (p0.y &lt; y1) {
                    p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1);
                } else if (p1.y &lt; y1) {
                    p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1);
                }

                if (p0.x &gt;= x2 &amp;&amp; p1.x &gt;= x2) {
                    continue;
                } else if (p0.x &gt;= x2) {
                    p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)));
                } else if (p1.x &gt;= x2) {
                    p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)));
                }

                if (p0.y &gt;= y2 &amp;&amp; p1.y &gt;= y2) {
                    continue;
                } else if (p0.y &gt;= y2) {
                    p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2);
                } else if (p1.y &gt;= y2) {
                    p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2);
                }

                if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
                    clippedLine = [p0];
                    clippedLines.push(clippedLine);
                }

                clippedLine.push(p1);
            }
        }

        return clippedLines;
    }

},{&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/collision_box.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = CollisionBox;

    function CollisionBox(anchor, x1, y1, x2, y2, maxScale) {
        // the box is centered around the anchor point
        this.anchor = anchor;

        // distances to the edges from the anchor
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;

        // the box is only valid for scales &lt; maxScale.
        // The box does not block other boxes at scales &gt;= maxScale;
        this.maxScale = maxScale;

        // the scale at which the label can first be shown
        this.placementScale = 0;

        // rotated and scaled bbox used for indexing
        this[0] = this[1] = this[2] = this[3] = 0;
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/collision_feature.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var CollisionBox = require(&#039;./collision_box&#039;);

    module.exports = CollisionFeature;

    function CollisionFeature(line, anchor, shaped, boxScale, padding, alignLine) {

        var y1 = shaped.top * boxScale - padding;
        var y2 = shaped.bottom * boxScale + padding;
        var x1 = shaped.left * boxScale - padding;
        var x2 = shaped.right * boxScale + padding;

        this.boxes = [];

        if (alignLine) {

            var height = y2 - y1;
            var length = x2 - x1;

            if (height &lt;= 0) return;

            // set minimum box height to avoid very many small labels
            height = Math.max(10 * boxScale, height);

            this.bboxifyLabel(line, anchor, length, height);

        } else {
            this.boxes.push(new CollisionBox(anchor, x1, y1, x2, y2, Infinity));
        }
    }

    CollisionFeature.prototype.bboxifyLabel = function(line, anchor, labelLength, boxSize) {
        var step = boxSize / 2;
        var nBoxes = Math.floor(labelLength / step);

        // offset the center of the first box by half a box so that the edge of the
        // box is at the edge of the label.
        var firstBoxOffset = -boxSize / 2;

        var bboxes = this.boxes;

        var p = anchor;
        var index = anchor.segment + 1;
        var anchorDistance = firstBoxOffset;

        // move backwards along the line to the first segment the label appears on
        do {
            index--;

            // there isn&#039;t enough room for the label after the beginning of the line
            // checkMaxAngle should have already caught this
            if (index &lt; 0) return bboxes;

            anchorDistance -= line[index].dist(p);
            p = line[index];
        } while (anchorDistance &gt; -labelLength / 2);

        var segmentLength = line[index].dist(line[index + 1]);

        for (var i = 0; i &lt; nBoxes; i++) {
            // the distance the box will be from the anchor
            var boxDistanceToAnchor = -labelLength / 2 + i * step;

            // the box is not on the current segment. Move to the next segment.
            while (anchorDistance + segmentLength &lt; boxDistanceToAnchor) {
                anchorDistance += segmentLength;
                index++;

                // There isn&#039;t enough room before the end of the line.
                if (index + 1 &gt;= line.length) return bboxes;

                segmentLength = line[index].dist(line[index + 1]);
            }

            // the distance the box will be from the beginning of the segment
            var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;

            var p0 = line[index];
            var p1 = line[index + 1];
            var boxAnchor = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0);

            var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
            var maxScale = labelLength / 2 / distanceToInnerEdge;

            bboxes.push(new CollisionBox(boxAnchor, -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale));
        }

        return bboxes;
    };

},{&quot;./collision_box&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/collision_box.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/collision_tile.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var rbush = require(&#039;rbush&#039;);

    module.exports = CollisionTile;

    function CollisionTile(zoom, tileExtent, tileSize) {
        this.zoom = zoom;
        this.tilePixelRatio = tileExtent / tileSize;
    }

    CollisionTile.prototype.minScale = 0.25;
    CollisionTile.prototype.maxScale = 2;

    CollisionTile.prototype.reset = function(angle, pitch) {
        this.tree = rbush();
        this.angle = angle;

        var sin = Math.sin(angle),
            cos = Math.cos(angle);
        this.rotationMatrix = [cos, -sin, sin, cos];

        // Stretch boxes in y direction to account for the map tilt.
        this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);

        // The amount the map is squished depends on the y position.
        // Sort of account for this by making all boxes a bit bigger.
        this.yStretch = Math.pow(this.yStretch, 1.3);
    };

    CollisionTile.prototype.placeFeature = function(feature) {

        var minPlacementScale = this.minScale;
        var rotationMatrix = this.rotationMatrix;
        var yStretch = this.yStretch;

        for (var b = 0; b &lt; feature.boxes.length; b++) {

            var box = feature.boxes[b];

            var anchor = box.anchor.matMult(rotationMatrix);
            var x = anchor.x;
            var y = anchor.y;

            box[0] = x + box.x1;
            box[1] = y + box.y1 * yStretch;
            box[2] = x + box.x2;
            box[3] = y + box.y2 * yStretch;

            var blockingBoxes = this.tree.search(box);

            for (var i = 0; i &lt; blockingBoxes.length; i++) {
                var blocking = blockingBoxes[i];
                var blockingAnchor = blocking.anchor.matMult(rotationMatrix);

                // Find the lowest scale at which the two boxes can fit side by side without overlapping.
                // Original algorithm:
                var s1 = (blocking.x1 - box.x2) / (x - blockingAnchor.x); // scale at which new box is to the left of old box
                var s2 = (blocking.x2 - box.x1) / (x - blockingAnchor.x); // scale at which new box is to the right of old box
                var s3 = (blocking.y1 - box.y2) * yStretch / (y - blockingAnchor.y); // scale at which new box is to the top of old box
                var s4 = (blocking.y2 - box.y1) * yStretch / (y - blockingAnchor.y); // scale at which new box is to the bottom of old box

                if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
                if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

                var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));

                if (collisionFreeScale &gt; blocking.maxScale) {
                    // After a box&#039;s maxScale the label has shrunk enough that the box is no longer needed to cover it,
                    // so unblock the new box at the scale that the old box disappears.
                    collisionFreeScale = blocking.maxScale;
                }

                if (collisionFreeScale &gt; box.maxScale) {
                    // If the box can only be shown after it is visible, then the box can never be shown.
                    // But the label can be shown after this box is not visible.
                    collisionFreeScale = box.maxScale;
                }

                if (collisionFreeScale &gt; minPlacementScale &amp;&amp;
                    collisionFreeScale &gt;= blocking.placementScale) {
                    // If this collision occurs at a lower scale than previously found collisions
                    // and the collision occurs while the other label is visible

                    // this this is the lowest scale at which the label won&#039;t collide with anything
                    minPlacementScale = collisionFreeScale;
                }

                if (minPlacementScale &gt;= this.maxScale) return minPlacementScale;
            }
        }

        return minPlacementScale;
    };

    CollisionTile.prototype.insertFeature = function(feature, minPlacementScale) {

        var boxes = feature.boxes;
        for (var k = 0; k &lt; boxes.length; k++) {
            boxes[k].placementScale = minPlacementScale;
        }

        if (minPlacementScale &lt; this.maxScale) {
            this.tree.load(boxes);
        }
    };

},{&quot;rbush&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/rbush/rbush.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/get_anchors.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var interpolate = require(&#039;../util/interpolate&#039;);
    var Anchor = require(&#039;../symbol/anchor&#039;);
    var checkMaxAngle = require(&#039;./check_max_angle&#039;);

    module.exports = getAnchors;

    function getAnchors(line, spacing, maxAngle, shapedText, glyphSize, boxScale, overscaling) {

        // Resample a line to get anchor points for labels and check that each
        // potential label passes text-max-angle check and has enough froom to fit
        // on the line.

        var angleWindowSize = shapedText ?
            3 / 5 * glyphSize * boxScale :
            0;

        // Offset the first anchor by half the label length (or half the spacing distance for icons).
        // Add a bit of extra offset to avoid collisions at T intersections.
        var labelLength = shapedText ? shapedText.right - shapedText.left : spacing;
        var extraOffset = glyphSize * 2;
        var offset = ((labelLength / 2 + extraOffset) * boxScale * overscaling) % spacing;

        return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, false);
    }


    function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, placeAtMiddle) {

        var distance = 0,
            markedDistance = offset ? offset - spacing : 0;

        var anchors = [];

        for (var i = 0; i &lt; line.length - 1; i++) {

            var a = line[i],
                b = line[i + 1];

            var segmentDist = a.dist(b),
                angle = b.angleTo(a);

            while (markedDistance + spacing &lt; distance + segmentDist) {
                markedDistance += spacing;

                var t = (markedDistance - distance) / segmentDist,
                    x = interpolate(a.x, b.x, t),
                    y = interpolate(a.y, b.y, t);

                if (x &gt;= 0 &amp;&amp; x &lt; 4096 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 4096) {
                    var anchor = new Anchor(x, y, angle, i);

                    if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
                        anchors.push(anchor);
                    }
                }
            }

            distance += segmentDist;
        }

        if (!placeAtMiddle &amp;&amp; !anchors.length) {
            // The first attempt at finding anchors at which labels can be placed failed.
            // Try again, but this time just try placing one anchor at the middle of the line.
            // This has the most effect for short lines in overscaled tiles, since the
            // initial offset used in overscaled tiles is calculated to align labels with positions in
            // parent tiles instead of placing the label as close to the beginning as possible.
            anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, true);
        }

        return anchors;
    }

},{&quot;../symbol/anchor&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/anchor.js&quot;,&quot;../util/interpolate&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/interpolate.js&quot;,&quot;./check_max_angle&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/check_max_angle.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/glyph_atlas.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var BinPack = require(&#039;./bin_pack&#039;);

    module.exports = GlyphAtlas;
    function GlyphAtlas(width, height) {
        this.width = width;
        this.height = height;

        this.bin = new BinPack(width, height);
        this.index = {};
        this.ids = {};
        this.data = new Uint8Array(width * height);
    }

    GlyphAtlas.prototype = {
        get debug() {
            return &#039;canvas&#039; in this;
        },
        set debug(value) {
            if (value &amp;&amp; !this.canvas) {
                this.canvas = document.createElement(&#039;canvas&#039;);
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                document.body.appendChild(this.canvas);
                this.ctx = this.canvas.getContext(&#039;2d&#039;);
            } else if (!value &amp;&amp; this.canvas) {
                this.canvas.parentNode.removeChild(this.canvas);
                delete this.ctx;
                delete this.canvas;
            }
        }
    };

    GlyphAtlas.prototype.getGlyphs = function() {
        var glyphs = {},
            split,
            name,
            id;

        for (var key in this.ids) {
            split = key.split(&#039;#&#039;);
            name = split[0];
            id = split[1];

            if (!glyphs[name]) glyphs[name] = [];
            glyphs[name].push(id);
        }

        return glyphs;
    };

    GlyphAtlas.prototype.getRects = function() {
        var rects = {},
            split,
            name,
            id;

        for (var key in this.ids) {
            split = key.split(&#039;#&#039;);
            name = split[0];
            id = split[1];

            if (!rects[name]) rects[name] = {};
            rects[name][id] = this.index[key];
        }

        return rects;
    };

    GlyphAtlas.prototype.removeGlyphs = function(id) {
        for (var key in this.ids) {

            var ids = this.ids[key];

            var pos = ids.indexOf(id);
            if (pos &gt;= 0) ids.splice(pos, 1);
            this.ids[key] = ids;

            if (!ids.length) {
                var rect = this.index[key];

                var target = this.data;
                for (var y = 0; y &lt; rect.h; y++) {
                    var y1 = this.width * (rect.y + y) + rect.x;
                    for (var x = 0; x &lt; rect.w; x++) {
                        target[y1 + x] = 0;
                    }
                }

                this.dirty = true;

                this.bin.release(rect);

                delete this.index[key];
                delete this.ids[key];
            }
        }


        this.updateTexture(this.gl);
    };

    GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
        if (!glyph) {
            // console.warn(&#039;missing glyph&#039;, code, String.fromCharCode(code));
            return null;
        }
        var key = name + &quot;#&quot; + glyph.id;

        // The glyph is already in this texture.
        if (this.index[key]) {
            if (this.ids[key].indexOf(id) &lt; 0) {
                this.ids[key].push(id);
            }
            return this.index[key];
        }

        // The glyph bitmap has zero width.
        if (!glyph.bitmap) {
            return null;
        }

        var bufferedWidth = glyph.width + buffer * 2;
        var bufferedHeight = glyph.height + buffer * 2;

        // Add a 1px border around every image.
        var packWidth = bufferedWidth;
        var packHeight = bufferedHeight;

        // Increase to next number divisible by 4, but at least 1.
        // This is so we can scale down the texture coordinates and pack them
        // into 2 bytes rather than 4 bytes.
        packWidth += (4 - packWidth % 4);
        packHeight += (4 - packHeight % 4);

        var rect = this.bin.allocate(packWidth, packHeight);
        if (rect.x &lt; 0) {
            console.warn(&#039;glyph bitmap overflow&#039;);
            return { glyph: glyph, rect: null };
        }

        this.index[key] = rect;
        this.ids[key] = [id];

        var target = this.data;
        var source = glyph.bitmap;
        for (var y = 0; y &lt; bufferedHeight; y++) {
            var y1 = this.width * (rect.y + y) + rect.x;
            var y2 = bufferedWidth * y;
            for (var x = 0; x &lt; bufferedWidth; x++) {
                target[y1 + x] = source[y2 + x];
            }
        }

        this.dirty = true;

        return rect;
    };

    GlyphAtlas.prototype.bind = function(gl) {
        this.gl = gl;
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }
    };

    GlyphAtlas.prototype.updateTexture = function(gl) {
        this.bind(gl);
        if (this.dirty) {

            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);

            // DEBUG
            if (this.ctx) {
                var data = this.ctx.getImageData(0, 0, this.width, this.height);
                for (var i = 0, j = 0; i &lt; this.data.length; i++, j += 4) {
                    data.data[j] = this.data[i];
                    data.data[j + 1] = this.data[i];
                    data.data[j + 2] = this.data[i];
                    data.data[j + 3] = 255;
                }
                this.ctx.putImageData(data, 0, 0);

                this.ctx.strokeStyle = &#039;red&#039;;
                for (var k = 0; k &lt; this.bin.free.length; k++) {
                    var free = this.bin.free[k];
                    this.ctx.strokeRect(free.x, free.y, free.w, free.h);
                }
            }
            // END DEBUG

            this.dirty = false;
        }
    };

},{&quot;./bin_pack&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/bin_pack.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/glyph_source.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var normalizeURL = require(&#039;../util/mapbox&#039;).normalizeGlyphsURL;
    var getArrayBuffer = require(&#039;../util/ajax&#039;).getArrayBuffer;
    var Glyphs = require(&#039;../util/glyphs&#039;);
    var Protobuf = require(&#039;pbf&#039;);

    module.exports = GlyphSource;

    function GlyphSource(url, glyphAtlas) {
        this.url = url &amp;&amp; normalizeURL(url);
        this.glyphAtlas = glyphAtlas;
        this.stacks = [];
        this.loading = {};
    }

    GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {

        if (this.stacks[fontstack] === undefined) this.stacks[fontstack] = {};

        var glyphs = {};

        var stack = this.stacks[fontstack];
        var glyphAtlas = this.glyphAtlas;

        // the number of pixels the sdf bitmaps are padded by
        var buffer = 3;

        var missing = {};
        var remaining = 0;
        var range;

        for (var i = 0; i &lt; glyphIDs.length; i++) {
            var glyphID = glyphIDs[i];
            range = Math.floor(glyphID / 256);

            if (stack[range]) {
                var glyph = stack[range].glyphs[glyphID];
                var rect  = glyphAtlas.addGlyph(uid, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
            } else {
                if (missing[range] === undefined) {
                    missing[range] = [];
                    remaining++;
                }
                missing[range].push(glyphID);
            }
        }

        if (!remaining) callback(undefined, glyphs);

        var onRangeLoaded = function(err, range, data) {
            // TODO not be silent about errors
            if (!err) {
                var stack = this.stacks[fontstack][range] = data.stacks[0];
                for (var i = 0; i &lt; missing[range].length; i++) {
                    var glyphID = missing[range][i];
                    var glyph = stack.glyphs[glyphID];
                    var rect  = glyphAtlas.addGlyph(uid, fontstack, glyph, buffer);
                    if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
                }
            }
            remaining--;
            if (!remaining) callback(undefined, glyphs);
        }.bind(this);

        for (var r in missing) {
            this.loadRange(fontstack, r, onRangeLoaded);
        }
    };

// A simplified representation of the glyph containing only the properties needed for shaping.
    function SimpleGlyph(glyph, rect, buffer) {
        this.advance = glyph.advance;
        this.left = glyph.left - buffer;
        this.top = glyph.top + buffer;
        this.rect = rect;
    }

    GlyphSource.prototype.loadRange = function(fontstack, range, callback) {

        if (range * 256 &gt; 65535) return callback(&#039;gyphs &gt; 65535 not supported&#039;);

        if (this.loading[fontstack] === undefined) this.loading[fontstack] = {};
        var loading = this.loading[fontstack];

        if (loading[range]) {
            loading[range].push(callback);
        } else {
            loading[range] = [callback];

            var rangeName = (range * 256) + &#039;-&#039; + (range * 256 + 255);
            var url = glyphUrl(fontstack, rangeName, this.url);

            getArrayBuffer(url, function(err, data) {
                var glyphs = !err &amp;&amp; new Glyphs(new Protobuf(new Uint8Array(data)));
                for (var i = 0; i &lt; loading[range].length; i++) {
                    loading[range][i](err, range, glyphs);
                }
                delete loading[range];
            });
        }
    };

    function glyphUrl(fontstack, range, url, subdomains) {
        subdomains = subdomains || &#039;abc&#039;;

        return url
            .replace(&#039;{s}&#039;, subdomains[fontstack.length % subdomains.length])
            .replace(&#039;{fontstack}&#039;, fontstack)
            .replace(&#039;{range}&#039;, range);
    }

},{&quot;../util/ajax&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;,&quot;../util/glyphs&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/glyphs.js&quot;,&quot;../util/mapbox&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mapbox.js&quot;,&quot;pbf&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/mergelines.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = function (features, textFeatures, geometries) {

        var leftIndex = {},
            rightIndex = {},
            mergedFeatures = [],
            mergedGeom = [],
            mergedTexts = [],
            mergedIndex = 0,
            k;

        function add(k) {
            mergedFeatures.push(features[k]);
            mergedGeom.push(geometries[k]);
            mergedTexts.push(textFeatures[k]);
            mergedIndex++;
        }

        function mergeFromRight(leftKey, rightKey, geom) {
            var i = rightIndex[leftKey];
            delete rightIndex[leftKey];
            rightIndex[rightKey] = i;

            mergedGeom[i][0].pop();
            mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
            return i;
        }

        function mergeFromLeft(leftKey, rightKey, geom) {
            var i = leftIndex[rightKey];
            delete leftIndex[rightKey];
            leftIndex[leftKey] = i;

            mergedGeom[i][0].shift();
            mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
            return i;
        }

        function getKey(text, geom, onRight) {
            var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
            return text + &#039;:&#039; + point.x + &#039;:&#039; + point.y;
        }

        for (k = 0; k &lt; features.length; k++) {
            var geom = geometries[k],
                text = textFeatures[k];

            if (!text) {
                add(k);
                continue;
            }

            var leftKey = getKey(text, geom),
                rightKey = getKey(text, geom, true);

            if ((leftKey in rightIndex) &amp;&amp; (rightKey in leftIndex) &amp;&amp; (rightIndex[leftKey] !== leftIndex[rightKey])) {
                // found lines with the same text adjacent to both ends of the current line, merge all three
                var j = mergeFromLeft(leftKey, rightKey, geom);
                var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);

                delete leftIndex[leftKey];
                delete rightIndex[rightKey];

                rightIndex[getKey(text, mergedGeom[i], true)] = i;
                mergedGeom[j] = null;

            } else if (leftKey in rightIndex) {
                // found mergeable line adjacent to the start of the current line, merge
                mergeFromRight(leftKey, rightKey, geom);

            } else if (rightKey in leftIndex) {
                // found mergeable line adjacent to the end of the current line, merge
                mergeFromLeft(leftKey, rightKey, geom);

            } else {
                // no adjacent lines, add as a new item
                add(k);
                leftIndex[leftKey] = mergedIndex - 1;
                rightIndex[rightKey] = mergedIndex - 1;
            }
        }

        return {
            features: mergedFeatures,
            textFeatures: mergedTexts,
            geometries: mergedGeom
        };
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/quads.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Point = require(&#039;point-geometry&#039;);
    var Anchor = require(&#039;../symbol/anchor&#039;);

    module.exports = {
        getIconQuads: getIconQuads,
        getGlyphQuads: getGlyphQuads
    };

    var minScale = 0.5; // underscale by 1 zoom level

    function SymbolQuad(anchor, tl, tr, bl, br, tex, angle, minScale, maxScale) {
        this.anchor = anchor;
        this.tl = tl;
        this.tr = tr;
        this.bl = bl;
        this.br = br;
        this.tex = tex;
        this.angle = angle;
        this.minScale = minScale;
        this.maxScale = maxScale;
    }

    function getIconQuads(anchor, shapedIcon, boxScale, line, layout, alongLine) {

        var tl = new Point(shapedIcon.left, shapedIcon.top);
        var tr = new Point(shapedIcon.right, shapedIcon.top);
        var br = new Point(shapedIcon.right, shapedIcon.bottom);
        var bl = new Point(shapedIcon.left, shapedIcon.bottom);

        var angle = layout[&#039;icon-rotate&#039;] * Math.PI / 180;
        if (alongLine) {
            var prev = line[anchor.segment];
            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
        }

        if (angle) {
            var sin = Math.sin(angle),
                cos = Math.cos(angle),
                matrix = [cos, -sin, sin, cos];

            tl = tl.matMult(matrix);
            tr = tr.matMult(matrix);
            bl = bl.matMult(matrix);
            br = br.matMult(matrix);
        }

        return [new SymbolQuad(anchor, tl, tr, bl, br, shapedIcon.image.rect, 0, minScale, Infinity)];
    }

    function getGlyphQuads(anchor, shaping, boxScale, line, layout, alongLine) {

        var textRotate = layout[&#039;text-rotate&#039;] * Math.PI / 180;
        var keepUpright = layout[&#039;text-keep-upright&#039;];

        var positionedGlyphs = shaping.positionedGlyphs;
        var quads = [];

        for (var k = 0; k &lt; positionedGlyphs.length; k++) {
            var positionedGlyph = positionedGlyphs[k];
            var glyph = positionedGlyph.glyph;
            var rect = glyph.rect;

            if (!rect) continue;

            var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;

            var glyphInstances;
            var labelMinScale = minScale;
            if (alongLine) {
                glyphInstances = [];
                labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, 1);
                if (keepUpright) {
                    labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, -1));
                }

            } else {
                glyphInstances = [{
                    anchor: anchor,
                    offset: 0,
                    angle: 0,
                    maxScale: Infinity,
                    minScale: minScale
                }];
            }

            var x1 = positionedGlyph.x + glyph.left,
                y1 = positionedGlyph.y - glyph.top,
                x2 = x1 + rect.w,
                y2 = y1 + rect.h,

                otl = new Point(x1, y1),
                otr = new Point(x2, y1),
                obl = new Point(x1, y2),
                obr = new Point(x2, y2);

            for (var i = 0; i &lt; glyphInstances.length; i++) {

                var instance = glyphInstances[i],
                    tl = otl,
                    tr = otr,
                    bl = obl,
                    br = obr,
                    angle = instance.angle + textRotate;

                if (angle) {
                    var sin = Math.sin(angle),
                        cos = Math.cos(angle),
                        matrix = [cos, -sin, sin, cos];

                    tl = tl.matMult(matrix);
                    tr = tr.matMult(matrix);
                    bl = bl.matMult(matrix);
                    br = br.matMult(matrix);
                }

                // Prevent label from extending past the end of the line
                var glyphMinScale = Math.max(instance.minScale, labelMinScale);

                var glyphAngle = (anchor.angle + textRotate + instance.offset + 2 * Math.PI) % (2 * Math.PI);
                quads.push(new SymbolQuad(instance.anchor, tl, tr, bl, br, rect, glyphAngle, glyphMinScale, instance.maxScale));

            }
        }

        return quads;
    }

    function getSegmentGlyphs(glyphs, anchor, offset, line, segment, direction) {
        var upsideDown = direction &lt; 0;

        if (offset &lt; 0) direction *= -1;

        if (direction &gt; 0) segment++;

        var newAnchor = anchor;
        var end = line[segment];
        var prevScale = Infinity;

        offset = Math.abs(offset);

        var placementScale = minScale;

        while (true) {
            var distance = newAnchor.dist(end);
            var scale = offset / distance;

            // Get the angle of the line segment
            var angle = Math.atan2(end.y - newAnchor.y, end.x - newAnchor.x);
            if (direction &lt; 0) angle += Math.PI;
            if (upsideDown) angle += Math.PI;

            glyphs.push({
                anchor: new Anchor(newAnchor.x, newAnchor.y, anchor.angle),
                offset: upsideDown ? Math.PI : 0,
                minScale: scale,
                maxScale: prevScale,
                angle: (angle + 2 * Math.PI) % (2 * Math.PI)
            });

            if (scale &lt;= placementScale) break;

            newAnchor = end;

            // skip duplicate nodes
            while (newAnchor.equals(end)) {
                segment += direction;
                end = line[segment];
                if (!end) {
                    return scale;
                }
            }

            var unit = end.sub(newAnchor)._unit();
            newAnchor = newAnchor.sub(unit._mult(distance));

            prevScale = scale;
        }

        return placementScale;
    }

},{&quot;../symbol/anchor&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/anchor.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/resolve_icons.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var resolveTokens = require(&#039;../util/token&#039;);

    module.exports = resolveIcons;

// For an array of features determine what icons need to be loaded.
    function resolveIcons(features, layoutProperties) {
        var icons = [];

        for (var i = 0, fl = features.length; i &lt; fl; i++) {
            var text = resolveTokens(features[i].properties, layoutProperties[&#039;icon-image&#039;]);
            if (!text) continue;

            if (icons.indexOf(text) &lt; 0) {
                icons.push(text);
            }
        }

        return icons;
    }

},{&quot;../util/token&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/token.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/resolve_text.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var resolveTokens = require(&#039;../util/token&#039;);

    module.exports = resolveText;

    /**
     * For an array of features determine what glyph ranges need to be loaded
     * and apply any text preprocessing. The remaining users of text should
     * use the `textFeatures` key returned by this function rather than accessing
     * feature text directly.
     * @private
     */
    function resolveText(features, layoutProperties, glyphs) {
        var textFeatures = [];
        var codepoints = [];

        for (var i = 0, fl = features.length; i &lt; fl; i++) {
            var text = resolveTokens(features[i].properties, layoutProperties[&#039;text-field&#039;]);
            if (!text) {
                textFeatures[i] = null;
                continue;
            }
            text = text.toString();

            var transform = layoutProperties[&#039;text-transform&#039;];
            if (transform === &#039;uppercase&#039;) {
                text = text.toLocaleUpperCase();
            } else if (transform === &#039;lowercase&#039;) {
                text = text.toLocaleLowerCase();
            }

            for (var j = 0, jl = text.length; j &lt; jl; j++) {
                codepoints.push(text.charCodeAt(j));
            }

            // Track indexes of features with text.
            textFeatures[i] = text;
        }

        // get a list of unique codepoints we are missing
        codepoints = uniq(codepoints, glyphs);

        return {
            textFeatures: textFeatures,
            codepoints: codepoints
        };
    }

    function uniq(ids, alreadyHave) {
        var u = [];
        var last;
        ids.sort(sortNumbers);
        for (var i = 0; i &lt; ids.length; i++) {
            if (ids[i] !== last) {
                last = ids[i];
                if (!alreadyHave[last]) u.push(ids[i]);
            }
        }
        return u;
    }

    function sortNumbers(a, b) {
        return a - b;
    }

},{&quot;../util/token&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/token.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/shaping.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = {
        shapeText: shapeText,
        shapeIcon: shapeIcon
    };


// The position of a glyph relative to the text&#039;s anchor point.
    function PositionedGlyph(codePoint, x, y, glyph) {
        this.codePoint = codePoint;
        this.x = x;
        this.y = y;
        this.glyph = glyph;
    }

// A collection of positioned glyphs and some metadata
    function Shaping(positionedGlyphs, top, bottom, left, right) {
        this.positionedGlyphs = positionedGlyphs;
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }

    function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {

        var positionedGlyphs = [];
        var shaping = new Shaping(positionedGlyphs, translate[1], translate[1], translate[0], translate[0]);

        // the y offset *should* be part of the font metadata
        var yOffset = -17;

        var x = translate[0];
        var y = translate[1] + yOffset;

        for (var i = 0; i &lt; text.length; i++) {
            var codePoint = text.charCodeAt(i);
            var glyph = glyphs[codePoint];

            if (!glyph) continue;

            positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
            x += glyph.advance + spacing;
        }

        if (!positionedGlyphs.length) return false;

        linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify);

        return shaping;
    }

    var breakable = { 32: true }; // Currently only breaks at regular spaces

    function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify) {
        var lastSafeBreak = null;

        var lengthBeforeCurrentLine = 0;
        var lineStartIndex = 0;
        var line = 0;

        var maxLineLength = 0;

        var positionedGlyphs = shaping.positionedGlyphs;

        if (maxWidth) {
            for (var i = 0; i &lt; positionedGlyphs.length; i++) {
                var positionedGlyph = positionedGlyphs[i];

                positionedGlyph.x -= lengthBeforeCurrentLine;
                positionedGlyph.y += lineHeight * line;

                if (positionedGlyph.x &gt; maxWidth &amp;&amp; lastSafeBreak !== null) {

                    var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
                    maxLineLength = Math.max(lineLength, maxLineLength);

                    for (var k = lastSafeBreak + 1; k &lt;= i; k++) {
                        positionedGlyphs[k].y += lineHeight;
                        positionedGlyphs[k].x -= lineLength;
                    }

                    if (justify) {
                        justifyLine(positionedGlyphs, glyphs, lineStartIndex, lastSafeBreak - 1, justify);
                    }

                    lineStartIndex = lastSafeBreak + 1;
                    lastSafeBreak = null;
                    lengthBeforeCurrentLine += lineLength;
                    line++;
                }

                if (breakable[positionedGlyph.codePoint]) {
                    lastSafeBreak = i;
                }
            }
        }

        var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
        var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
        maxLineLength = Math.max(maxLineLength, lastLineLength);

        var height = (line + 1) * lineHeight;

        justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
        align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line);

        // Calculate the bounding box
        shaping.top += -verticalAlign * height;
        shaping.bottom = shaping.top + height;
        shaping.left += -horizontalAlign * maxLineLength;
        shaping.right = shaping.left + maxLineLength;
    }

    function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
        var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
        var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

        for (var j = start; j &lt;= end; j++) {
            positionedGlyphs[j].x -= lineIndent;
        }

    }

    function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line) {
        var shiftX = (justify - horizontalAlign) * maxLineLength;
        var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight;

        for (var j = 0; j &lt; positionedGlyphs.length; j++) {
            positionedGlyphs[j].x += shiftX;
            positionedGlyphs[j].y += shiftY;
        }
    }


    function shapeIcon(image, layout) {
        if (!image || !image.rect) return null;

        var dx = layout[&#039;icon-offset&#039;][0];
        var dy = layout[&#039;icon-offset&#039;][1];
        var x1 = dx - image.width / 2;
        var x2 = x1 + image.rect.w;
        var y1 = dy - image.height / 2;
        var y2 = y1 + image.rect.h;

        return new PositionedIcon(image, y1, y2, x1, x2);
    }

    function PositionedIcon(image, top, bottom, left, right) {
        this.image = image;
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/sprite_atlas.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var BinPack = require(&#039;./bin_pack&#039;);

    module.exports = SpriteAtlas;
    function SpriteAtlas(width, height) {
        this.width = width;
        this.height = height;

        this.bin = new BinPack(width, height);
        this.images = {};
        this.data = false;
        this.texture = 0; // WebGL ID
        this.filter = 0; // WebGL ID
        this.pixelRatio = 1;
        this.dirty = true;
    }

    SpriteAtlas.prototype = {
        get debug() {
            return &#039;canvas&#039; in this;
        },
        set debug(value) {
            if (value &amp;&amp; !this.canvas) {
                this.canvas = document.createElement(&#039;canvas&#039;);
                this.canvas.width = this.width * this.pixelRatio;
                this.canvas.height = this.height * this.pixelRatio;
                this.canvas.style.width = this.width + &#039;px&#039;;
                this.canvas.style.width = this.width + &#039;px&#039;;
                document.body.appendChild(this.canvas);
                this.ctx = this.canvas.getContext(&#039;2d&#039;);
            } else if (!value &amp;&amp; this.canvas) {
                this.canvas.parentNode.removeChild(this.canvas);
                delete this.ctx;
                delete this.canvas;
            }
        }
    };

    SpriteAtlas.prototype.resize = function(newRatio) {
        if (this.pixelRatio === newRatio) return false;

        var oldRatio = this.pixelRatio;
        this.pixelRatio = newRatio;

        if (this.canvas) {
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
        }

        if (this.data) {
            var oldData = this.data;

            this.data = false;
            this.allocate();
            this.texture = false;

            var oldWidth = this.width * oldRatio;
            var oldHeight = this.height * oldRatio;
            var newWidth = this.width * newRatio;
            var newHeight = this.height * newRatio;

            // Basic image scaling. TODO: Replace this with better image scaling.
            var newImage = this.data;
            var oldImage = oldData;

            for (var y = 0; y &lt; newHeight; y++) {
                var oldYOffset = Math.floor((y * oldHeight) / newHeight) * oldWidth;
                var newYOffset = y * newWidth;
                for (var x = 0; x &lt; newWidth; x++) {
                    var oldX = Math.floor((x * oldWidth) / newWidth);
                    newImage[newYOffset + x] = oldImage[oldYOffset + oldX];
                }
            }

            oldData = null;
            this.dirty = true;
        }

        return this.dirty;
    };

    function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
        var srcI = srcY * srcStride + srcX;
        var dstI = dstY * dstStride + dstX;
        var x, y;

        if (wrap) {
            // add 1 pixel wrapped padding on each side of the image
            dstI -= dstStride;
            for (y = -1; y &lt;= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
                for (x = -1; x &lt;= width; x++) {
                    dst[dstI + x] = src[srcI + ((x + width) % width)];
                }
            }

        } else {
            for (y = 0; y &lt; height; y++, srcI += srcStride, dstI += dstStride) {
                for (x = 0; x &lt; width; x++) {
                    dst[dstI + x] = src[srcI + x];
                }
            }
        }
    }

    SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {

        // Increase to next number divisible by 4, but at least 1.
        // This is so we can scale down the texture coordinates and pack them
        // into 2 bytes rather than 4 bytes.
        // Pad icons to prevent them from polluting neighbours during linear interpolation
        var padding = 2;
        var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
        var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;

        // We have to allocate a new area in the bin, and store an empty image in it.
        // Add a 1px border around every image.
        var rect = this.bin.allocate(packWidth, packHeight);
        if (rect.w === 0) {
            return rect;
        }

        rect.originalWidth = pixelWidth;
        rect.originalHeight = pixelHeight;

        return rect;
    };

    SpriteAtlas.prototype.getImage = function(name, wrap) {
        if (this.images[name]) {
            return this.images[name];
        }

        if (!this.sprite) {
            return null;
        }

        var pos = this.sprite.getSpritePosition(name);
        if (!pos.width || !pos.height) {
            return null;
        }

        var width = pos.width / pos.pixelRatio;
        var height = pos.height / pos.pixelRatio;
        var rect = this.allocateImage(width, height);
        if (rect.w === 0) {
            return rect;
        }

        var image = new AtlasImage(rect, width, height, pos.sdf);
        this.images[name] = image;

        this.copy(rect, pos, wrap);

        return image;
    };


    SpriteAtlas.prototype.getPosition = function(name, repeating) {
        var image = this.getImage(name, repeating);
        var rect = image &amp;&amp; image.rect;

        if (!rect) {
            return null;
        }

        // When the image is repeating, get the correct position of the image, rather than the
        // one rounded up to 4 pixels.
        var width = repeating ? image.width : rect.w;
        var height = repeating ? image.height : rect.h;

        return {
            size: [width, height],
            tl: [(rect.x)         / this.width, (rect.y)          / this.height],
            br: [(rect.x + width) / this.width, (rect.y + height) / this.height]
        };
    };


    SpriteAtlas.prototype.allocate = function() {
        if (!this.data) {
            var w = Math.floor(this.width * this.pixelRatio);
            var h = Math.floor(this.height * this.pixelRatio);
            this.data = new Uint32Array(w * h);
            for (var i = 0; i &lt; this.data.length; i++) {
                this.data[i] = 0;
            }
        }
    };


    SpriteAtlas.prototype.copy = function(dst, src, wrap) {
        // if (!sprite-&gt;raster) return;
        if (!this.sprite.img.data) return;
        var srcImg = new Uint32Array(this.sprite.img.data.buffer);

        this.allocate();
        var dstImg = this.data;

        copyBitmap(
            /* source buffer */  srcImg,
            /* source stride */  this.sprite.img.width,
            /* source x */       src.x,
            /* source y */       src.y,
            /* dest buffer */    dstImg,
            /* dest stride */    this.width * this.pixelRatio,
            /* dest x */         dst.x * this.pixelRatio,
            /* dest y */         dst.y * this.pixelRatio,
            /* icon dimension */ src.width,
            /* icon dimension */ src.height,
            /* wrap */ wrap
        );

        this.dirty = true;
    };

    SpriteAtlas.prototype.setSprite = function(sprite) {
        this.sprite = sprite;
    };

    SpriteAtlas.prototype.addIcons = function(icons, callback) {
        for (var i = 0; i &lt; icons.length; i++) {
            this.getImage(icons[i]);
        }

        callback(null, this.images);
    };

    SpriteAtlas.prototype.bind = function(gl, linear) {
        var first = false;
        if (!this.texture) {
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            first = true;
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }

        var filterVal = linear ? gl.LINEAR : gl.NEAREST;
        if (filterVal !== this.filter) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
            this.filter = filterVal;
        }

        if (this.dirty) {
            this.allocate();

            if (first) {
                gl.texImage2D(
                    gl.TEXTURE_2D, // enum target
                    0, // ind level
                    gl.RGBA, // ind internalformat
                        this.width * this.pixelRatio, // GLsizei width
                        this.height * this.pixelRatio, // GLsizei height
                    0, // ind border
                    gl.RGBA, // enum format
                    gl.UNSIGNED_BYTE, // enum type
                    new Uint8Array(this.data.buffer) // Object data
                );
            } else {
                gl.texSubImage2D(
                    gl.TEXTURE_2D, // enum target
                    0, // int level
                    0, // int xoffset
                    0, // int yoffset
                        this.width * this.pixelRatio, // long width
                        this.height * this.pixelRatio, // long height
                    gl.RGBA, // enum format
                    gl.UNSIGNED_BYTE, // enum type
                    new Uint8Array(this.data.buffer) // Object pixels
                );
            }

            this.dirty = false;

            // DEBUG
            if (this.ctx) {
                var data = this.ctx.getImageData(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);
                data.data.set(new Uint8ClampedArray(this.data.buffer));
                this.ctx.putImageData(data, 0, 0);

                this.ctx.strokeStyle = &#039;red&#039;;
                for (var k = 0; k &lt; this.bin.free.length; k++) {
                    var free = this.bin.free[k];
                    this.ctx.strokeRect(free.x * this.pixelRatio, free.y * this.pixelRatio, free.w * this.pixelRatio, free.h * this.pixelRatio);
                }
            }
            // END DEBUG
        }
    };

    function AtlasImage(rect, width, height, sdf) {
        this.rect = rect;
        this.width = width;
        this.height = height;
        this.sdf = sdf;
    }

},{&quot;./bin_pack&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/symbol/bin_pack.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/attribution.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Control = require(&#039;./control&#039;);
    var DOM = require(&#039;../../util/dom&#039;);
    var util = require(&#039;../../util/util&#039;);

    module.exports = Attribution;

    /**
     * Creates an attribution control
     * @class Attribution
     * @example
     * map.addControl(new mapboxgl.Attribution());
     */
    function Attribution() {}

    Attribution.prototype = util.inherit(Control, {
        options: {
            position: &#039;bottom-right&#039;
        },

        onAdd: function(map) {
            var className = &#039;mapboxgl-ctrl-attrib&#039;,
                container = this._container = DOM.create(&#039;div&#039;, className, map.getContainer());

            this._update();
            map.on(&#039;source.load&#039;, this._update.bind(this));
            map.on(&#039;source.change&#039;, this._update.bind(this));
            map.on(&#039;source.remove&#039;, this._update.bind(this));
            map.on(&#039;moveend&#039;, this._updateEditLink.bind(this));

            return container;
        },

        _update: function() {
            var attributions = [];

            if (this._map.style) {
                for (var id in this._map.style.sources) {
                    var source = this._map.style.sources[id];
                    if (source.attribution &amp;&amp; attributions.indexOf(source.attribution) &lt; 0) {
                        attributions.push(source.attribution);
                    }
                }
            }

            this._container.innerHTML = attributions.join(&#039; | &#039;);
            this._editLink = this._container.getElementsByClassName(&#039;mapbox-improve-map&#039;)[0];
            this._updateEditLink();
        },

        _updateEditLink: function() {
            if (this._editLink) {
                var center = this._map.getCenter();
                this._editLink.href = &#039;https://www.mapbox.com/map-feedback/#/&#039; +
                    center.lng + &#039;/&#039; + center.lat + &#039;/&#039; + Math.round(this._map.getZoom() + 1);
            }
        }
    });

},{&quot;../../util/dom&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dom.js&quot;,&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./control&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/control.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/control.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = Control;

    /**
     * A base class for map-related interface elements.
     *
     * @class Control
     */
    function Control() {}

    Control.prototype = {
        /**
         * Add this control to the map, returning the control itself
         * for chaining. This will insert the control&#039;s DOM element into
         * the map&#039;s DOM element if the control has a `position` specified.
         *
         * @param {Map} map
         * @returns {Control} this
         */
        addTo: function(map) {
            this._map = map;
            var container = this._container = this.onAdd(map);
            if (this.options &amp;&amp; this.options.position) {
                var pos = this.options.position;
                var corner = map._controlCorners[pos];
                container.className += &#039; mapboxgl-ctrl&#039;;
                if (pos.indexOf(&#039;bottom&#039;) !== -1) {
                    corner.insertBefore(container, corner.firstChild);
                } else {
                    corner.appendChild(container);
                }
            }

            return this;
        },

        /**
         * Remove this control from the map it has been added to.
         *
         * @returns {Control} this
         */
        remove: function() {
            this._container.parentNode.removeChild(this._container);
            if (this.onRemove) this.onRemove(this._map);
            this._map = null;
            return this;
        }
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/navigation.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Control = require(&#039;./control&#039;);
    var DOM = require(&#039;../../util/dom&#039;);
    var util = require(&#039;../../util/util&#039;);

    module.exports = Navigation;

    /**
     * Creates a navigation control with zoom buttons and a compass
     * @class Navigation
     * @param {Object} [options]
     * @param {String} [options.position=top-right] A string indicating the control&#039;s position on the map. Options are `top-right`, `top-left`, `bottom-right`, `bottom-left`
     * @example
     * map.addControl(new mapboxgl.Navigation({position: &#039;top-left&#039;})); // position is optional
     */
    function Navigation(options) {
        util.setOptions(this, options);
    }

    Navigation.prototype = util.inherit(Control, {
        options: {
            position: &#039;top-right&#039;
        },

        onAdd: function(map) {
            var className = &#039;mapboxgl-ctrl&#039;;

            var container = this._container = DOM.create(&#039;div&#039;, className + &#039;-group&#039;, map.getContainer());

            this._zoomInButton = this._createButton(className + &#039;-icon &#039; + className + &#039;-zoom-in&#039;, map.zoomIn.bind(map));
            this._zoomOutButton = this._createButton(className + &#039;-icon &#039; + className + &#039;-zoom-out&#039;, map.zoomOut.bind(map));
            this._compass = this._createButton(className + &#039;-compass&#039;, map.resetNorth.bind(map));

            var compassCanvas = this._compassCanvas = DOM.create(&#039;canvas&#039;, className + &#039;-compass-canvas&#039;, this._compass);
            compassCanvas.style.cssText = &#039;width:26px; height:26px;&#039;;
            compassCanvas.width = 26 * 2;
            compassCanvas.height = 26 * 2;

            this._compass.addEventListener(&#039;mousedown&#039;, this._onCompassDown.bind(this));
            this._onCompassMove = this._onCompassMove.bind(this);
            this._onCompassUp = this._onCompassUp.bind(this);

            this._compassCtx = compassCanvas.getContext(&#039;2d&#039;);

            map.on(&#039;rotate&#039;, this._drawNorth.bind(this));
            this._drawNorth();

            return container;
        },

        _onCompassDown: function(e) {
            DOM.disableDrag();

            document.addEventListener(&#039;mousemove&#039;, this._onCompassMove);
            document.addEventListener(&#039;mouseup&#039;, this._onCompassUp);
            this._prevX = e.screenX;

            e.stopPropagation();
        },

        _onCompassMove: function(e) {
            var x = e.screenX,
                d = x &lt; 2 ? -5 : // left edge of the screen, continue rotating
                        x &gt; window.screen.width - 2 ? 5 : // right edge
                    (x - this._prevX) / 4;

            this._map.setBearing(this._map.getBearing() - d);
            this._prevX = e.screenX;
            this._moved = true;

            e.preventDefault();
        },

        _onCompassUp: function() {
            document.removeEventListener(&#039;mousemove&#039;, this._onCompassMove);
            document.removeEventListener(&#039;mouseup&#039;, this._onCompassUp);
            DOM.enableDrag();

            if (this._moved) {
                this._moved = false;
                DOM.suppressClick();
            }
        },

        _createButton: function(className, fn) {
            var a = DOM.create(&#039;button&#039;, className, this._container);
            a.addEventListener(&#039;click&#039;, function() { fn(); });
            return a;
        },

        _drawNorth: function() {
            var rad = 20,
                width = 8,
                center = 26,
                angle = this._map.transform.angle + (Math.PI / 2),
                ctx = this._compassCtx;

            this._compassCanvas.width = this._compassCanvas.width;

            ctx.translate(center, center);
            ctx.rotate(angle);

            ctx.beginPath();
            ctx.fillStyle = &#039;#000&#039;;
            ctx.lineTo(0, -width);
            ctx.lineTo(-rad, 0);
            ctx.lineTo(0, width);
            ctx.fill();

            ctx.beginPath();
            ctx.fillStyle = &#039;#bbb&#039;;
            ctx.moveTo(0, 0);
            ctx.lineTo(0, width);
            ctx.lineTo(rad, 0);
            ctx.lineTo(0, -width);
            ctx.fill();

            ctx.beginPath();
            ctx.strokeStyle = &#039;#fff&#039;;
            ctx.lineWidth = 4;
            ctx.moveTo(0, -width);
            ctx.lineTo(0, width);
            ctx.stroke();
        }
    });

},{&quot;../../util/dom&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dom.js&quot;,&quot;../../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./control&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/control.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/easings.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util/util&#039;);
    var interpolate = require(&#039;../util/interpolate&#039;);
    var browser = require(&#039;../util/browser&#039;);
    var LatLng = require(&#039;../geo/lat_lng&#039;);
    var LatLngBounds = require(&#039;../geo/lat_lng_bounds&#039;);
    var Point = require(&#039;point-geometry&#039;);

    /**
     * @typedef {Object} [animOptions]
     * @param {Number} [animOptions.duration=500] Number in milliseconds
     * @param {Function} animOptions.easing
     * @param {Array} [animOptions.offset=[0,0]] point, origin of movement relative to map center
     * @param {Boolean} [animOptions.animate=true] When set to false, no animation happens
     */
    util.extend(exports, /** @lends Map.prototype */{
        isEasing: function() {
            return !!this._abortFn;
        },

        /**
         * Stop current animation
         *
         * @returns {this}
         */
        stop: function() {
            if (this._abortFn) {
                this._abortFn.call(this);
                delete this._abortFn;

                this._finishFn.call(this);
                delete this._finishFn;
            }
            return this;
        },

        _ease: function(frame, finish, options) {
            this._finishFn = finish;
            this._abortFn = browser.timed(function (t) {
                frame.call(this, options.easing(t));
                if (t === 1) {
                    delete this._abortFn;
                    this._finishFn.call(this);
                    delete this._finishFn;
                }
            }, options.animate === false ? 0 : options.duration, this);
        },

        /**
         * Pan by a certain number of pixels
         *
         * @param {Array} offset [x, y]
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        panBy: function(offset, options) {
            this.panTo(this.transform.center, util.extend({offset: Point.convert(offset).mult(-1)}, options));
            return this;
        },

        /**
         * Pan to a certain location with easing
         *
         * @param {Object} latlng a `LatLng` object
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        panTo: function(latlng, options) {
            this.stop();

            latlng = LatLng.convert(latlng);

            options = util.extend({
                duration: 500,
                easing: util.ease,
                offset: [0, 0]
            }, options);

            var tr = this.transform,
                offset = Point.convert(options.offset).rotate(-tr.angle),
                from = tr.point,
                to = tr.project(latlng).sub(offset);

            if (!options.noMoveStart) {
                this.fire(&#039;movestart&#039;);
            }

            this._ease(function(k) {
                tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
                this._move();
            }, function() {
                this.fire(&#039;moveend&#039;);
            }, options);

            return this;
        },

        /**
         * Zooms to a certain zoom level with easing.
         *
         * @param {Number} zoom
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        zoomTo: function(zoom, options) {
            this.stop();

            options = util.extend({
                duration: 500
            }, options);

            options.easing = this._updateEasing(options.duration, zoom, options.easing);

            var tr = this.transform,
                around = tr.center,
                startZoom = tr.zoom;

            if (options.around) {
                around = LatLng.convert(options.around);
            } else if (options.offset) {
                around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
            }

            if (options.animate === false) options.duration = 0;

            if (!this.zooming) {
                this.zooming = true;
                this.fire(&#039;movestart&#039;);
            }

            this._ease(function(k) {
                tr.setZoomAround(interpolate(startZoom, zoom, k), around);
                this.animationLoop.set(300); // text fading
                this._move(true);
            }, function() {
                this.ease = null;
                if (options.duration &gt;= 200) {
                    this.zooming = false;
                    this.fire(&#039;moveend&#039;);
                }
            }, options);

            if (options.duration &lt; 200) {
                clearTimeout(this._onZoomEnd);
                this._onZoomEnd = setTimeout(function() {
                    this.zooming = false;
                    this._rerender();
                    this.fire(&#039;moveend&#039;);
                }.bind(this), 200);
            }

            return this;
        },

        /**
         * Zoom in by 1 level
         *
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        zoomIn: function(options) {
            this.zoomTo(this.getZoom() + 1, options);
        },

        /**
         * Zoom out by 1 level
         *
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        zoomOut: function(options) {
            this.zoomTo(this.getZoom() - 1, options);
        },

        /**
         * Rotate bearing by a certain number of degrees with easing
         *
         * @param {Number} bearing
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        rotateTo: function(bearing, options) {
            this.stop();

            options = util.extend({
                duration: 500,
                easing: util.ease
            }, options);

            var tr = this.transform,
                start = this.getBearing(),
                around = tr.center;

            if (options.around) {
                around = LatLng.convert(options.around);
            } else if (options.offset) {
                around = tr.pointLocation(tr.centerPoint.add(Point.convert(options.offset)));
            }

            bearing = this._normalizeBearing(bearing, start);

            this.rotating = true;
            this.fire(&#039;movestart&#039;);

            this._ease(function(k) {
                tr.setBearingAround(interpolate(start, bearing, k), around);
                this._move(false, true);
            }, function() {
                this.rotating = false;
                this.fire(&#039;moveend&#039;);
            }, options);

            return this;
        },

        /**
         * Sets map bearing to 0 (north) with easing
         *
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        resetNorth: function(options) {
            return this.rotateTo(0, util.extend({duration: 1000}, options));
        },

        /**
         * Zoom to contain certain geographical bounds
         *
         * @param {Array} bounds [[minLat, minLng], [maxLat, maxLng]]
         * @param {Object} options
         * @param {Number} [options.speed=1.2] How fast animation occurs
         * @param {Number} [options.curve=1.42] How much zooming out occurs during animation
         * @param {Function} options.easing
         * @param {Number} options.padding how much padding there is around the given bounds on each side in pixels
         * @param {Number} options.maxZoom
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        fitBounds: function(bounds, options) {

            options = util.extend({
                padding: 0,
                offset: [0, 0],
                maxZoom: Infinity
            }, options);

            bounds = LatLngBounds.convert(bounds);

            var offset = Point.convert(options.offset),
                tr = this.transform,
                nw = tr.project(bounds.getNorthWest()),
                se = tr.project(bounds.getSouthEast()),
                size = se.sub(nw),
                center = tr.unproject(nw.add(se).div(2)),

                scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
                scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y,

                zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);

            return options.linear ?
                this.easeTo(center, zoom, 0, options) :
                this.flyTo(center, zoom, 0, options);
        },

        /**
         * Easing animation to a specified location/zoom/bearing
         *
         * @param {Object} latlng a `LatLng` object
         * @param {Number} zoom
         * @param {Number} bearing
         * @param {Number} pitch
         * @param {animOptions}
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        easeTo: function(latlng, zoom, bearing, pitch, options) {
            this.stop();

            options = util.extend({
                offset: [0, 0],
                duration: 500,
                easing: util.ease
            }, options);

            var tr = this.transform,
                offset = Point.convert(options.offset).rotate(-tr.angle),
                startZoom = this.getZoom(),
                startBearing = this.getBearing(),
                startPitch = this.getPitch();

            latlng = LatLng.convert(latlng);
            zoom = zoom === undefined ? startZoom : zoom;
            bearing = bearing === undefined ? startBearing : this._normalizeBearing(bearing, startBearing);
            pitch = pitch === undefined ? startPitch : pitch;

            var scale = tr.zoomScale(zoom - startZoom),
                from = tr.point,
                to = latlng ? tr.project(latlng).sub(offset.div(scale)) : tr.point,
                around;

            if (zoom !== startZoom) {
                around = tr.pointLocation(tr.centerPoint.add(to.sub(from).div(1 - 1 / scale)));
                this.zooming = true;
            }
            if (startBearing !== bearing) this.rotating = true;

            this.fire(&#039;movestart&#039;);

            this._ease(function (k) {
                if (zoom !== startZoom) {
                    tr.setZoomAround(interpolate(startZoom, zoom, k), around);
                } else {
                    tr.center = tr.unproject(from.add(to.sub(from).mult(k)));
                }

                if (bearing !== startBearing) {
                    tr.bearing = interpolate(startBearing, bearing, k);
                }

                if (pitch !== startPitch) {
                    tr.pitch = interpolate(startPitch, pitch, k);
                }

                this.animationLoop.set(300); // text fading
                this._move(zoom !== startZoom, bearing !== startBearing);
            }, function() {
                this.zooming = false;
                this.rotating = false;
                this.fire(&#039;moveend&#039;);
            }, options);

            return this;
        },

        /**
         * Flying animation to a specified location/zoom/bearing with automatic curve
         *
         * @param {Object} latlng a `LatLng` object
         * @param {Number} zoom
         * @param {Number} bearing
         * @param {Object} options
         * @param {Number} [options.speed=1.2] How fast animation occurs
         * @param {Number} [options.curve=1.42] How much zooming out occurs during animation
         * @param {Function} options.easing
         * @fires movestart
         * @fires moveend
         * @returns {this}
         */
        flyTo: function(latlng, zoom, bearing, options) {
            this.stop();

            options = util.extend({
                offset: [0, 0],
                speed: 1.2,
                curve: 1.42,
                easing: util.ease
            }, options);

            latlng = LatLng.convert(latlng);

            var offset = Point.convert(options.offset),
                tr = this.transform,
                startZoom = this.getZoom(),
                startBearing = this.getBearing();

            zoom = zoom === undefined ? startZoom : zoom;
            bearing = bearing === undefined ? startBearing : this._normalizeBearing(bearing, startBearing);

            var scale = tr.zoomScale(zoom - startZoom),
                from = tr.point,
                to = tr.project(latlng).sub(offset.div(scale));

            if (options.animate === false) {
                return this.setView(latlng, zoom, bearing, this.getPitch());
            }

            var startWorldSize = tr.worldSize,
                rho = options.curve,
                V = options.speed,

                w0 = Math.max(tr.width, tr.height),
                w1 = w0 / scale,
                u1 = to.sub(from).mag(),
                rho2 = rho * rho;

            function r(i) {
                var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
                return Math.log(Math.sqrt(b * b + 1) - b);
            }

            function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
            function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
            function tanh(n) { return sinh(n) / cosh(n); }

            var r0 = r(0),
                w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
                u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
                S = (r(1) - r0) / rho;

            if (Math.abs(u1) &lt; 0.000001) {
                if (Math.abs(w0 - w1) &lt; 0.000001) return this;

                var k = w1 &lt; w0 ? -1 : 1;
                S = Math.abs(Math.log(w1 / w0)) / rho;

                u = function() { return 0; };
                w = function(s) { return Math.exp(k * rho * s); };
            }

            options.duration = 1000 * S / V;

            this.zooming = true;
            if (startBearing !== bearing) this.rotating = true;

            this.fire(&#039;movestart&#039;);

            this._ease(function (k) {
                var s = k * S,
                    us = u(s);

                tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
                tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

                if (bearing !== startBearing) {
                    tr.bearing = interpolate(startBearing, bearing, k);
                }

                this.animationLoop.set(300); // text fading

                this._move(true, bearing !== startBearing);
            }, function() {
                this.zooming = false;
                this.rotating = false;
                this.fire(&#039;moveend&#039;);
            }, options);

            return this;
        },

        // convert bearing so that it&#039;s numerically close to the current one so that it interpolates properly
        _normalizeBearing: function(bearing, currentBearing) {
            bearing = util.wrap(bearing, -180, 180);
            var diff = Math.abs(bearing - currentBearing);
            if (Math.abs(bearing - 360 - currentBearing) &lt; diff) bearing -= 360;
            if (Math.abs(bearing + 360 - currentBearing) &lt; diff) bearing += 360;
            return bearing;
        },

        _updateEasing: function(duration, zoom, bezier) {
            var easing;

            if (this.ease) {
                var ease = this.ease,
                    t = (Date.now() - ease.start) / ease.duration,
                    speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                    x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                    y = Math.sqrt(0.27 * 0.27 - x * x);

                easing = util.bezier(x, y, 0.25, 1);
            } else {
                easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
            }

            // store information on current easing
            this.ease = {
                start: (new Date()).getTime(),
                to: Math.pow(2, zoom),
                duration: duration,
                easing: easing
            };

            return easing;
        }
    });

},{&quot;../geo/lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;,&quot;../geo/lat_lng_bounds&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng_bounds.js&quot;,&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;../util/interpolate&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/interpolate.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/handlers.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Interaction = require(&#039;./interaction&#039;);
    var Point = require(&#039;point-geometry&#039;);
    var util = require(&#039;../util/util&#039;);
    var DOM = require(&#039;../util/dom&#039;);
    var LatLngBounds = require(&#039;../geo/lat_lng_bounds&#039;);

    module.exports = Handlers;

    function Handlers(map) {

        var rotateEnd;

        var box;

        var inertiaLinearity = 0.2,
            inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1);

        function boxzoomFinish() {
            if (box) {
                box.parentNode.removeChild(box);
                map.getContainer().classList.remove(&#039;mapboxgl-crosshair&#039;);
                box = false;
                DOM.enableDrag();
            }
        }

        this.interaction = new Interaction(map.getCanvas())
            .on(&#039;click&#039;, function(e) {
                e.latLng = map.unproject(e.point);
                map.fire(&#039;click&#039;, e);
            })
            .on(&#039;mousemove&#039;, function(e) {
                e.latLng = map.unproject(e.point);
                map.fire(&#039;mousemove&#039;, e);
            })
            .on(&#039;down&#039;, function() {
                map.fire(&#039;movestart&#039;);
            })
            .on(&#039;resize&#039;, function() {
                map.stop();
                map.resize();
                map.update();
            })
            .on(&#039;keydown&#039;, function(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;

                var pan = 80;
                var rotate = 2;

                function zoomBy(z) {
                    map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1) * z);
                }

                function panBy(v) {
                    map.panBy(v);
                }

                function rotateBy(v) {
                    map.setBearing(map.getBearing() + v);
                }

                switch (e.keyCode) {
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        zoomBy(1);
                        break;
                    case 189:
                    case 109:
                    case 173:
                        zoomBy(-1);
                        break;
                    case 37:
                        if (e.shiftKey) {
                            rotateBy(-rotate);
                        } else {
                            panBy([-pan, 0]);
                        }
                        break;
                    case 39:
                        if (e.shiftKey) {
                            rotateBy(rotate);
                        } else {
                            panBy([pan, 0]);
                        }
                        break;
                    case 38:
                        panBy([0, -pan]);
                        break;
                    case 40:
                        panBy([0, pan]);
                        break;
                    default:
                        return;
                }
            })
            .on(&#039;pan&#039;, function(e) {
                map.stop();
                var mouseLocation = map.transform.pointLocation(e.point.add(e.offset));
                map.transform.setLocationAtPoint(mouseLocation, e.point);
                map._move();
            })
            .on(&#039;panend&#039;, function(e) {
                if (!e.inertia) {
                    map.fire(&#039;moveend&#039;);
                } else {
                    // convert velocity to px/s &amp; adjust for increased initial animation speed when easing out
                    var velocity = e.inertia.mult(1000 * inertiaLinearity),
                        speed = velocity.mag();

                    var maxSpeed = 4000; // px/s

                    if (speed &gt;= maxSpeed) {
                        speed = maxSpeed;
                        velocity._unit()._mult(maxSpeed);
                    }

                    var deceleration = 8000, // px/s^2
                        duration = speed / (deceleration * inertiaLinearity),
                        offset = velocity.mult(-duration / 2).round();

                    map.panBy(offset, {
                        duration: duration * 1000,
                        easing: inertiaEasing,
                        noMoveStart: true
                    });
                }
            })
            .on(&#039;zoom&#039;, function(e) {
                // Scale by sigmoid of scroll wheel delta.
                var scale = 2 / (1 + Math.exp(-Math.abs(e.delta / 100)));
                if (e.delta &lt; 0 &amp;&amp; scale !== 0) scale = 1 / scale;

                var fromScale = map.ease &amp;&amp; isFinite(e.delta) ? map.ease.to : map.transform.scale,
                    duration = !isFinite(e.delta) ? 800 : 0;

                map.zoomTo(map.transform.scaleZoom(fromScale * scale), {
                    duration: duration,
                    around: map.unproject(e.point)
                });
            })
            .on(&#039;rotate&#039;, function(e) {
                var center = map.transform.centerPoint, // Center of rotation
                    startToCenter = e.start.sub(center),
                    startToCenterDist = startToCenter.mag();

                map.rotating = true;

                // If the first click was too close to the center, move the center of rotation by 200 pixels
                // in the direction of the click.
                if (startToCenterDist &lt; 200) {
                    center = e.start.add(new Point(-200, 0)._rotate(startToCenter.angle()));
                }

                var bearingDiff = e.prev.sub(center).angleWith(e.current.sub(center)) / Math.PI * 180;
                map.transform.bearing = map.getBearing() - bearingDiff;

                map._move(false, true);

                window.clearTimeout(rotateEnd);
                rotateEnd = window.setTimeout(function() {
                    map.rotating = false;
                    map._rerender();
                }, 200);
            })
            .on(&#039;boxzoomstart&#039;, function(e) {
                if (!box) {
                    box = DOM.create(&#039;div&#039;, &#039;mapboxgl-boxzoom&#039;, map.getContainer());
                    map.getContainer().classList.add(&#039;mapboxgl-crosshair&#039;);
                    map.fire(&#039;boxzoomstart&#039;);
                    DOM.disableDrag();
                }

                var minX = Math.min(e.start.x, e.current.x);
                var maxX = Math.max(e.start.x, e.current.x);
                var minY = Math.min(e.start.y, e.current.y);
                var maxY = Math.max(e.start.y, e.current.y);

                DOM.setTransform(box, &#039;translate(&#039; + minX + &#039;px,&#039; + minY + &#039;px)&#039;);
                box.style.width = (maxX - minX) + &#039;px&#039;;
                box.style.height = (maxY - minY) + &#039;px&#039;;
            })
            .on(&#039;boxzoomend&#039;, function(e) {
                boxzoomFinish();

                var bounds = new LatLngBounds(
                    map.unproject(e.start),
                    map.unproject(e.current)
                );

                map.fitBounds(bounds, { linear: true }).fire(&#039;boxzoomend&#039;, {
                    boxZoomBounds: bounds
                });
            })
            .on(&#039;boxzoomcancel&#039;, boxzoomFinish);
    }

},{&quot;../geo/lat_lng_bounds&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng_bounds.js&quot;,&quot;../util/dom&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dom.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./interaction&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/interaction.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/hash.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    /*
     * Adds positional coordinates to URL hashes. Passed as an option to the map object
     *
     * @class mapboxgl.Hash
     * @returns {Hash} `this`
     */
    module.exports = Hash;

    var util = require(&#039;../util/util&#039;);

    function Hash() {
        util.bindAll([
            &#039;_onHashChange&#039;,
            &#039;_updateHash&#039;
        ], this);
    }

    Hash.prototype = {
        /* Map element to listen for coordinate changes
         *
         * @param {Object} map
         * @returns {Hash} `this`
         */
        addTo: function(map) {
            this._map = map;
            window.addEventListener(&#039;hashchange&#039;, this._onHashChange, false);
            this._map.on(&#039;moveend&#039;, this._updateHash);
            return this;
        },

        /* Removes hash
         *
         * @returns {Popup} `this`
         */
        remove: function() {
            window.removeEventListener(&#039;hashchange&#039;, this._onHashChange, false);
            this._map.off(&#039;moveend&#039;, this._updateHash);
            delete this._map;
            return this;
        },

        _onHashChange: function() {
            var loc = location.hash.replace(&#039;#&#039;, &#039;&#039;).split(&#039;/&#039;);
            if (loc.length &gt;= 3) {
                this._map.setView([+loc[1], +loc[2]], +loc[0], +(loc[3] || 0), this._map.getPitch());
                return true;
            }
            return false;
        },

        _updateHash: function() {
            var center = this._map.getCenter(),
                zoom = this._map.getZoom(),
                bearing = this._map.getBearing(),
                precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

                hash = &#039;#&#039; + (Math.round(zoom * 100) / 100) +
                    &#039;/&#039; + center.lat.toFixed(precision) +
                    &#039;/&#039; + center.lng.toFixed(precision) +
                    (bearing ? &#039;/&#039; + (Math.round(bearing * 10) / 10) : &#039;&#039;);

            window.history.replaceState(&#039;&#039;, &#039;&#039;, hash);
        }
    };

},{&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/interaction.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Evented = require(&#039;../util/evented&#039;);
    var browser = require(&#039;../util/browser&#039;);
    var Point = require(&#039;point-geometry&#039;);

    module.exports = Interaction;

    function Interaction(el) {
        var interaction = this;
        if (!el) return;

        var rotating = false,
            panned = false,
            boxzoom = false,
            firstPos = null,
            pos = null,
            inertia = null,
            now;

        function mousePos(e) {
            var rect = el.getBoundingClientRect();
            return new Point(
                    e.clientX - rect.left - el.clientLeft,
                    e.clientY - rect.top - el.clientTop);
        }

        el.addEventListener(&#039;contextmenu&#039;, function(ev) {
            rotating = true;
            firstPos = pos = mousePos(ev);
            ev.preventDefault();
        }, false);
        el.addEventListener(&#039;mousedown&#039;, onmousedown, false);
        document.addEventListener(&#039;mouseup&#039;, onmouseup, false);
        document.addEventListener(&#039;mousemove&#039;, onmousemove, false);
        el.addEventListener(&#039;click&#039;, onclick, false);
        scrollwheel(zoom);
        el.addEventListener(&#039;dblclick&#039;, ondoubleclick, false);
        window.addEventListener(&#039;resize&#039;, resize, false);
        el.addEventListener(&#039;keydown&#039;, keydown, false);

        function zoom(type, delta, point) {
            interaction.fire(&#039;zoom&#039;, {
                source: type,
                delta: delta,
                point: point
            });
            inertia = null;
            now = null;
        }

        function click(point, ev) {
            interaction.fire(&#039;click&#039;, {point: point, originalEvent: ev});
        }

        function mousemove(point, ev) {
            interaction.fire(&#039;mousemove&#039;, {point: point, originalEvent: ev});
        }

        function pan(point) {
            if (pos) {
                var offset = pos.sub(point);
                interaction.fire(&#039;pan&#039;, {offset: offset, point: point});

                // add an averaged version of this movement to the inertia vector
                if (inertia) {
                    var duration = Date.now() - now;
                    // sometimes it&#039;s 0 after some erratic paning
                    if (duration) {
                        var time = duration + now;
                        inertia.push([time, point]);
                        while (inertia.length &gt; 2 &amp;&amp; time - inertia[0][0] &gt; 100) inertia.shift();
                    }

                } else {
                    inertia = [];
                }
                now = Date.now();
                pos = point;
            }
        }

        function resize() {
            interaction.fire(&#039;resize&#039;);
        }

        function keydown(ev) {
            if (boxzoom &amp;&amp; ev.keyCode === 27) {
                interaction.fire(&#039;boxzoomcancel&#039;);
                boxzoom = false;
            }

            interaction.fire(&#039;keydown&#039;, ev);
        }

        function rotate(point) {
            if (pos) {
                interaction.fire(&#039;rotate&#039;, {
                    start: firstPos,
                    prev: pos,
                    current: point
                });
                pos = point;
            }
        }

        function doubleclick(point) {
            interaction.fire(&#039;dblclick&#039;, {point: point});
        }

        function onmousedown(ev) {
            firstPos = pos = mousePos(ev);
            interaction.fire(&#039;down&#039;);
            if (ev.shiftKey || ((ev.which === 1) &amp;&amp; (ev.button === 1))) {
                boxzoom = true;
            }
        }

        function onmouseup(ev) {
            panned = pos &amp;&amp; firstPos &amp;&amp; (pos.x !== firstPos.x || pos.y !== firstPos.y);

            rotating = false;
            pos = null;

            if (boxzoom) {
                interaction.fire(&#039;boxzoomend&#039;, {
                    start: firstPos,
                    current: mousePos(ev)
                });
                boxzoom = false;

            } else if (inertia &amp;&amp; inertia.length &gt;= 2 &amp;&amp; now &gt; Date.now() - 100) {
                var last = inertia[inertia.length - 1],
                    first = inertia[0],
                    velocity = last[1].sub(first[1]).div(last[0] - first[0]);
                interaction.fire(&#039;panend&#039;, {inertia: velocity});

            } else {
                interaction.fire(&#039;panend&#039;);
            }

            inertia = null;
            now = null;
        }

        function onmousemove(ev) {
            var point = mousePos(ev);

            if (boxzoom) {
                interaction.fire(&#039;boxzoomstart&#039;, {
                    start: firstPos,
                    current: point
                });

            } else if (rotating) {
                rotate(point);

            } else if (pos) {
                pan(point);

            } else {
                var target = ev.toElement || ev.target;
                while (target &amp;&amp; target !== el &amp;&amp; target.parentNode) target = target.parentNode;
                if (target === el) {
                    mousemove(point, ev);
                }
            }
        }

        function onclick(ev) {
            if (!panned) click(mousePos(ev), ev);
        }

        function ondoubleclick(ev) {
            doubleclick(mousePos(ev));
            zoom(&#039;wheel&#039;, Infinity * (ev.shiftKey ? -1 : 1), mousePos(ev));
            ev.preventDefault();
        }

        function scrollwheel(callback) {
            var firefox = /Firefox/i.test(navigator.userAgent);
            var safari = /Safari/i.test(navigator.userAgent) &amp;&amp; !/Chrom(ium|e)/i.test(navigator.userAgent);
            var time = window.performance || Date;

            el.addEventListener(&#039;wheel&#039;, wheel, false);
            el.addEventListener(&#039;mousewheel&#039;, mousewheel, false);

            var lastEvent = 0;

            var type = null;
            var typeTimeout = null;
            var initialValue = null;

            function scroll(value, ev) {
                var stamp = time.now();
                var timeDelta = stamp - lastEvent;
                lastEvent = stamp;

                var point = mousePos(ev);

                if (value !== 0 &amp;&amp; (value % 4.000244140625) === 0) {
                    // This one is definitely a mouse wheel event.
                    type = &#039;wheel&#039;;
                    // Normalize this value to match trackpad.
                    value = Math.floor(value / 4);
                } else if (value !== 0 &amp;&amp; Math.abs(value) &lt; 4) {
                    // This one is definitely a trackpad event because it is so small.
                    type = &#039;trackpad&#039;;
                } else if (timeDelta &gt; 400) {
                    // This is likely a new scroll action.
                    type = null;
                    initialValue = value;
                    // Start a timeout in case this was a singular event, and dely it
                    // by up to 40ms.
                    typeTimeout = setTimeout(function() {
                        type = &#039;wheel&#039;;
                        callback(type, -initialValue, point);
                    }, 40);
                } else if (type === null) {
                    // This is a repeating event, but we don&#039;t know the type of event
                    // just yet. If the delta per time is small, we assume it&#039;s a
                    // fast trackpad; otherwise we switch into wheel mode.
                    type = (Math.abs(timeDelta * value) &lt; 200) ? &#039;trackpad&#039; : &#039;wheel&#039;;

                    // Make sure our delayed event isn&#039;t fired again, because we
                    // accumulate the previous event (which was less than 40ms ago) into
                    // this event.
                    if (typeTimeout) {
                        clearTimeout(typeTimeout);
                        typeTimeout = null;
                        value += initialValue;
                    }
                }

                // Slow down zoom if shift key is held for more precise zooming
                if (ev.shiftKey &amp;&amp; value) value = value / 4;

                // Only fire the callback if we actually know what type of scrolling
                // device the user uses.
                if (type !== null) {
                    callback(type, -value, point);
                }
            }

            function wheel(e) {
                var deltaY = e.deltaY;
                // Firefox doubles the values on retina screens...
                if (firefox &amp;&amp; e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) deltaY /= browser.devicePixelRatio;
                if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) deltaY *= 40;
                scroll(deltaY, e);
                e.preventDefault();
            }

            function mousewheel(e) {
                var deltaY = -e.wheelDeltaY;
                if (safari) deltaY = deltaY / 3;
                scroll(deltaY, e);
                e.preventDefault();
            }
        }
    }

    Interaction.prototype = Object.create(Evented);

},{&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/map.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Canvas = require(&#039;../util/canvas&#039;);
    var util = require(&#039;../util/util&#039;);
    var browser = require(&#039;../util/browser&#039;);
    var Evented = require(&#039;../util/evented&#039;);
    var DOM = require(&#039;../util/dom&#039;);

    var Style = require(&#039;../style/style&#039;);
    var AnimationLoop = require(&#039;../style/animation_loop&#039;);
    var GLPainter = require(&#039;../render/painter&#039;);

    var Transform = require(&#039;../geo/transform&#039;);
    var Hash = require(&#039;./hash&#039;);
    var Handlers = require(&#039;./handlers&#039;);
    var Easings = require(&#039;./easings&#039;);
    var LatLng = require(&#039;../geo/lat_lng&#039;);
    var LatLngBounds = require(&#039;../geo/lat_lng_bounds&#039;);
    var Point = require(&#039;point-geometry&#039;);
    var Attribution = require(&#039;./control/attribution&#039;);

    /**
     * Creates a map instance.
     * @class Map
     * @param {Object} options
     * @param {String} options.container HTML element to initialize the map in (or element id as string)
     * @param {Number} [options.minZoom=0] Minimum zoom of the map
     * @param {Number} [options.maxZoom=20] Maximum zoom of the map
     * @param {Object} options.style Map style and data source definition (either a JSON object or a JSON URL), described in the [style reference](https://mapbox.com/mapbox-gl-style-spec/)
     * @param {Boolean} [options.hash=false] If `true`, the map will track and update the page URL according to map position
     * @param {Boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
     * @param {Array} options.classes Style class names with which to initialize the map
     * @param {Boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
     * @example
     * var map = new mapboxgl.Map({
 *   container: &#039;map&#039;,
 *   center: [37.772537, -122.420679],
 *   zoom: 13,
 *   style: style_object,
 *   hash: true
 * });
     */
    var Map = module.exports = function(options) {

        options = this.options = util.inherit(this.options, options);

        this.animationLoop = new AnimationLoop();
        this.transform = new Transform(options.minZoom, options.maxZoom);

        if (options.maxBounds) {
            var b = LatLngBounds.convert(options.maxBounds);
            this.transform.latRange = [b.getSouth(), b.getNorth()];
            this.transform.lngRange = [b.getWest(), b.getEast()];
        }

        util.bindAll([
            &#039;_forwardStyleEvent&#039;,
            &#039;_forwardSourceEvent&#039;,
            &#039;_forwardLayerEvent&#039;,
            &#039;_forwardTileEvent&#039;,
            &#039;_onStyleLoad&#039;,
            &#039;_onStyleChange&#039;,
            &#039;_onSourceAdd&#039;,
            &#039;_onSourceRemove&#039;,
            &#039;_onSourceUpdate&#039;,
            &#039;update&#039;,
            &#039;render&#039;
        ], this);

        this._setupContainer();
        this._setupControlPos();
        this._setupPainter();

        this.handlers = options.interactive &amp;&amp; new Handlers(this);

        this._hash = options.hash &amp;&amp; (new Hash()).addTo(this);
        // don&#039;t set position from options if set through hash
        if (!this._hash || !this._hash._onHashChange()) {
            this.setView(options.center, options.zoom, options.bearing, options.pitch);
        }

        this.sources = {};
        this.stacks = {};
        this._classes = {};

        this.resize();

        if (options.classes) this.setClasses(options.classes);
        if (options.style) this.setStyle(options.style);
        if (options.attributionControl) this.addControl(new Attribution());
    };

    util.extend(Map.prototype, Evented);
    util.extend(Map.prototype, Easings);
    util.extend(Map.prototype, /** @lends Map.prototype */{

        options: {
            center: [0, 0],
            zoom: 0,
            bearing: 0,
            pitch: 0,

            minZoom: 0,
            maxZoom: 20,

            interactive: true,
            hash: false,

            attributionControl: true,

            failIfMajorPerformanceCaveat: false
        },

        addControl: function(control) {
            control.addTo(this);
            return this;
        },

        /**
         * Sets a map position
         *
         * @param {Array} center Latitude and longitude (passed as `[lat, lng]`)
         * @param {number} zoom Map zoom level
         * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
         * @param {number} pitch The angle at which the camera is looking at the ground
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setView: function(center, zoom, bearing, pitch) {
            this.stop();

            var tr = this.transform,
                zoomChanged = tr.zoom !== +zoom,
                bearingChanged = tr.bearing !== +bearing,
                pitchChanged = tr.pitch !== +pitch;

            tr.center = LatLng.convert(center);
            tr.zoom = +zoom;
            tr.bearing = +bearing;
            tr.pitch = +pitch;

            return this
                .fire(&#039;movestart&#039;)
                ._move(zoomChanged, bearingChanged, pitchChanged)
                .fire(&#039;moveend&#039;);
        },

        /**
         * Sets a map location
         *
         * @param {Array} center Latitude and longitude (passed as `[lat, lng]`)
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setCenter: function(center) {
            this.setView(center, this.getZoom(), this.getBearing(), this.getPitch());
        },

        /**
         * Sets a map zoom
         *
         * @param {number} zoom Map zoom level
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setZoom: function(zoom) {
            this.setView(this.getCenter(), zoom, this.getBearing(), this.getPitch());
        },

        /**
         * Sets a map rotation
         *
         * @param {number} bearing Map rotation bearing in degrees counter-clockwise from north
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setBearing: function(bearing) {
            this.setView(this.getCenter(), this.getZoom(), bearing, this.getPitch());
        },

        /**
         * Sets a map angle
         *
         * @param {number} pitch The angle at which the camera is looking at the ground
         * @fires movestart
         * @fires moveend
         * @returns {Map} `this`
         */
        setPitch: function(pitch) {
            this.setView(this.getCenter(), this.getZoom(), this.getBearing(), pitch);
        },

        /**
         * Get the current view geographical point
         * @returns {LatLng}
         */
        getCenter: function() { return this.transform.center; },

        /**
         * Get the current zoom
         * @returns {number}
         */
        getZoom: function() { return this.transform.zoom; },

        /**
         * Get the current bearing in degrees
         * @returns {number}
         */
        getBearing: function() { return this.transform.bearing; },

        /**
         * Get the current angle in degrees
         * @returns {number}
         */
        getPitch: function() { return this.transform.pitch; },

        /**
         * @typedef {Object} [styleOptions]
         * @param {Boolean} [styleOptions.transition=true]
         */

        /**
         * Adds a style class to a map
         *
         * @param {string} klass name of style class
         * @param {styleOptions} options
         * @fires change
         * @returns {Map} `this`
         */
        addClass: function(klass, options) {
            if (this._classes[klass]) return;
            this._classes[klass] = true;
            if (this.style) this.style._cascade(this._classes, options);
        },

        /**
         * Removes a style class from a map
         *
         * @param {string} klass name of style class
         * @param {styleOptions} options
         * @fires change
         * @returns {Map} `this`
         */
        removeClass: function(klass, options) {
            if (!this._classes[klass]) return;
            delete this._classes[klass];
            if (this.style) this.style._cascade(this._classes, options);
        },

        /**
         * Helper method to add more than one class
         *
         * @param {Array&lt;string&gt;} klasses An array of class names
         * @param {styleOptions} options
         * @fires change
         * @returns {Map} `this`
         */
        setClasses: function(klasses, options) {
            this._classes = {};
            for (var i = 0; i &lt; klasses.length; i++) {
                this._classes[klasses[i]] = true;
            }
            if (this.style) this.style._cascade(this._classes, options);
        },

        /**
         * Check whether a style class is active
         *
         * @param {string} klass Name of style class
         * @returns {boolean}
         */
        hasClass: function(klass) {
            return !!this._classes[klass];
        },

        /**
         * Return an array of the current active style classes
         *
         * @returns {boolean}
         */
        getClasses: function() {
            return Object.keys(this._classes);
        },

        /**
         * Detect the map&#039;s new width and height and resize it.
         *
         * @returns {Map} `this`
         */
        resize: function() {
            var width = 0, height = 0;

            if (this._container) {
                width = this._container.offsetWidth || 400;
                height = this._container.offsetHeight || 300;
            }

            this._canvas.resize(width, height);

            this.transform.width = width;
            this.transform.height = height;
            this.transform._constrain();

            this.painter.resize(width, height);

            return this
                .fire(&#039;movestart&#039;)
                ._move()
                .fire(&#039;resize&#039;)
                .fire(&#039;moveend&#039;);
        },

        /**
         * Get the map&#039;s geographical bounds
         *
         * @returns {LatLngBounds}
         */
        getBounds: function() {
            return new LatLngBounds(
                this.transform.pointLocation(new Point(0, 0)),
                this.transform.pointLocation(this.transform.size));
        },

        /**
         * Get pixel coordinates (relative to map container) given a geographical location
         *
         * @param {LatLng} latlng
         * @returns {Object} `x` and `y` coordinates
         */
        project: function(latlng) {
            return this.transform.locationPoint(LatLng.convert(latlng));
        },

        /**
         * Get geographical coordinates given pixel coordinates
         *
         * @param {Array&lt;number&gt;} point [x, y] pixel coordinates
         * @returns {LatLng}
         */
        unproject: function(point) {
            return this.transform.pointLocation(Point.convert(point));
        },

        /**
         * Get all features at a point ([x, y])
         *
         * @param {Array&lt;number&gt;} point [x, y] pixel coordinates
         * @param {Object} params
         * @param {number} [params.radius=0] Optional. Radius in pixels to search in
         * @param {string} params.layer Optional. Only return features from a given layer
         * @param {string} params.type Optional. Either `raster` or `vector`
         * @param {featuresAtCallback} callback function that returns the response
         *
         * @callback featuresAtCallback
         * @param {Object|null} err Error _If any_
         * @param {Array} features Displays a JSON array of features given the passed parameters of `featuresAt`
         *
         * @returns {Map} `this`
         */
        featuresAt: function(point, params, callback) {
            var coord = this.transform.pointCoordinate(Point.convert(point));
            this.style.featuresAt(coord, params, callback);
            return this;
        },

        /**
         * Replaces the map&#039;s style object
         *
         * @param {Object} style A style object formatted as JSON
         * @returns {Map} `this`
         */
        setStyle: function(style) {
            if (this.style) {
                this.style
                    .off(&#039;load&#039;, this._onStyleLoad)
                    .off(&#039;error&#039;, this._forwardStyleEvent)
                    .off(&#039;change&#039;, this._onStyleChange)
                    .off(&#039;source.add&#039;, this._onSourceAdd)
                    .off(&#039;source.remove&#039;, this._onSourceRemove)
                    .off(&#039;source.load&#039;, this._onSourceUpdate)
                    .off(&#039;source.error&#039;, this._forwardSourceEvent)
                    .off(&#039;source.change&#039;, this._onSourceUpdate)
                    .off(&#039;layer.add&#039;, this._forwardLayerEvent)
                    .off(&#039;layer.remove&#039;, this._forwardLayerEvent)
                    .off(&#039;tile.add&#039;, this._forwardTileEvent)
                    .off(&#039;tile.remove&#039;, this._forwardTileEvent)
                    .off(&#039;tile.load&#039;, this.update)
                    .off(&#039;tile.error&#039;, this._forwardTileEvent)
                    ._remove();

                this.off(&#039;rotate&#039;, this.style._redoPlacement);
                this.off(&#039;pitch&#039;, this.style._redoPlacement);
            }

            if (!style) {
                this.style = null;
                return this;
            } else if (style instanceof Style) {
                this.style = style;
            } else {
                this.style = new Style(style, this.animationLoop);
            }

            this.style
                .on(&#039;load&#039;, this._onStyleLoad)
                .on(&#039;error&#039;, this._forwardStyleEvent)
                .on(&#039;change&#039;, this._onStyleChange)
                .on(&#039;source.add&#039;, this._onSourceAdd)
                .on(&#039;source.remove&#039;, this._onSourceRemove)
                .on(&#039;source.load&#039;, this._onSourceUpdate)
                .on(&#039;source.error&#039;, this._forwardSourceEvent)
                .on(&#039;source.change&#039;, this._onSourceUpdate)
                .on(&#039;layer.add&#039;, this._forwardLayerEvent)
                .on(&#039;layer.remove&#039;, this._forwardLayerEvent)
                .on(&#039;tile.add&#039;, this._forwardTileEvent)
                .on(&#039;tile.remove&#039;, this._forwardTileEvent)
                .on(&#039;tile.load&#039;, this.update)
                .on(&#039;tile.error&#039;, this._forwardTileEvent);

            this.on(&#039;rotate&#039;, this.style._redoPlacement);
            this.on(&#039;pitch&#039;, this.style._redoPlacement);

            return this;
        },

        /**
         * Add a source to the map style.
         *
         * @param {string} id ID of the source. Must not be used by any existing source.
         * @param {Object} source source specification, following the
         * [Mapbox GL Style Reference](https://www.mapbox.com/mapbox-gl-style-spec/#sources)
         * @fires source.add
         * @returns {Map} `this`
         */
        addSource: function(id, source) {
            this.style.addSource(id, source);
            return this;
        },

        /**
         * Remove an existing source from the map style.
         *
         * @param {string} id ID of the source to remove
         * @fires source.remove
         * @returns {Map} `this`
         */
        removeSource: function(id) {
            this.style.removeSource(id);
            return this;
        },

        /**
         * Return the style source object with the given `id`.
         *
         * @param {string} id source ID
         * @returns {Object}
         */
        getSource: function(id) {
            return this.style.getSource(id);
        },

        /**
         * Add a layer to the map style. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param {Layer} layer
         * @param {string=} before  ID of an existing layer to insert before
         * @fires layer.add
         * @returns {Map} `this`
         */
        addLayer: function(layer, before) {
            this.style.addLayer(layer, before);
            this.style._cascade(this._classes);
            return this;
        },

        /**
         * Remove the layer with the given `id` from the map. Any layers which refer to the
         * specified layer via a `ref` property are also removed.
         *
         * @param {string} id
         * @fires layer.remove
         * @returns {Map} this
         */
        removeLayer: function(id) {
            this.style.removeLayer(id);
            this.style._cascade(this._classes);
            return this;
        },

        /**
         * Set the filter for a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {Array} filter filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
         * @returns {Map} `this`
         */
        setFilter: function(layer, filter) {
            this.style.setFilter(layer, filter);
            return this;
        },

        /**
         * Get the filter for a given style layer.
         *
         * @param {string} layer ID of a layer
         * @returns {Array} filter specification, as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#filter)
         */
        getFilter: function(layer) {
            return this.style.getFilter(layer);
        },

        /**
         * Set the value of a paint property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a paint property
         * @param {*} value value for the paint propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
         * @param {string=} klass optional class specifier for the property
         * @returns {Map} `this`
         */
        setPaintProperty: function(layer, name, value, klass) {
            this.style.setPaintProperty(layer, name, value, klass);
            this.style._cascade(this._classes);
            this.update(true);
            return this;
        },

        /**
         * Get the value of a paint property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a paint property
         * @param {string=} klass optional class specifier for the property
         * @returns {*} value for the paint propery
         */
        getPaintProperty: function(layer, name, klass) {
            return this.style.getPaintProperty(layer, name, klass);
        },

        /**
         * Set the value of a layout property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a layout property
         * @param {*} value value for the layout propery; must have the type appropriate for the property as defined in the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/)
         * @returns {Map} `this`
         */
        setLayoutProperty: function(layer, name, value) {
            this.style.setLayoutProperty(layer, name, value);
            return this;
        },

        /**
         * Get the value of a layout property in a given style layer.
         *
         * @param {string} layer ID of a layer
         * @param {string} name name of a layout property
         * @param {string=} klass optional class specifier for the property
         * @returns {*} value for the layout propery
         */
        getLayoutProperty: function(layer, name) {
            return this.style.getLayoutProperty(layer, name);
        },

        /**
         * Get the Map&#039;s container as an HTML element
         * @returns {HTMLElement} container
         */
        getContainer: function() {
            return this._container;
        },

        /**
         * Get the Map&#039;s canvas as an HTML canvas
         * @returns {HTMLElement} canvas
         */
        getCanvas: function() {
            return this._canvas.getElement();
        },

        _move: function(zoom, rotate, pitch) {

            this.update(zoom).fire(&#039;move&#039;);

            if (zoom) this.fire(&#039;zoom&#039;);
            if (rotate) this.fire(&#039;rotate&#039;);
            if (pitch) this.fire(&#039;pitch&#039;);

            return this;
        },

        // map setup code
        _setupContainer: function() {
            var id = this.options.container;
            var container = this._container = typeof id === &#039;string&#039; ? document.getElementById(id) : id;
            if (container) container.classList.add(&#039;mapboxgl-map&#039;);
            this._canvas = new Canvas(this, container);
        },

        _setupControlPos: function() {
            var corners = this._controlCorners = {};
            var prefix = &#039;mapboxgl-ctrl-&#039;;
            var container = this.getContainer();

            function createCorner(pos) {
                var className = prefix + pos;
                corners[pos] = DOM.create(&#039;div&#039;, className, container);
            }

            if (container &amp;&amp; typeof document === &#039;object&#039;) {
                createCorner(&#039;top-left&#039;);
                createCorner(&#039;top-right&#039;);
                createCorner(&#039;bottom-left&#039;);
                createCorner(&#039;bottom-right&#039;);
            }
        },

        _setupPainter: function() {
            var gl = this._canvas.getWebGLContext(this.options.failIfMajorPerformanceCaveat);

            if (!gl) {
                console.error(&#039;Failed to initialize WebGL&#039;);
                return;
            }

            this.painter = new GLPainter(gl, this.transform);
        },

        _contextLost: function(event) {
            event.preventDefault();
            if (this._frameId) {
                browser.cancelFrame(this._frameId);
            }
        },

        _contextRestored: function() {
            this._setupPainter();
            this.resize();
            this.update();
        },

        /**
         * Is this map fully loaded? If the style isn&#039;t loaded
         * or it has a change to the sources or style that isn&#039;t
         * propagated to its style, return false.
         *
         * @returns {boolean} whether the map is loaded
         */
        loaded: function() {
            if (this._styleDirty || this._sourcesDirty)
                return false;
            if (this.style &amp;&amp; !this.style.loaded())
                return false;
            return true;
        },

        /**
         * Update this map&#039;s style and re-render the map.
         *
         * @param {Object} updateStyle new style
         * @returns {Map} this
         */
        update: function(updateStyle) {
            if (!this.style) return this;

            this._styleDirty = this._styleDirty || updateStyle;
            this._sourcesDirty = true;

            this._rerender();

            return this;
        },

        /**
         * Call when a (re-)render of the map is required, e.g. when the
         * user panned or zoomed,f or new data is available.
         * @returns {Map} this
         */
        render: function() {
            if (this.style &amp;&amp; this._styleDirty) {
                this._styleDirty = false;
                this.style._recalculate(this.transform.zoom);
            }

            if (this.style &amp;&amp; this._sourcesDirty &amp;&amp; !this._sourcesDirtyTimeout) {
                this._sourcesDirty = false;
                this._sourcesDirtyTimeout = setTimeout(function() {
                    this._sourcesDirtyTimeout = null;
                }.bind(this), 50);
                this.style._updateSources(this.transform);
            }

            this.painter.render(this.style, {
                debug: this.debug,
                vertices: this.vertices,
                rotating: this.rotating,
                zooming: this.zooming
            });

            this.fire(&#039;render&#039;);

            if (this.loaded() &amp;&amp; !this._loaded) {
                this._loaded = true;
                this.fire(&#039;load&#039;);
            }

            this._frameId = null;

            if (!this.animationLoop.stopped()) {
                this._styleDirty = true;
            }

            if (this._sourcesDirty || this._repaint || !this.animationLoop.stopped()) {
                this._rerender();
            }

            return this;
        },

        /**
         * Destroys the map&#039;s underlying resources, including web workers.
         * @returns {Map} this
         */
        remove: function() {
            if (this._hash) this._hash.remove();
            browser.cancelFrame(this._frameId);
            clearTimeout(this._sourcesDirtyTimeout);
            this.setStyle(null);
            return this;
        },

        _rerender: function() {
            if (this.style &amp;&amp; !this._frameId) {
                this._frameId = browser.frame(this.render);
            }
        },

        _forwardStyleEvent: function(e) {
            this.fire(&#039;style.&#039; + e.type, util.extend({style: e.target}, e));
        },

        _forwardSourceEvent: function(e) {
            this.fire(e.type, util.extend({style: e.target}, e));
        },

        _forwardLayerEvent: function(e) {
            this.fire(e.type, util.extend({style: e.target}, e));
        },

        _forwardTileEvent: function(e) {
            this.fire(e.type, util.extend({style: e.target}, e));
        },

        _onStyleLoad: function(e) {
            this.style._cascade(this._classes, {transition: false});
            this._forwardStyleEvent(e);
        },

        _onStyleChange: function(e) {
            this.update(true);
            this._forwardStyleEvent(e);
        },

        _onSourceAdd: function(e) {
            var source = e.source;
            if (source.onAdd)
                source.onAdd(this);
            this._forwardSourceEvent(e);
        },

        _onSourceRemove: function(e) {
            var source = e.source;
            if (source.onRemove)
                source.onRemove(this);
            this._forwardSourceEvent(e);
        },

        _onSourceUpdate: function(e) {
            this.update();
            this._forwardSourceEvent(e);
        }
    });

    util.extendAll(Map.prototype, {

        // debug code
        _debug: false,
        get debug() { return this._debug; },
        set debug(value) { this._debug = value; this.update(); },

        // show collision boxes
        _collisionDebug: false,
        get collisionDebug() { return this._collisionDebug; },
        set collisionDebug(value) {
            this._collisionDebug = value;
            for (var i in this.style.sources) {
                this.style.sources[i].reload();
            }
            this.update();
        },

        // continuous repaint
        _repaint: false,
        get repaint() { return this._repaint; },
        set repaint(value) { this._repaint = value; this.update(); },

        // show vertices
        _vertices: false,
        get vertices() { return this._vertices; },
        set vertices(value) { this._vertices = value; this.update(); }
    });

},{&quot;../geo/lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;,&quot;../geo/lat_lng_bounds&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng_bounds.js&quot;,&quot;../geo/transform&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/transform.js&quot;,&quot;../render/painter&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/render/painter.js&quot;,&quot;../style/animation_loop&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/animation_loop.js&quot;,&quot;../style/style&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/style/style.js&quot;,&quot;../util/browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;../util/canvas&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/canvas.js&quot;,&quot;../util/dom&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dom.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;,&quot;./control/attribution&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/control/attribution.js&quot;,&quot;./easings&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/easings.js&quot;,&quot;./handlers&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/handlers.js&quot;,&quot;./hash&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/hash.js&quot;,&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/ui/popup.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = Popup;

    var util = require(&#039;../util/util&#039;);
    var Evented = require(&#039;../util/evented&#039;);
    var DOM = require(&#039;../util/dom&#039;);
    var LatLng = require(&#039;../geo/lat_lng&#039;);

    /**
     * Creates a popup component
     * @class Popup
     * @param {Object} options
     * @param {Boolean} options.closeButton
     * @param {Boolean} options.closeOnClick
     * @example
     * var tooltip = new mapboxgl.Popup()
     *   .setLatLng(map.unproject(e.point))
     *   .setHTML(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;)
     *   .addTo(map);
     */
    function Popup(options) {
        util.setOptions(this, options);
        util.bindAll([
                &#039;_updatePosition&#039;,
                &#039;_onClickClose&#039;],
            this);
    }

    Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
        options: {
            closeButton: true,
            closeOnClick: true
        },

        /**
         * Attaches the popup to a map
         * @param {Map} map
         * @returns {Popup} `this`
         */
        addTo: function(map) {
            this._map = map;
            this._map.on(&#039;move&#039;, this._updatePosition);
            if (this.options.closeOnClick) {
                this._map.on(&#039;click&#039;, this._onClickClose);
            }
            this._update();
            return this;
        },

        /**
         * Removes the popup from the map
         * @example
         * var popup = new mapboxgl.Popup().addTo(map);
         * popup.remove();
         * @returns {Popup} `this`
         */
        remove: function() {
            if (this._container) {
                this._container.parentNode.removeChild(this._container);
            }

            if (this._map) {
                this._map.off(&#039;move&#039;, this._updatePosition);
                this._map.off(&#039;click&#039;, this._onClickClose);
                delete this._map;
            }

            return this;
        },

        /**
         * Get the current coordinates of popup element relative to map
         * @returns {LatLng}
         */
        getLatLng: function() {
            return this._latLng;
        },

        /**
         * Set the coordinates of a popup element to a map
         * @param {LatLng} latlng
         * @returns {Popup} `this`
         */
        setLatLng: function(latlng) {
            this._latLng = LatLng.convert(latlng);
            this._update();
            return this;
        },

        /**
         * Fill a popup element with text only content
         * @param {string} text
         * @returns {Popup} `this`
         */
        setText: function(text) {
            this._content = document.createTextNode(text);
            this._updateContent();
            return this;
        },

        /**
         * Fill a popup element with HTML content
         * @param {string} html
         * @returns {Popup} `this`
         */
        setHTML: function(html) {
            this._content = document.createDocumentFragment();

            var temp = document.createElement(&#039;body&#039;), child;
            temp.innerHTML = html;
            while (true) {
                child = temp.firstChild;
                if (!child) break;
                this._content.appendChild(child);
            }

            this._updateContent();
            return this;
        },

        _update: function() {
            if (!this._map) { return; }

            if (!this._container) {
                this._container = DOM.create(&#039;div&#039;, &#039;mapboxgl-popup&#039;, this._map.getContainer());

                this._tip     = DOM.create(&#039;div&#039;, &#039;mapboxgl-popup-tip&#039;,     this._container);
                this._wrapper = DOM.create(&#039;div&#039;, &#039;mapboxgl-popup-content&#039;, this._container);

                if (this.options.closeButton) {
                    this._closeButton = DOM.create(&#039;button&#039;, &#039;mapboxgl-popup-close-button&#039;, this._wrapper);
                    this._closeButton.innerHTML = &#039;&amp;#215;&#039;;
                    this._closeButton.addEventListener(&#039;click&#039;, this._onClickClose);
                }
            }

            this._updateContent();
            this._updatePosition();
        },

        _updateContent: function() {
            if (!this._content || !this._container) { return; }

            var node = this._wrapper;

            while (node.hasChildNodes()) {
                node.removeChild(node.firstChild);
            }

            node.appendChild(this._closeButton);
            node.appendChild(this._content);
        },

        _updatePosition: function() {
            if (!this._latLng || !this._container) { return; }

            var pos = this._map.project(this._latLng).round(),
                anchor = this.options.anchor;

            if (!anchor) {
                var width = this._container.offsetWidth,
                    height = this._container.offsetHeight;

                if (pos.y &lt; height) {
                    anchor = [&#039;top&#039;];
                } else if (pos.y &gt; this._map.transform.height - height) {
                    anchor = [&#039;bottom&#039;];
                } else {
                    anchor = [];
                }

                if (pos.x &lt; width / 2) {
                    anchor.push(&#039;left&#039;);
                } else if (pos.x &gt; this._map.transform.width - width / 2) {
                    anchor.push(&#039;right&#039;);
                }

                if (anchor.length === 0) {
                    anchor = &#039;bottom&#039;;
                } else {
                    anchor = anchor.join(&#039;-&#039;);
                }

                this.options.anchor = anchor;
            }

            var anchorTranslate = {
                &#039;top&#039;: &#039;translate(-50%,0)&#039;,
                &#039;top-left&#039;: &#039;translate(0,0)&#039;,
                &#039;top-right&#039;: &#039;translate(-100%,0)&#039;,
                &#039;bottom&#039;: &#039;translate(-50%,-100%)&#039;,
                &#039;bottom-left&#039;: &#039;translate(0,-100%)&#039;,
                &#039;bottom-right&#039;: &#039;translate(-100%,-100%)&#039;,
                &#039;left&#039;: &#039;translate(0,-50%)&#039;,
                &#039;right&#039;: &#039;translate(-100%,-50%)&#039;
            };

            var classList = this._container.classList;
            for (var key in anchorTranslate) {
                classList.remove(&#039;mapboxgl-popup-anchor-&#039; + key);
            }
            classList.add(&#039;mapboxgl-popup-anchor-&#039; + anchor);

            DOM.setTransform(this._container, anchorTranslate[anchor] + &#039; translate(&#039; + pos.x + &#039;px,&#039; + pos.y + &#039;px)&#039;);
        },

        _onClickClose: function() {
            this.remove();
        }
    });

},{&quot;../geo/lat_lng&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/geo/lat_lng.js&quot;,&quot;../util/dom&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dom.js&quot;,&quot;../util/evented&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;,&quot;../util/util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/actor.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = Actor;

    function Actor(target, parent) {
        this.target = target;
        this.parent = parent;
        this.callbacks = {};
        this.callbackID = 0;
        this.receive = this.receive.bind(this);
        this.target.addEventListener(&#039;message&#039;, this.receive, false);
    }

    Actor.prototype.receive = function(message) {
        var data = message.data,
            callback;

        if (data.type === &#039;&lt;response&gt;&#039;) {
            callback = this.callbacks[data.id];
            delete this.callbacks[data.id];
            callback(data.error || null, data.data);
        } else if (typeof data.id !== &#039;undefined&#039;) {
            var id = data.id;
            this.parent[data.type](data.data, function(err, data, buffers) {
                this.postMessage({
                    type: &#039;&lt;response&gt;&#039;,
                    id: String(id),
                    error: err ? String(err) : null,
                    data: data
                }, buffers);
            }.bind(this));
        } else {
            this.parent[data.type](data.data);
        }
    };

    Actor.prototype.send = function(type, data, callback, buffers) {
        var id = null;
        if (callback) this.callbacks[id = this.callbackID++] = callback;
        this.postMessage({ type: type, id: String(id), data: data }, buffers);
    };

    Actor.prototype.postMessage = function(message, transferList) {
        try {
            this.target.postMessage(message, transferList);
        } catch (e) {
            this.target.postMessage(message); // No support for transferList on IE
        }
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/ajax.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    exports.getJSON = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open(&#039;GET&#039;, url, true);
        xhr.onerror = function(e) {
            callback(e);
        };
        xhr.onload = function() {
            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 &amp;&amp; xhr.response) {
                var data;
                try {
                    data = JSON.parse(xhr.response);
                } catch (err) {
                    return callback(err);
                }
                callback(null, data);
            } else {
                callback(new Error(xhr.statusText));
            }
        };
        xhr.send();
        return xhr;
    };

    exports.getArrayBuffer = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open(&#039;GET&#039;, url, true);
        xhr.responseType = &#039;arraybuffer&#039;;
        xhr.onerror = function(e) {
            callback(e);
        };
        xhr.onload = function() {
            if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 &amp;&amp; xhr.response) {
                callback(null, xhr.response);
            } else {
                callback(new Error(xhr.statusText));
            }
        };
        xhr.send();
        return xhr;
    };

    exports.getImage = function(url, callback) {
        var img = new Image();
        img.crossOrigin = &#039;Anonymous&#039;;
        img.onload = function() {
            callback(null, img);
        };
        img.src = url;
        img.getData = function() {
            var canvas = document.createElement(&#039;canvas&#039;);
            var context = canvas.getContext(&#039;2d&#039;);
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, img.width, img.height).data;
        };
        return img;
    };

    exports.getVideo = function(urls, callback) {
        var video = document.createElement(&#039;video&#039;);
        video.crossOrigin = &#039;Anonymous&#039;;
        video.onloadstart = function() {
            callback(null, video);
        };
        for (var i = 0; i &lt; urls.length; i++) {
            var s = document.createElement(&#039;source&#039;);
            s.src = urls[i];
            video.appendChild(s);
        }
        video.getData = function() { return video; };
        return video;
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Canvas = require(&#039;./canvas&#039;);

    var frame = window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame;

    exports.frame = function(fn) {
        return frame(fn);
    };

    var cancel = window.cancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        window.msCancelAnimationFrame;

    exports.cancelFrame = function(id) {
        cancel(id);
    };

    exports.timed = function (fn, dur, ctx) {
        if (!dur) {
            fn.call(ctx, 1);
            return null;
        }

        var abort = false,
            start = window.performance ? window.performance.now() : Date.now();

        function tick(now) {
            if (abort) return;
            if (!window.performance) now = Date.now();

            if (now &gt;= start + dur) {
                fn.call(ctx, 1);
            } else {
                fn.call(ctx, (now - start) / dur);
                exports.frame(tick);
            }
        }

        exports.frame(tick);

        return function() { abort = true; };
    };

    /**
     * Test whether the basic JavaScript and DOM features required for Mapbox GL are present.
     * @param {Object} options
     * @param {Boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
     * @return {Boolean} Returns true if Mapbox GL should be expected to work, and false if not.
     */
    exports.supported = function(options) {

        var supports = [

            function() { return typeof window !== &#039;undefined&#039;; },

            function() { return typeof document !== &#039;undefined&#039;; },

            function () {
                return !!(Array.prototype &amp;&amp;
                    Array.prototype.every &amp;&amp;
                    Array.prototype.filter &amp;&amp;
                    Array.prototype.forEach &amp;&amp;
                    Array.prototype.indexOf &amp;&amp;
                    Array.prototype.lastIndexOf &amp;&amp;
                    Array.prototype.map &amp;&amp;
                    Array.prototype.some &amp;&amp;
                    Array.prototype.reduce &amp;&amp;
                    Array.prototype.reduceRight &amp;&amp;
                    Array.isArray);
            },

            function() {
                return !!(Function.prototype &amp;&amp; Function.prototype.bind) &amp;&amp;
                    !!(Object.keys &amp;&amp;
                        Object.create &amp;&amp;
                        Object.getPrototypeOf &amp;&amp;
                        Object.getOwnPropertyNames &amp;&amp;
                        Object.isSealed &amp;&amp;
                        Object.isFrozen &amp;&amp;
                        Object.isExtensible &amp;&amp;
                        Object.getOwnPropertyDescriptor &amp;&amp;
                        Object.defineProperty &amp;&amp;
                        Object.defineProperties &amp;&amp;
                        Object.seal &amp;&amp;
                        Object.freeze &amp;&amp;
                        Object.preventExtensions);
            },

            function() {
                return &#039;JSON&#039; in window &amp;&amp; &#039;parse&#039; in JSON &amp;&amp; &#039;stringify&#039; in JSON;
            },

            function() {
                return new Canvas().supportsWebGLContext((options &amp;&amp; options.failIfMajorPerformanceCaveat) || false);
            },

            function() { return &#039;Worker&#039; in window; }
        ];

        for (var i = 0; i &lt; supports.length; i++) {
            if (!supports[i]()) return false;
        }
        return true;
    };

    exports.hardwareConcurrency = navigator.hardwareConcurrency || 8;

    Object.defineProperty(exports, &#039;devicePixelRatio&#039;, {
        get: function() { return window.devicePixelRatio; }
    });

},{&quot;./canvas&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/canvas.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/canvas.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;../util&#039;);

    module.exports = Canvas;

    function Canvas(parent, container) {
        this.canvas = document.createElement(&#039;canvas&#039;);

        if (parent &amp;&amp; container) {
            this.canvas.style.position = &#039;absolute&#039;;
            this.canvas.classList.add(&#039;mapboxgl-canvas&#039;);
            if (parent.options.interactive) {
                this.canvas.classList.add(&#039;mapboxgl-interactive&#039;);
            }
            this.canvas.addEventListener(&#039;webglcontextlost&#039;, parent._contextLost.bind(parent), false);
            this.canvas.addEventListener(&#039;webglcontextrestored&#039;, parent._contextRestored.bind(parent), false);
            this.canvas.setAttribute(&#039;tabindex&#039;, 0);
            container.appendChild(this.canvas);
        }
    }

    Canvas.prototype.resize = function(width, height) {
        var pixelRatio = window.devicePixelRatio || 1;

        // Request the required canvas size taking the pixelratio into account.
        this.canvas.width = pixelRatio * width;
        this.canvas.height = pixelRatio * height;

        // Maintain the same canvas size, potentially downscaling it for HiDPI displays
        this.canvas.style.width = width + &#039;px&#039;;
        this.canvas.style.height = height + &#039;px&#039;;
    };

    Canvas.prototype._contextAttributes = {
        antialias: false,
        alpha: true,
        stencil: true,
        depth: false
    };

    Canvas.prototype.getWebGLContext = function(failIfMajorPerformanceCaveat) {
        var attributes = util.inherit(this._contextAttributes, {
            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
        });

        return this.canvas.getContext(&#039;webgl&#039;, attributes) ||
            this.canvas.getContext(&#039;experimental-webgl&#039;, attributes);
    };

    Canvas.prototype.supportsWebGLContext = function(failIfMajorPerformanceCaveat) {
        var attributes = util.inherit(this._contextAttributes, {
            failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat
        });

        if (&#039;probablySupportsContext&#039; in this.canvas) {
            return this.canvas.probablySupportsContext(&#039;webgl&#039;, attributes) ||
                this.canvas.probablySupportsContext(&#039;experimental-webgl&#039;, attributes);
        } else if (&#039;supportsContext&#039; in this.canvas) {
            return this.canvas.supportsContext(&#039;webgl&#039;, attributes) ||
                this.canvas.supportsContext(&#039;experimental-webgl&#039;, attributes);
        }

        return !!window.WebGLRenderingContext &amp;&amp; !!this.getWebGLContext(failIfMajorPerformanceCaveat);
    };

    Canvas.prototype.getElement = function() {
        return this.canvas;
    };

},{&quot;../util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dispatcher.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Actor = require(&#039;../actor&#039;);

    var scripts = document.getElementsByTagName(&quot;script&quot;);
    var workerFile = (document.currentScript || scripts[scripts.length - 1]).getAttribute(&#039;src&#039;);
    var absolute = workerFile.indexOf(&#039;http&#039;) !== -1;

    module.exports = Dispatcher;

    function Dispatcher(length, parent) {
        this.actors = [];
        this.currentActor = 0;

        var url, blob, i;

        for (i = 0; i &lt; length; i++) {
            // due to cross domain issues we can&#039;t load it directly with the url,
            // so create a blob and object url and load that
            if (absolute) {
                blob = new Blob([&#039;importScripts(&quot;&#039; + workerFile + &#039;&quot;);&#039;], {type: &#039;application/javascript&#039;});
                url = window.URL.createObjectURL(blob);
            } else {
                url = workerFile;
            }

            var worker = new window.Worker(url);
            var actor = new Actor(worker, parent);
            actor.name = &quot;Worker &quot; + i;
            this.actors.push(actor);
        }
    }

    Dispatcher.prototype = {
        broadcast: function(type, data) {
            for (var i = 0; i &lt; this.actors.length; i++) {
                this.actors[i].send(type, data);
            }
        },

        send: function(type, data, callback, targetID, buffers) {
            if (typeof targetID !== &#039;number&#039; || isNaN(targetID)) {
                // Use round robin to send requests to web workers.
                targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
            }

            this.actors[targetID].send(type, data, callback, buffers);
            return targetID;
        },

        remove: function() {
            for (var i = 0; i &lt; this.actors.length; i++) {
                this.actors[i].target.terminate();
            }
            this.actors = [];
        }
    };

},{&quot;../actor&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/actor.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/dom.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    exports.create = function (tagName, className, container) {
        var el = document.createElement(tagName);
        if (className) el.className = className;
        if (container) container.appendChild(el);
        return el;
    };

    var docStyle = document.documentElement.style;

    function testProp(props) {
        for (var i = 0; i &lt; props.length; i++) {
            if (props[i] in docStyle) {
                return props[i];
            }
        }
    }

    var selectProp = testProp([&#039;userSelect&#039;, &#039;MozUserSelect&#039;, &#039;WebkitUserSelect&#039;, &#039;msUserSelect&#039;]),
        userSelect;
    exports.disableDrag = function () {
        if (selectProp) {
            userSelect = docStyle[selectProp];
            docStyle[selectProp] = &#039;none&#039;;
        }
    };
    exports.enableDrag = function () {
        if (selectProp) {
            docStyle[selectProp] = userSelect;
        }
    };

    var transformProp = testProp([&#039;transform&#039;, &#039;WebkitTransform&#039;]);
    exports.setTransform = function(el, value) {
        el.style[transformProp] = value;
    };

// Suppress the next click, but only if it&#039;s immediate.
    function suppressClick(e) {
        e.preventDefault();
        e.stopPropagation();
        window.removeEventListener(&#039;click&#039;, suppressClick, true);
    }
    exports.suppressClick = function() {
        window.addEventListener(&#039;click&#039;, suppressClick, true);
        window.setTimeout(function() {
            window.removeEventListener(&#039;click&#039;, suppressClick, true);
        }, 0);
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/config.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = {
        HTTP_URL: &#039;http://a.tiles.mapbox.com&#039;,
        HTTPS_URL: &#039;https://a.tiles.mapbox.com&#039;,
        FORCE_HTTPS: true,
        REQUIRE_ACCESS_TOKEN: true
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/evented.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var util = require(&#039;./util&#039;);

    /**
     * Methods mixed in to other classes for event capabilities.
     * @mixin Evented
     */
    var Evented = {

        /**
         * Subscribe to a specified event with a listener function the latter gets the data object that was passed to `fire` and additionally `target` and `type` properties
         *
         * @param {String} type Event type
         * @param {Function} listener Function to be called when the event is fired
         */
        on: function(type, fn) {
            this._events = this._events || {};
            this._events[type] = this._events[type] || [];
            this._events[type].push(fn);

            return this;
        },

        /**
         * Remove a event listener
         *
         * @param {String} [type] Event type. If none is specified, remove all listeners
         * @param {Function} [listener] Function to be called when the event is fired. If none is specified all listeners are removed
         */
        off: function(type, fn) {
            if (!type) {
                // clear all listeners if no arguments specified
                delete this._events;
                return this;
            }

            if (!this.listens(type)) return this;

            if (fn) {
                var idx = this._events[type].indexOf(fn);
                if (idx &gt;= 0) {
                    this._events[type].splice(idx, 1);
                }
                if (!this._events[type].length) {
                    delete this._events[type];
                }
            } else {
                delete this._events[type];
            }

            return this;
        },

        /**
         * Call a function once when an event has fired
         *
         * @param {String} type Event type.
         * @param {Function} listener Function to be called once when the event is fired
         */
        once: function(type, fn) {
            var wrapper = function(data) {
                this.off(type, wrapper);
                fn.call(this, data);
            }.bind(this);
            this.on(type, wrapper);
            return this;
        },

        /**
         * Fire event of a given string type with the given data object
         *
         * @param {String} type The event name
         * @param {Object} [data] Optional data passed down to the event object
         * @returns {Boolean} Returns true if the object listens to an event of a particular type
         */
        fire: function(type, data) {
            if (!this.listens(type)) return this;

            data = util.extend({}, data);
            util.extend(data, {type: type, target: this});

            // make sure adding/removing listeners inside other listeners won&#039;t cause infinite loop
            var listeners = this._events[type].slice();

            for (var i = 0; i &lt; listeners.length; i++) {
                listeners[i].call(this, data);
            }

            return this;
        },

        /**
         * Check if an event is registered to a type
         * @returns {Boolean} Returns true if the object listens to an event of a particular type
         */
        listens: function(type) {
            return !!(this._events &amp;&amp; this._events[type]);
        }
    };

    module.exports = Evented;

},{&quot;./util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/glyphs.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = Glyphs;

    function Glyphs(pbf, end) {
        this.stacks = pbf.readFields(readFontstacks, [], end);
    }

    function readFontstacks(tag, stacks, pbf) {
        if (tag === 1) {
            var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
            stacks.push(fontstack);
        }
    }

    function readFontstack(tag, fontstack, pbf) {
        if (tag === 1) fontstack.name = pbf.readString();
        else if (tag === 2) fontstack.range = pbf.readString();
        else if (tag === 3) {
            var glyph = pbf.readMessage(readGlyph, {});
            fontstack.glyphs[glyph.id] = glyph;
        }
    }

    function readGlyph(tag, glyph, pbf) {
        if (tag === 1) glyph.id = pbf.readVarint();
        else if (tag === 2) glyph.bitmap = pbf.readBytes();
        else if (tag === 3) glyph.width = pbf.readVarint();
        else if (tag === 4) glyph.height = pbf.readVarint();
        else if (tag === 5) glyph.left = pbf.readSVarint();
        else if (tag === 6) glyph.top = pbf.readSVarint();
        else if (tag === 7) glyph.advance = pbf.readVarint();
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/interpolate.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = interpolate;

    function interpolate(a, b, t) {
        return (a * (1 - t)) + (b * t);
    }

    interpolate.number = interpolate;

    interpolate.vec2 = function(from, to, t) {
        return [
            interpolate(from[0], to[0], t),
            interpolate(from[1], to[1], t)
        ];
    };

    /*
     * Interpolate between two colors given as 4-element arrays.
     *
     * @param {Color} from
     * @param {Color} to
     * @param {Number} t interpolation factor between 0 and 1
     * @returns {Color} interpolated color
     */
    interpolate.color = function(from, to, t) {
        return [
            interpolate(from[0], to[0], t),
            interpolate(from[1], to[1], t),
            interpolate(from[2], to[2], t),
            interpolate(from[3], to[3], t)
        ];
    };

    interpolate.array = function(from, to, t) {
        return from.map(function(d, i) {
            return interpolate(d, to[i], t);
        });
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mapbox.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var config = require(&#039;./config&#039;);
    var browser = require(&#039;./browser&#039;);

    function normalizeURL(url, pathPrefix, accessToken) {
        accessToken = accessToken || config.ACCESS_TOKEN;

        if (!accessToken &amp;&amp; config.REQUIRE_ACCESS_TOKEN) {
            throw new Error(&#039;An API access token is required to use Mapbox GL. &#039; +
                &#039;See https://www.mapbox.com/developers/api/#access-tokens&#039;);
        }

        var https = config.FORCE_HTTPS ||
            (typeof document !== &#039;undefined&#039; &amp;&amp; document.location.protocol === &#039;https:&#039;);

        url = url.replace(/^mapbox:\/\//, (https ? config.HTTPS_URL : config.HTTP_URL) + pathPrefix);
        url += url.indexOf(&#039;?&#039;) !== -1 ? &#039;&amp;access_token=&#039; : &#039;?access_token=&#039;;

        if (config.REQUIRE_ACCESS_TOKEN) {
            if (accessToken[0] === &#039;s&#039;) {
                throw new Error(&#039;Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). &#039; +
                    &#039;See https://www.mapbox.com/developers/api/#access-tokens&#039;);
            }

            url += accessToken;
        }

        return url;
    }

    module.exports.normalizeStyleURL = function(url, accessToken) {
        var user = url.match(/^mapbox:\/\/([^.]+)/);
        if (!user)
            return url;

        return normalizeURL(url, &#039;/styles/v1/&#039; + user[1] + &#039;/&#039;, accessToken);
    };

    module.exports.normalizeSourceURL = function(url, accessToken) {
        if (!url.match(/^mapbox:\/\//))
            return url;

        url = normalizeURL(url + &#039;.json&#039;, &#039;/v4/&#039;, accessToken);

        // TileJSON requests need a secure flag appended to their URLs so
        // that the server knows to send SSL-ified resource references.
        if (url.indexOf(&#039;https&#039;) === 0)
            url += &#039;&amp;secure&#039;;

        return url;
    };

    module.exports.normalizeGlyphsURL = function(url, accessToken) {
        if (!url.match(/^mapbox:\/\//))
            return url;

        return normalizeURL(url, &#039;/v4/&#039;, accessToken);
    };

    module.exports.normalizeTileURL = function(url, sourceUrl) {
        if (!sourceUrl || !sourceUrl.match(/^mapbox:\/\//))
            return url;
        return url.replace(/\.((?:png|jpg)\d*)(?=$|\?)/, browser.devicePixelRatio &gt;= 2 ? &#039;@2x.$1&#039; : &#039;.$1&#039;);
    };

},{&quot;./browser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/browser/browser.js&quot;,&quot;./config&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/config.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/mru_cache.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    /*
     * A [most-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
     * with hash lookup made possible by keeping a list of keys in parallel to
     * an array of dictionary of values
     */
    module.exports = MRUCache;
    function MRUCache(length, onRemove) {
        this.max = length;
        this.onRemove = onRemove;
        this.reset();
    }

    /*
     * Clears the cache
     */
    MRUCache.prototype.reset = function() {
        for (var key in this.list) {
            this.onRemove(this.list[key]);
        }

        this.list = {};
        this.order = [];

        return this;
    };

    /*
     * Add a key, value combination to the cache, trimming its size if this pushes
     * it over max length.
     */
    MRUCache.prototype.add = function(key, data) {
        this.list[key] = data;
        this.order.push(key);

        if (this.order.length &gt; this.max) {
            var removedData = this.get(this.order[0]);
            if (removedData) this.onRemove(removedData);
        }

        return this;
    };

    /*
     * Determine whether the value attached to `key` is present
     */
    MRUCache.prototype.has = function(key) {
        return key in this.list;
    };

    /*
     * List all keys in the cache
     */
    MRUCache.prototype.keys = function() {
        return this.order;
    };

    /*
     * Get the value attached to a specific key. If the key is not found,
     * returns `null`
     */
    MRUCache.prototype.get = function(key) {
        if (!this.has(key)) { return null; }

        var data = this.list[key];

        delete this.list[key];
        this.order.splice(this.order.indexOf(key), 1);

        return data;
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/token.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = resolveTokens;

    function resolveTokens(properties, text) {
        return text.replace(/{([^{}()\[\]&lt;&gt;$=:;.,^]+)}/g, function(match, key) {
            return key in properties ? properties[key] : &#039;&#039;;
        });
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/util/util.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var UnitBezier = require(&#039;unitbezier&#039;);

    /**
     * Given a value `t` that varies between 0 and 1, return
     * an interpolation function that eases between 0 and 1 in a pleasing
     * cubic in-out fashion.
     *
     * @param {number} t input
     * @returns {number} input
     */
    exports.easeCubicInOut = function (t) {
        if (t &lt;= 0) return 0;
        if (t &gt;= 1) return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t &lt; 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    };

    /**
     * Given given (x, y), (x1, y1) control points for a bezier curve,
     * return a function that interpolates along that curve.
     *
     * @param {number} p1x control point 1 x coordinate
     * @param {number} p1y control point 1 y coordinate
     * @param {number} p2x control point 2 x coordinate
     * @param {number} p2y control point 2 y coordinate
     * @returns {Function} interpolator: receives number value, returns
     * number value.
     */
    exports.bezier = function(p1x, p1y, p2x, p2y) {
        var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
        return function(t) {
            return bezier.solve(t);
        };
    };

    /**
     * A default bezier-curve powered easing function with
     * control points (0.25, 0.1) and (0.25, 1)
     *
     * @param {number} t
     * @returns {number} output
     */
    exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

    /**
     * Given a four-element array of numbers that represents a color in
     * RGBA, return a version for which the RGB components are multiplied
     * by the A (alpha) component
     *
     * @param {Number&lt;Array&gt;} c color array
     * @returns {Number&lt;Array&gt;} premultiplied color array
     */
    exports.premultiply = function (c) {
        c[0] *= c[3];
        c[1] *= c[3];
        c[2] *= c[3];
        return c;
    };

    /**
     * constrain n to the given range via min + max
     *
     * @param {Number} n value
     * @param {Number} min the minimum value to be returned
     * @param {Number} max the maximum value to be returned
     * @returns {Number} the clamped value
     */
    exports.clamp = function (n, min, max) {
        return Math.min(max, Math.max(min, n));
    };

    /*
     * constrain n to the given range via modular arithmetic
     * @param {Number} n
     * @param {Number} min
     * @param {Number} max
     * @returns {Number} constrained number
     */
    exports.wrap = function (n, min, max) {
        var d = max - min;
        return n === max ? n : ((n - min) % d + d) % d + min;
    };

    /*
     * return the first non-null and non-undefined argument to this function.
     * @returns {*} argument
     */
    exports.coalesce = function() {
        for (var i = 0; i &lt; arguments.length; i++) {
            var arg = arguments[i];
            if (arg !== null &amp;&amp; arg !== undefined)
                return arg;
        }
    };

    /*
     * Call an asynchronous function on an array of arguments,
     * calling `callback` once all calls complete.
     *
     * @param {Array&lt;*&gt;} array input to each call of the async function.
     * @param {Function} fn an async function with signature (data, callback)
     * @param {Function} callback a callback run after all async work is done.
     * called with no arguments
     * @returns {undefined}
     */
    exports.asyncEach = function (array, fn, callback) {
        var remaining = array.length;
        if (remaining === 0) return callback();
        function check() { if (--remaining === 0) callback(); }
        for (var i = 0; i &lt; array.length; i++) fn(array[i], check);
    };

    /*
     * Compute the difference between the keys in one object and the keys
     * in another object.
     *
     * @param {Object} obj
     * @param {Object} other
     * @returns {Array&lt;string&gt;} keys difference
     */
    exports.keysDifference = function (obj, other) {
        var difference = [];
        for (var i in obj) {
            if (!(i in other)) {
                difference.push(i);
            }
        }
        return difference;
    };

    /**
     * Given a destination object and optionally many source objects,
     * copy all properties from the source objects into the destination.
     * The last source object given overrides properties from previous
     * source objects.
     * @param {Object} dest destination object
     * @param {...Object} sources sources from which properties are pulled
     * @returns {Object} dest
     */
    exports.extend = function (dest) {
        for (var i = 1; i &lt; arguments.length; i++) {
            var src = arguments[i];
            for (var k in src) {
                dest[k] = src[k];
            }
        }
        return dest;
    };

    /**
     * Extend a destination object with all properties of the src object,
     * using defineProperty instead of simple assignment.
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    exports.extendAll = function (dest, src) {
        for (var i in src) {
            Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
        }
        return dest;
    };

    /**
     * Extend a parent&#039;s prototype with all properties in a properties
     * object.
     *
     * @param {Object} parent
     * @param {Object} props
     * @returns {Object}
     */
    exports.inherit = function (parent, props) {
        var parentProto = typeof parent === &#039;function&#039; ? parent.prototype : parent,
            proto = Object.create(parentProto);
        exports.extendAll(proto, props);
        return proto;
    };

    /**
     * Given an object and a number of properties as strings, return version
     * of that object with only those properties.
     *
     * @param {Object} src the object
     * @param {Array&lt;string&gt;} properties an array of property names chosen
     * to appear on the resulting object.
     * @returns {Object} object with limited properties.
     * @example
     * var foo = { name: &#039;Charlie&#039;, age: 10 };
     * var justName = pick(foo, [&#039;name&#039;]);
     * // justName = { name: &#039;Charlie&#039; }
     */
    exports.pick = function (src, properties) {
        var result = {};
        for (var i = 0; i &lt; properties.length; i++) {
            var k = properties[i];
            if (k in src) {
                result[k] = src[k];
            }
        }
        return result;
    };

    var id = 1;

    /**
     * Return a unique numeric id, starting at 1 and incrementing with
     * each call.
     *
     * @returns {Number} unique numeric id.
     */
    exports.uniqueId = function () {
        return id++;
    };

    /**
     * Create a version of `fn` that only fires once every `time` millseconds.
     *
     * @param {Function} fn the function to be throttled
     * @param {Number} time millseconds required between function calls
     * @param {*} context the value of `this` with which the function is called
     * @returns {Function} debounced function
     */
    exports.throttle = function (fn, time, context) {
        var lock, args, wrapperFn, later;

        later = function () {
            // reset lock and call if queued
            lock = false;
            if (args) {
                wrapperFn.apply(context, args);
                args = false;
            }
        };

        wrapperFn = function () {
            if (lock) {
                // called too soon, queue to call later
                args = arguments;

            } else {
                // call and lock until later
                fn.apply(context, arguments);
                setTimeout(later, time);
                lock = true;
            }
        };

        return wrapperFn;
    };

    /**
     * Create a version of `fn` that is only called `time` milliseconds
     * after its last invocation
     *
     * @param {Function} fn the function to be debounced
     * @param {Number} time millseconds after which the function will be invoked
     * @returns {Function} debounced function
     */
    exports.debounce = function(fn, time) {
        var timer, args;

        return function() {
            args = arguments;
            clearTimeout(timer);

            timer = setTimeout(function() {
                fn.apply(null, args);
            }, time);
        };
    };

    /**
     * Given an array of member function names as strings, replace all of them
     * with bound versions that will always refer to `context` as `this`. This
     * is useful for classes where otherwise event bindings would reassign
     * `this` to the evented object or some other value: this lets you ensure
     * the `this` value always.
     *
     * @param {Array&lt;string&gt;} fns list of member function names
     * @param {*} context the context value
     * @returns {undefined} changes functions in-place
     * @example
     * function MyClass() {
 *   bindAll([&#039;ontimer&#039;], this);
 *   this.name = &#039;Tom&#039;;
 * }
     * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
     * var myClass = new MyClass();
     * setTimeout(myClass.ontimer, 100);
     */
    exports.bindAll = function(fns, context) {
        fns.forEach(function(fn) {
            context[fn] = context[fn].bind(context);
        });
    };

    /**
     * Set the &#039;options&#039; property on `obj` with properties
     * from the `options` argument. Properties in the `options`
     * object will override existing properties.
     *
     * @param {Object} obj destination object
     * @param {Object} options object of override options
     * @returns {Object} derived options object.
     */
    exports.setOptions = function(obj, options) {
        if (!obj.hasOwnProperty(&#039;options&#039;)) {
            obj.options = obj.options ? Object.create(obj.options) : {};
        }
        for (var i in options) {
            obj.options[i] = options[i];
        }
        return obj.options;
    };

},{&quot;unitbezier&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/unitbezier/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/csscolorparser/csscolorparser.js&quot;:[function(require,module,exports){
// (c) Dean McNamee &lt;dean@gmail.com&gt;, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
    var kCSSColorTable = {
        &quot;transparent&quot;: [0,0,0,0], &quot;aliceblue&quot;: [240,248,255,1],
        &quot;antiquewhite&quot;: [250,235,215,1], &quot;aqua&quot;: [0,255,255,1],
        &quot;aquamarine&quot;: [127,255,212,1], &quot;azure&quot;: [240,255,255,1],
        &quot;beige&quot;: [245,245,220,1], &quot;bisque&quot;: [255,228,196,1],
        &quot;black&quot;: [0,0,0,1], &quot;blanchedalmond&quot;: [255,235,205,1],
        &quot;blue&quot;: [0,0,255,1], &quot;blueviolet&quot;: [138,43,226,1],
        &quot;brown&quot;: [165,42,42,1], &quot;burlywood&quot;: [222,184,135,1],
        &quot;cadetblue&quot;: [95,158,160,1], &quot;chartreuse&quot;: [127,255,0,1],
        &quot;chocolate&quot;: [210,105,30,1], &quot;coral&quot;: [255,127,80,1],
        &quot;cornflowerblue&quot;: [100,149,237,1], &quot;cornsilk&quot;: [255,248,220,1],
        &quot;crimson&quot;: [220,20,60,1], &quot;cyan&quot;: [0,255,255,1],
        &quot;darkblue&quot;: [0,0,139,1], &quot;darkcyan&quot;: [0,139,139,1],
        &quot;darkgoldenrod&quot;: [184,134,11,1], &quot;darkgray&quot;: [169,169,169,1],
        &quot;darkgreen&quot;: [0,100,0,1], &quot;darkgrey&quot;: [169,169,169,1],
        &quot;darkkhaki&quot;: [189,183,107,1], &quot;darkmagenta&quot;: [139,0,139,1],
        &quot;darkolivegreen&quot;: [85,107,47,1], &quot;darkorange&quot;: [255,140,0,1],
        &quot;darkorchid&quot;: [153,50,204,1], &quot;darkred&quot;: [139,0,0,1],
        &quot;darksalmon&quot;: [233,150,122,1], &quot;darkseagreen&quot;: [143,188,143,1],
        &quot;darkslateblue&quot;: [72,61,139,1], &quot;darkslategray&quot;: [47,79,79,1],
        &quot;darkslategrey&quot;: [47,79,79,1], &quot;darkturquoise&quot;: [0,206,209,1],
        &quot;darkviolet&quot;: [148,0,211,1], &quot;deeppink&quot;: [255,20,147,1],
        &quot;deepskyblue&quot;: [0,191,255,1], &quot;dimgray&quot;: [105,105,105,1],
        &quot;dimgrey&quot;: [105,105,105,1], &quot;dodgerblue&quot;: [30,144,255,1],
        &quot;firebrick&quot;: [178,34,34,1], &quot;floralwhite&quot;: [255,250,240,1],
        &quot;forestgreen&quot;: [34,139,34,1], &quot;fuchsia&quot;: [255,0,255,1],
        &quot;gainsboro&quot;: [220,220,220,1], &quot;ghostwhite&quot;: [248,248,255,1],
        &quot;gold&quot;: [255,215,0,1], &quot;goldenrod&quot;: [218,165,32,1],
        &quot;gray&quot;: [128,128,128,1], &quot;green&quot;: [0,128,0,1],
        &quot;greenyellow&quot;: [173,255,47,1], &quot;grey&quot;: [128,128,128,1],
        &quot;honeydew&quot;: [240,255,240,1], &quot;hotpink&quot;: [255,105,180,1],
        &quot;indianred&quot;: [205,92,92,1], &quot;indigo&quot;: [75,0,130,1],
        &quot;ivory&quot;: [255,255,240,1], &quot;khaki&quot;: [240,230,140,1],
        &quot;lavender&quot;: [230,230,250,1], &quot;lavenderblush&quot;: [255,240,245,1],
        &quot;lawngreen&quot;: [124,252,0,1], &quot;lemonchiffon&quot;: [255,250,205,1],
        &quot;lightblue&quot;: [173,216,230,1], &quot;lightcoral&quot;: [240,128,128,1],
        &quot;lightcyan&quot;: [224,255,255,1], &quot;lightgoldenrodyellow&quot;: [250,250,210,1],
        &quot;lightgray&quot;: [211,211,211,1], &quot;lightgreen&quot;: [144,238,144,1],
        &quot;lightgrey&quot;: [211,211,211,1], &quot;lightpink&quot;: [255,182,193,1],
        &quot;lightsalmon&quot;: [255,160,122,1], &quot;lightseagreen&quot;: [32,178,170,1],
        &quot;lightskyblue&quot;: [135,206,250,1], &quot;lightslategray&quot;: [119,136,153,1],
        &quot;lightslategrey&quot;: [119,136,153,1], &quot;lightsteelblue&quot;: [176,196,222,1],
        &quot;lightyellow&quot;: [255,255,224,1], &quot;lime&quot;: [0,255,0,1],
        &quot;limegreen&quot;: [50,205,50,1], &quot;linen&quot;: [250,240,230,1],
        &quot;magenta&quot;: [255,0,255,1], &quot;maroon&quot;: [128,0,0,1],
        &quot;mediumaquamarine&quot;: [102,205,170,1], &quot;mediumblue&quot;: [0,0,205,1],
        &quot;mediumorchid&quot;: [186,85,211,1], &quot;mediumpurple&quot;: [147,112,219,1],
        &quot;mediumseagreen&quot;: [60,179,113,1], &quot;mediumslateblue&quot;: [123,104,238,1],
        &quot;mediumspringgreen&quot;: [0,250,154,1], &quot;mediumturquoise&quot;: [72,209,204,1],
        &quot;mediumvioletred&quot;: [199,21,133,1], &quot;midnightblue&quot;: [25,25,112,1],
        &quot;mintcream&quot;: [245,255,250,1], &quot;mistyrose&quot;: [255,228,225,1],
        &quot;moccasin&quot;: [255,228,181,1], &quot;navajowhite&quot;: [255,222,173,1],
        &quot;navy&quot;: [0,0,128,1], &quot;oldlace&quot;: [253,245,230,1],
        &quot;olive&quot;: [128,128,0,1], &quot;olivedrab&quot;: [107,142,35,1],
        &quot;orange&quot;: [255,165,0,1], &quot;orangered&quot;: [255,69,0,1],
        &quot;orchid&quot;: [218,112,214,1], &quot;palegoldenrod&quot;: [238,232,170,1],
        &quot;palegreen&quot;: [152,251,152,1], &quot;paleturquoise&quot;: [175,238,238,1],
        &quot;palevioletred&quot;: [219,112,147,1], &quot;papayawhip&quot;: [255,239,213,1],
        &quot;peachpuff&quot;: [255,218,185,1], &quot;peru&quot;: [205,133,63,1],
        &quot;pink&quot;: [255,192,203,1], &quot;plum&quot;: [221,160,221,1],
        &quot;powderblue&quot;: [176,224,230,1], &quot;purple&quot;: [128,0,128,1],
        &quot;red&quot;: [255,0,0,1], &quot;rosybrown&quot;: [188,143,143,1],
        &quot;royalblue&quot;: [65,105,225,1], &quot;saddlebrown&quot;: [139,69,19,1],
        &quot;salmon&quot;: [250,128,114,1], &quot;sandybrown&quot;: [244,164,96,1],
        &quot;seagreen&quot;: [46,139,87,1], &quot;seashell&quot;: [255,245,238,1],
        &quot;sienna&quot;: [160,82,45,1], &quot;silver&quot;: [192,192,192,1],
        &quot;skyblue&quot;: [135,206,235,1], &quot;slateblue&quot;: [106,90,205,1],
        &quot;slategray&quot;: [112,128,144,1], &quot;slategrey&quot;: [112,128,144,1],
        &quot;snow&quot;: [255,250,250,1], &quot;springgreen&quot;: [0,255,127,1],
        &quot;steelblue&quot;: [70,130,180,1], &quot;tan&quot;: [210,180,140,1],
        &quot;teal&quot;: [0,128,128,1], &quot;thistle&quot;: [216,191,216,1],
        &quot;tomato&quot;: [255,99,71,1], &quot;turquoise&quot;: [64,224,208,1],
        &quot;violet&quot;: [238,130,238,1], &quot;wheat&quot;: [245,222,179,1],
        &quot;white&quot;: [255,255,255,1], &quot;whitesmoke&quot;: [245,245,245,1],
        &quot;yellow&quot;: [255,255,0,1], &quot;yellowgreen&quot;: [154,205,50,1]}

    function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
        return i &lt; 0 ? 0 : i &gt; 255 ? 255 : i;
    }

    function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
        return f &lt; 0 ? 0 : f &gt; 1 ? 1 : f;
    }

    function parse_css_int(str) {  // int or percentage.
        if (str[str.length - 1] === &#039;%&#039;)
            return clamp_css_byte(parseFloat(str) / 100 * 255);
        return clamp_css_byte(parseInt(str));
    }

    function parse_css_float(str) {  // float or percentage.
        if (str[str.length - 1] === &#039;%&#039;)
            return clamp_css_float(parseFloat(str) / 100);
        return clamp_css_float(parseFloat(str));
    }

    function css_hue_to_rgb(m1, m2, h) {
        if (h &lt; 0) h += 1;
        else if (h &gt; 1) h -= 1;

        if (h * 6 &lt; 1) return m1 + (m2 - m1) * h * 6;
        if (h * 2 &lt; 1) return m2;
        if (h * 3 &lt; 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
        return m1;
    }

    function parseCSSColor(css_str) {
        // Remove all whitespace, not compliant, but should just be more accepting.
        var str = css_str.replace(/ /g, &#039;&#039;).toLowerCase();

        // Color keywords (and transparent) lookup.
        if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

        // #abc and #abc123 syntax.
        if (str[0] === &#039;#&#039;) {
            if (str.length === 4) {
                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
                if (!(iv &gt;= 0 &amp;&amp; iv &lt;= 0xfff)) return null;  // Covers NaN.
                return [((iv &amp; 0xf00) &gt;&gt; 4) | ((iv &amp; 0xf00) &gt;&gt; 8),
                        (iv &amp; 0xf0) | ((iv &amp; 0xf0) &gt;&gt; 4),
                        (iv &amp; 0xf) | ((iv &amp; 0xf) &lt;&lt; 4),
                    1];
            } else if (str.length === 7) {
                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
                if (!(iv &gt;= 0 &amp;&amp; iv &lt;= 0xffffff)) return null;  // Covers NaN.
                return [(iv &amp; 0xff0000) &gt;&gt; 16,
                        (iv &amp; 0xff00) &gt;&gt; 8,
                        iv &amp; 0xff,
                    1];
            }

            return null;
        }

        var op = str.indexOf(&#039;(&#039;), ep = str.indexOf(&#039;)&#039;);
        if (op !== -1 &amp;&amp; ep + 1 === str.length) {
            var fname = str.substr(0, op);
            var params = str.substr(op+1, ep-(op+1)).split(&#039;,&#039;);
            var alpha = 1;  // To allow case fallthrough.
            switch (fname) {
                case &#039;rgba&#039;:
                    if (params.length !== 4) return null;
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case &#039;rgb&#039;:
                    if (params.length !== 3) return null;
                    return [parse_css_int(params[0]),
                        parse_css_int(params[1]),
                        parse_css_int(params[2]),
                        alpha];
                case &#039;hsla&#039;:
                    if (params.length !== 4) return null;
                    alpha = parse_css_float(params.pop());
                // Fall through.
                case &#039;hsl&#039;:
                    if (params.length !== 3) return null;
                    var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
                    // NOTE(deanm): According to the CSS spec s/l should only be
                    // percentages, but we don&#039;t bother and let float or percentage.
                    var s = parse_css_float(params[1]);
                    var l = parse_css_float(params[2]);
                    var m2 = l &lt;= 0.5 ? l * (s + 1) : l + s - l * s;
                    var m1 = l * 2 - m2;
                    return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                        clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                        clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                        alpha];
                default:
                    return null;
            }
        }

        return null;
    }

    try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/feature-filter/index.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var VectorTileFeatureTypes = [&#039;Unknown&#039;, &#039;Point&#039;, &#039;LineString&#039;, &#039;Polygon&#039;];

    function infix(operator) {
        return function(_, key, value) {
            if (key === &#039;$type&#039;) {
                return &#039;t&#039; + operator + VectorTileFeatureTypes.indexOf(value);
            } else {
                return &#039;p[&#039; + JSON.stringify(key) + &#039;]&#039; + operator + JSON.stringify(value);
            }
        };
    }

    function strictInfix(operator) {
        var nonstrictInfix = infix(operator);
        return function(_, key, value) {
            if (key === &#039;$type&#039;) {
                return nonstrictInfix(_, key, value);
            } else {
                return &#039;typeof(p[&#039; + JSON.stringify(key) + &#039;]) === typeof(&#039; + JSON.stringify(value) + &#039;) &amp;&amp; &#039; +
                    nonstrictInfix(_, key, value);
            }
        };
    }

    var operators = {
        &#039;==&#039;: infix(&#039;===&#039;),
        &#039;!=&#039;: infix(&#039;!==&#039;),
        &#039;&gt;&#039;: strictInfix(&#039;&gt;&#039;),
        &#039;&lt;&#039;: strictInfix(&#039;&lt;&#039;),
        &#039;&lt;=&#039;: strictInfix(&#039;&lt;=&#039;),
        &#039;&gt;=&#039;: strictInfix(&#039;&gt;=&#039;),
        &#039;in&#039;: function(_, key) {
            return Array.prototype.slice.call(arguments, 2).map(function(value) {
                return &#039;(&#039; + operators[&#039;==&#039;](_, key, value) + &#039;)&#039;;
            }).join(&#039;||&#039;) || &#039;false&#039;;
        },
        &#039;!in&#039;: function() {
            return &#039;!(&#039; + operators.in.apply(this, arguments) + &#039;)&#039;;
        },
        &#039;any&#039;: function() {
            return Array.prototype.slice.call(arguments, 1).map(function(filter) {
                return &#039;(&#039; + compile(filter) + &#039;)&#039;;
            }).join(&#039;||&#039;) || &#039;false&#039;;
        },
        &#039;all&#039;: function() {
            return Array.prototype.slice.call(arguments, 1).map(function(filter) {
                return &#039;(&#039; + compile(filter) + &#039;)&#039;;
            }).join(&#039;&amp;&amp;&#039;) || &#039;true&#039;;
        },
        &#039;none&#039;: function() {
            return &#039;!(&#039; + operators.any.apply(this, arguments) + &#039;)&#039;;
        }
    };

    function compile(filter) {
        return operators[filter[0]].apply(filter, filter);
    }

    function truth() {
        return true;
    }

    module.exports = function (filter) {
        if (!filter) return truth;
        var filterStr = &#039;var p = f.properties || f.tags || {}, t = f.type; return &#039; + compile(filter) + &#039;;&#039;;
        // jshint evil: true
        return new Function(&#039;f&#039;, filterStr);
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/clip.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = clip;

    /* clip features between two axis-parallel lines:
     *     |        |
     *  ___|___     |     /
     * /   |   \____|____/
     *     |        |
     */

    function clip(features, scale, k1, k2, axis, intersect) {

        k1 /= scale;
        k2 /= scale;

        var clipped = [];

        for (var i = 0; i &lt; features.length; i++) {

            var feature = features[i],
                geometry = feature.geometry,
                type = feature.type,
                min, max;

            if (feature.min) {
                min = feature.min[axis];
                max = feature.max[axis];

                if (min &gt;= k1 &amp;&amp; max &lt;= k2) { // trivial accept
                    clipped.push(feature);
                    continue;
                } else if (min &gt; k2 || max &lt; k1) continue; // trivial reject
            }

            var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

            if (slices.length) {
                // if a feature got clipped, it will likely get clipped on the next zoom level as well,
                // so there&#039;s no need to recalculate bboxes
                clipped.push({
                    geometry: slices,
                    type: type,
                    tags: features[i].tags || null
                });
            }
        }

        return clipped.length ? clipped : null;
    }

    function clipPoints(geometry, k1, k2, axis) {
        var slice = [];

        for (var i = 0; i &lt; geometry.length; i++) {
            var a = geometry[i],
                ak = a[axis];

            if (ak &gt;= k1 &amp;&amp; ak &lt;= k2) slice.push(a);
        }
        return slice;
    }

    function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

        var slices = [];

        for (var i = 0; i &lt; geometry.length; i++) {

            var ak = 0,
                bk = 0,
                b = null,
                points = geometry[i],
                area = points.area,
                dist = points.dist,
                len = points.length,
                a, j;

            var slice = [];

            for (j = 0; j &lt; len - 1; j++) {
                a = b || points[j];
                b = points[j + 1];
                ak = bk || a[axis];
                bk = b[axis];

                if (ak &lt; k1) {

                    if ((bk &gt; k2)) { // ---|-----|--&gt;
                        slice.push(intersect(a, b, k1), intersect(a, b, k2));
                        if (!closed) slice = newSlice(slices, slice, area, dist);

                    } else if (bk &gt;= k1) slice.push(intersect(a, b, k1)); // ---|--&gt;  |

                } else if (ak &gt; k2) {

                    if ((bk &lt; k1)) { // &lt;--|-----|---
                        slice.push(intersect(a, b, k2), intersect(a, b, k1));
                        if (!closed) slice = newSlice(slices, slice, area, dist);

                    } else if (bk &lt;= k2) slice.push(intersect(a, b, k2)); // |  &lt;--|---

                } else {

                    slice.push(a);

                    if (bk &lt; k1) { // &lt;--|---  |
                        slice.push(intersect(a, b, k1));
                        if (!closed) slice = newSlice(slices, slice, area, dist);

                    } else if (bk &gt; k2) { // |  ---|--&gt;
                        slice.push(intersect(a, b, k2));
                        if (!closed) slice = newSlice(slices, slice, area, dist);
                    }
                    // | --&gt; |
                }
            }

            // add the last point
            a = points[len - 1];
            ak = a[axis];
            if (ak &gt;= k1 &amp;&amp; ak &lt;= k2) slice.push(a);

            // close the polygon if its endpoints are not the same after clipping
            if (closed &amp;&amp; slice[0] !== slice[slice.length - 1]) slice.push(slice[0]);

            // add the final slice
            newSlice(slices, slice, area, dist);
        }

        return slices;
    }

    function newSlice(slices, slice, area, dist) {
        if (slice.length) {
            // we don&#039;t recalculate the area/length of the unclipped geometry because the case where it goes
            // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
            slice.area = area;
            slice.dist = dist;

            slices.push(slice);
        }
        return [];
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/convert.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = convert;

    var simplify = require(&#039;./simplify&#039;);

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

    function convert(data, tolerance) {
        var features = [];

        if (data.type === &#039;FeatureCollection&#039;) {
            for (var i = 0; i &lt; data.features.length; i++) {
                convertFeature(features, data.features[i], tolerance);
            }
        } else if (data.type === &#039;Feature&#039;) {
            convertFeature(features, data, tolerance);

        } else {
            // single geometry or a geometry collection
            convertFeature(features, {geometry: data}, tolerance);
        }
        return features;
    }

    function convertFeature(features, feature, tolerance) {
        var geom = feature.geometry,
            type = geom.type,
            coords = geom.coordinates,
            tags = feature.properties,
            i, j, rings;

        if (type === &#039;Point&#039;) {
            features.push(create(tags, 1, [projectPoint(coords)]));

        } else if (type === &#039;MultiPoint&#039;) {
            features.push(create(tags, 1, project(coords)));

        } else if (type === &#039;LineString&#039;) {
            features.push(create(tags, 2, [project(coords, tolerance)]));

        } else if (type === &#039;MultiLineString&#039; || type === &#039;Polygon&#039;) {
            rings = [];
            for (i = 0; i &lt; coords.length; i++) {
                rings.push(project(coords[i], tolerance));
            }
            features.push(create(tags, type === &#039;Polygon&#039; ? 3 : 2, rings));

        } else if (type === &#039;MultiPolygon&#039;) {
            rings = [];
            for (i = 0; i &lt; coords.length; i++) {
                for (j = 0; j &lt; coords[i].length; j++) {
                    rings.push(project(coords[i][j], tolerance));
                }
            }
            features.push(create(tags, 3, rings));

        } else if (type === &#039;GeometryCollection&#039;) {
            for (i = 0; i &lt; geom.geometries.length; i++) {
                convertFeature(features, {
                    geometry: geom.geometries[i],
                    properties: tags
                }, tolerance);
            }

        } else {
            console.warn(&#039;Unsupported GeoJSON type: &#039; + geom.type);
        }
    }

    function create(tags, type, geometry) {
        var feature = {
            geometry: geometry,
            type: type,
            tags: tags || null,
            min: [1, 1], // initial bbox values;
            max: [0, 0]  // note that all coords are in [0..1] range
        };
        calcBBox(feature);
        return feature;
    }

    function project(lonlats, tolerance) {
        var projected = [];
        for (var i = 0; i &lt; lonlats.length; i++) {
            projected.push(projectPoint(lonlats[i]));
        }
        if (tolerance) {
            simplify(projected, tolerance);
            calcSize(projected);
        }
        return projected;
    }

    function projectPoint(p) {
        var sin = Math.sin(p[1] * Math.PI / 180),
            x = (p[0] / 360 + 0.5),
            y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
        return [x, y, 0];
    }

// calculate area and length of the poly
    function calcSize(points) {
        var area = 0,
            dist = 0;

        for (var i = 0, a, b; i &lt; points.length - 1; i++) {
            a = b || points[i];
            b = points[i + 1];

            area += a[0] * b[1] - b[0] * a[1];

            // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
            dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
        }
        points.area = Math.abs(area / 2);
        points.dist = dist;
    }

// calculate the feature bounding box for faster clipping later
    function calcBBox(feature) {
        var geometry = feature.geometry,
            min = feature.min,
            max = feature.max;

        if (feature.type === 1) calcRingBBox(min, max, geometry);
        else for (var i = 0; i &lt; geometry.length; i++) calcRingBBox(min, max, geometry[i]);

        return feature;
    }

    function calcRingBBox(min, max, points) {
        for (var i = 0, p; i &lt; points.length; i++) {
            p = points[i];
            min[0] = Math.min(p[0], min[0]);
            max[0] = Math.max(p[0], max[0]);
            min[1] = Math.min(p[1], min[1]);
            max[1] = Math.max(p[1], max[1]);
        }
    }

},{&quot;./simplify&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/simplify.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/index.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = geojsonvt;

    var convert = require(&#039;./convert&#039;), // GeoJSON conversion and preprocessing
        clip = require(&#039;./clip&#039;),       // stripe clipping algorithm
        createTile = require(&#039;./tile&#039;); // final simplified tile generation


    function geojsonvt(data, options) {
        return new GeoJSONVT(data, options);
    }

    function GeoJSONVT(data, options) {
        options = this.options = extend(Object.create(this.options), options);

        var debug = options.debug;

        if (debug) console.time(&#039;preprocess data&#039;);

        var z2 = 1 &lt;&lt; options.baseZoom, // 2^z
            features = convert(data, options.tolerance / (z2 * options.extent));

        this.tiles = {};

        if (debug) {
            console.timeEnd(&#039;preprocess data&#039;);
            console.time(&#039;generate tiles up to z&#039; + options.maxZoom);
            this.stats = {};
            this.total = 0;
        }

        // start slicing from the top tile down
        this.splitTile(features, 0, 0, 0);

        if (debug) {
            console.log(&#039;features: %d, points: %d&#039;, this.tiles[0].numFeatures, this.tiles[0].numPoints);
            console.timeEnd(&#039;generate tiles up to z&#039; + options.maxZoom);
            console.log(&#039;tiles generated:&#039;, this.total, JSON.stringify(this.stats));
        }
    }

    GeoJSONVT.prototype.options = {
        baseZoom: 14,   // max zoom to preserve detail on
        maxZoom: 4,     // zoom to slice down to on first pass
        maxPoints: 100, // stop slicing a tile below this number of points
        tolerance: 3,   // simplification tolerance (higher means simpler)
        extent: 4096,   // tile extent
        buffer: 64,     // tile buffer on each side
        debug: 0        // logging level (0, 1 or 2)
    };

    GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

        var stack = [features, z, x, y],
            options = this.options,
            debug = options.debug,
            extent = options.extent,
            buffer = options.buffer;

        // avoid recursion by using a processing queue
        while (stack.length) {
            features = stack.shift();
            z = stack.shift();
            x = stack.shift();
            y = stack.shift();

            var z2 = 1 &lt;&lt; z,
                id = toID(z, x, y),
                tile = this.tiles[id],
                tileTolerance = z === options.baseZoom ? 0 : options.tolerance / (z2 * extent);

            if (!tile) {
                if (debug &gt; 1) console.time(&#039;creation&#039;);

                tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, extent, z === options.baseZoom);

                if (debug) {
                    if (debug &gt; 1) {
                        console.log(&#039;tile z%d-%d-%d (features: %d, points: %d, simplified: %d)&#039;,
                            z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                        console.timeEnd(&#039;creation&#039;);
                    }
                    var key = &#039;z&#039; + z + &#039;:&#039;;
                    this.stats[key] = (this.stats[key] || 0) + 1;
                    this.total++;
                }
            }

            if (!cz &amp;&amp; (z === options.maxZoom || tile.numPoints &lt;= options.maxPoints ||
                isClippedSquare(tile.features, extent, buffer)) || z === options.baseZoom || z === cz) {
                tile.source = features;
                continue; // stop tiling
            }

            if (cz) tile.source = features;
            else tile.source = null;

            if (debug &gt; 1) console.time(&#039;clipping&#039;);

            // values we&#039;ll use for clipping
            var k1 = 0.5 * buffer / extent,
                k2 = 0.5 - k1,
                k3 = 0.5 + k1,
                k4 = 1 + k1,

                tl, bl, tr, br, left, right,
                m, goLeft, goTop;

            if (cz) { // if we have a specific tile to drill down to, calculate where to go
                m = 1 &lt;&lt; (cz - z);
                goLeft = cx / m - x &lt; 0.5;
                goTop = cy / m - y &lt; 0.5;
            }

            tl = bl = tr = br = left = right = null;

            if (!cz ||  goLeft) left  = clip(features, z2, x - k1, x + k3, 0, intersectX);
            if (!cz || !goLeft) right = clip(features, z2, x + k2, x + k4, 0, intersectX);

            if (left) {
                if (!cz ||  goTop) tl = clip(left, z2, y - k1, y + k3, 1, intersectY);
                if (!cz || !goTop) bl = clip(left, z2, y + k2, y + k4, 1, intersectY);
            }

            if (right) {
                if (!cz ||  goTop) tr = clip(right, z2, y - k1, y + k3, 1, intersectY);
                if (!cz || !goTop) br = clip(right, z2, y + k2, y + k4, 1, intersectY);
            }

            if (debug &gt; 1) console.timeEnd(&#039;clipping&#039;);

            if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
            if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
            if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
            if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
        }
    };

    GeoJSONVT.prototype.getTile = function (z, x, y) {
        var id = toID(z, x, y);
        if (this.tiles[id]) return this.tiles[id];

        var options = this.options,
            debug = options.debug;

        if (debug &gt; 1) console.log(&#039;drilling down to z%d-%d-%d&#039;, z, x, y);

        var z0 = z,
            x0 = x,
            y0 = y,
            parent;

        while (!parent &amp;&amp; z0 &gt; 0) {
            z0--;
            x0 = Math.floor(x0 / 2);
            y0 = Math.floor(y0 / 2);
            parent = this.tiles[toID(z0, x0, y0)];
        }

        if (debug &gt; 1) console.log(&#039;found parent tile z%d-%d-%d&#039;, z0, x0, y0);

        // if we found a parent tile containing the original geometry, we can drill down from it
        if (parent.source) {
            if (isClippedSquare(parent.features, options.extent, options.buffer)) return parent;

            if (debug) console.time(&#039;drilling down&#039;);
            this.splitTile(parent.source, z0, x0, y0, z, x, y);
            if (debug) console.timeEnd(&#039;drilling down&#039;);
        }

        return this.tiles[id];
    };

// checks whether a tile is a whole-area fill after clipping; if it is, there&#039;s no sense slicing it further
    function isClippedSquare(features, extent, buffer) {
        if (features.length !== 1) return false;

        var feature = features[0];
        if (feature.type !== 3 || feature.geometry.length &gt; 1) return false;

        for (var i = 0; i &lt; feature.geometry[0].length; i++) {
            var p = feature.geometry[0][i];
            if ((p[0] !== -buffer &amp;&amp; p[0] !== extent + buffer) ||
                (p[1] !== -buffer &amp;&amp; p[1] !== extent + buffer)) return false;
        }
        return true;
    }

    function toID(z, x, y) {
        return (((1 &lt;&lt; z) * y + x) * 32) + z;
    }

    function intersectX(a, b, x) {
        return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
    }
    function intersectY(a, b, y) {
        return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
    }

    function extend(dest, src) {
        for (var i in src) dest[i] = src[i];
        return dest;
    }

},{&quot;./clip&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/clip.js&quot;,&quot;./convert&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/convert.js&quot;,&quot;./tile&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/tile.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/simplify.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

    function simplify(points, tolerance) {

        var sqTolerance = tolerance * tolerance,
            len = points.length,
            first = 0,
            last = len - 1,
            stack = [],
            i, maxSqDist, sqDist, index;

        // always retain the endpoints (1 is the max value)
        points[first][2] = 1;
        points[last][2] = 1;

        // avoid recursion by using a stack
        while (last) {

            maxSqDist = 0;

            for (i = first + 1; i &lt; last; i++) {
                sqDist = getSqSegDist(points[i], points[first], points[last]);

                if (sqDist &gt; maxSqDist) {
                    index = i;
                    maxSqDist = sqDist;
                }
            }

            if (maxSqDist &gt; sqTolerance) {
                points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
                stack.push(first, index, index, last);
            }

            last = stack.pop();
            first = stack.pop();
        }
    }

// square distance from a point to a segment
    function getSqSegDist(p, a, b) {

        var x = a[0], y = a[1],
            bx = b[0], by = b[1],
            px = p[0], py = p[1],
            dx = bx - x,
            dy = by - y;

        if (dx !== 0 || dy !== 0) {

            var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

            if (t &gt; 1) {
                x = bx;
                y = by;

            } else if (t &gt; 0) {
                x += dx * t;
                y += dy * t;
            }
        }

        dx = px - x;
        dy = py - y;

        return dx * dx + dy * dy;
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/geojson-vt/src/tile.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = createTile;

    function createTile(features, z2, tx, ty, tolerance, extent, noSimplify) {
        var tile = {
            features: [],
            numPoints: 0,
            numSimplified: 0,
            numFeatures: 0,
            source: null
        };
        for (var i = 0; i &lt; features.length; i++) {
            tile.numFeatures++;
            addFeature(tile, features[i], z2, tx, ty, tolerance, extent, noSimplify);
        }
        return tile;
    }

    function addFeature(tile, feature, z2, tx, ty, tolerance, extent, noSimplify) {

        var geom = feature.geometry,
            type = feature.type,
            transformed = [],
            sqTolerance = tolerance * tolerance,
            i, j, ring, p;

        if (type === 1) {
            for (i = 0; i &lt; geom.length; i++) {
                transformed.push(transformPoint(geom[i], z2, tx, ty, extent));
                tile.numPoints++;
                tile.numSimplified++;
            }

        } else {

            // simplify and transform projected coordinates for tile geometry
            for (i = 0; i &lt; geom.length; i++) {
                ring = geom[i];

                // filter out tiny polylines &amp; polygons
                if (!noSimplify &amp;&amp; ((type === 2 &amp;&amp; ring.dist &lt; tolerance) ||
                    (type === 3 &amp;&amp; ring.area &lt; sqTolerance))) {
                    tile.numPoints += ring.length;
                    continue;
                }

                var transformedRing = [];

                for (j = 0; j &lt; ring.length; j++) {
                    p = ring[j];
                    // keep points with importance &gt; tolerance
                    if (noSimplify || p[2] &gt; sqTolerance) {
                        transformedRing.push(transformPoint(p, z2, tx, ty, extent));
                        tile.numSimplified++;
                    }
                    tile.numPoints++;
                }

                transformed.push(transformedRing);
            }
        }

        if (transformed.length) {
            tile.features.push({
                geometry: transformed,
                type: type,
                tags: feature.tags || null
            });
        }
    }

    function transformPoint(p, z2, tx, ty, extent) {
        var x = Math.round(extent * (p[0] * z2 - tx)),
            y = Math.round(extent * (p[1] * z2 - ty));
        return [x, y];
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/gl-matrix/dist/gl-matrix.js&quot;:[function(require,module,exports){
    /**
     * @fileoverview gl-matrix - High performance matrix and vector operations
     * @author Brandon Jones
     * @author Colin MacKenzie IV
     * @version 2.2.1
     */

    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

     Redistribution and use in source and binary forms, with or without modification,
     are permitted provided that the following conditions are met:

     * Redistributions of source code must retain the above copyright notice, this
     list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


    (function(_global) {
        &quot;use strict&quot;;

        var shim = {};
        if (typeof(exports) === &#039;undefined&#039;) {
            if(typeof define == &#039;function&#039; &amp;&amp; typeof define.amd == &#039;object&#039; &amp;&amp; define.amd) {
                shim.exports = {};
                define(function() {
                    return shim.exports;
                });
            } else {
                // gl-matrix lives in a browser, define its namespaces in global
                shim.exports = typeof(window) !== &#039;undefined&#039; ? window : _global;
            }
        }
        else {
            // gl-matrix lives in commonjs, define its namespaces in exports
            shim.exports = exports;
        }

        (function(exports) {
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


            if(!GLMAT_EPSILON) {
                var GLMAT_EPSILON = 0.000001;
            }

            if(!GLMAT_ARRAY_TYPE) {
                var GLMAT_ARRAY_TYPE = (typeof Float32Array !== &#039;undefined&#039;) ? Float32Array : Array;
            }

            if(!GLMAT_RANDOM) {
                var GLMAT_RANDOM = Math.random;
            }

            /**
             * @class Common utilities
             * @name glMatrix
             */
            var glMatrix = {};

            /**
             * Sets the type of array used when creating new vectors and matricies
             *
             * @param {Type} type Array type, such as Float32Array or Array
             */
            glMatrix.setMatrixArrayType = function(type) {
                GLMAT_ARRAY_TYPE = type;
            }

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.glMatrix = glMatrix;
            }

            var degree = Math.PI / 180;

            /**
             * Convert Degree To Radian
             *
             * @param {Number} Angle in Degrees
             */
            glMatrix.toRadian = function(a){
                return a * degree;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 2 Dimensional Vector
             * @name vec2
             */

            var vec2 = {};

            /**
             * Creates a new, empty vec2
             *
             * @returns {vec2} a new 2D vector
             */
            vec2.create = function() {
                var out = new GLMAT_ARRAY_TYPE(2);
                out[0] = 0;
                out[1] = 0;
                return out;
            };

            /**
             * Creates a new vec2 initialized with values from an existing vector
             *
             * @param {vec2} a vector to clone
             * @returns {vec2} a new 2D vector
             */
            vec2.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(2);
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };

            /**
             * Creates a new vec2 initialized with the given values
             *
             * @param {Number} x X component
             * @param {Number} y Y component
             * @returns {vec2} a new 2D vector
             */
            vec2.fromValues = function(x, y) {
                var out = new GLMAT_ARRAY_TYPE(2);
                out[0] = x;
                out[1] = y;
                return out;
            };

            /**
             * Copy the values from one vec2 to another
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the source vector
             * @returns {vec2} out
             */
            vec2.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                return out;
            };

            /**
             * Set the components of a vec2 to the given values
             *
             * @param {vec2} out the receiving vector
             * @param {Number} x X component
             * @param {Number} y Y component
             * @returns {vec2} out
             */
            vec2.set = function(out, x, y) {
                out[0] = x;
                out[1] = y;
                return out;
            };

            /**
             * Adds two vec2&#039;s
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            vec2.add = function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                return out;
            };

            /**
             * Subtracts vector b from vector a
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            vec2.subtract = function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                return out;
            };

            /**
             * Alias for {@link vec2.subtract}
             * @function
             */
            vec2.sub = vec2.subtract;

            /**
             * Multiplies two vec2&#039;s
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            vec2.multiply = function(out, a, b) {
                out[0] = a[0] * b[0];
                out[1] = a[1] * b[1];
                return out;
            };

            /**
             * Alias for {@link vec2.multiply}
             * @function
             */
            vec2.mul = vec2.multiply;

            /**
             * Divides two vec2&#039;s
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            vec2.divide = function(out, a, b) {
                out[0] = a[0] / b[0];
                out[1] = a[1] / b[1];
                return out;
            };

            /**
             * Alias for {@link vec2.divide}
             * @function
             */
            vec2.div = vec2.divide;

            /**
             * Returns the minimum of two vec2&#039;s
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            vec2.min = function(out, a, b) {
                out[0] = Math.min(a[0], b[0]);
                out[1] = Math.min(a[1], b[1]);
                return out;
            };

            /**
             * Returns the maximum of two vec2&#039;s
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec2} out
             */
            vec2.max = function(out, a, b) {
                out[0] = Math.max(a[0], b[0]);
                out[1] = Math.max(a[1], b[1]);
                return out;
            };

            /**
             * Scales a vec2 by a scalar number
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the vector to scale
             * @param {Number} b amount to scale the vector by
             * @returns {vec2} out
             */
            vec2.scale = function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                return out;
            };

            /**
             * Adds two vec2&#039;s after scaling the second operand by a scalar value
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @param {Number} scale the amount to scale b by before adding
             * @returns {vec2} out
             */
            vec2.scaleAndAdd = function(out, a, b, scale) {
                out[0] = a[0] + (b[0] * scale);
                out[1] = a[1] + (b[1] * scale);
                return out;
            };

            /**
             * Calculates the euclidian distance between two vec2&#039;s
             *
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {Number} distance between a and b
             */
            vec2.distance = function(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1];
                return Math.sqrt(x*x + y*y);
            };

            /**
             * Alias for {@link vec2.distance}
             * @function
             */
            vec2.dist = vec2.distance;

            /**
             * Calculates the squared euclidian distance between two vec2&#039;s
             *
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {Number} squared distance between a and b
             */
            vec2.squaredDistance = function(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1];
                return x*x + y*y;
            };

            /**
             * Alias for {@link vec2.squaredDistance}
             * @function
             */
            vec2.sqrDist = vec2.squaredDistance;

            /**
             * Calculates the length of a vec2
             *
             * @param {vec2} a vector to calculate length of
             * @returns {Number} length of a
             */
            vec2.length = function (a) {
                var x = a[0],
                    y = a[1];
                return Math.sqrt(x*x + y*y);
            };

            /**
             * Alias for {@link vec2.length}
             * @function
             */
            vec2.len = vec2.length;

            /**
             * Calculates the squared length of a vec2
             *
             * @param {vec2} a vector to calculate squared length of
             * @returns {Number} squared length of a
             */
            vec2.squaredLength = function (a) {
                var x = a[0],
                    y = a[1];
                return x*x + y*y;
            };

            /**
             * Alias for {@link vec2.squaredLength}
             * @function
             */
            vec2.sqrLen = vec2.squaredLength;

            /**
             * Negates the components of a vec2
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a vector to negate
             * @returns {vec2} out
             */
            vec2.negate = function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                return out;
            };

            /**
             * Normalize a vec2
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a vector to normalize
             * @returns {vec2} out
             */
            vec2.normalize = function(out, a) {
                var x = a[0],
                    y = a[1];
                var len = x*x + y*y;
                if (len &gt; 0) {
                    //TODO: evaluate use of glm_invsqrt here?
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                }
                return out;
            };

            /**
             * Calculates the dot product of two vec2&#039;s
             *
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {Number} dot product of a and b
             */
            vec2.dot = function (a, b) {
                return a[0] * b[0] + a[1] * b[1];
            };

            /**
             * Computes the cross product of two vec2&#039;s
             * Note that the cross product must by definition produce a 3D vector
             *
             * @param {vec3} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @returns {vec3} out
             */
            vec2.cross = function(out, a, b) {
                var z = a[0] * b[1] - a[1] * b[0];
                out[0] = out[1] = 0;
                out[2] = z;
                return out;
            };

            /**
             * Performs a linear interpolation between two vec2&#039;s
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the first operand
             * @param {vec2} b the second operand
             * @param {Number} t interpolation amount between the two inputs
             * @returns {vec2} out
             */
            vec2.lerp = function (out, a, b, t) {
                var ax = a[0],
                    ay = a[1];
                out[0] = ax + t * (b[0] - ax);
                out[1] = ay + t * (b[1] - ay);
                return out;
            };

            /**
             * Generates a random vector with the given scale
             *
             * @param {vec2} out the receiving vector
             * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
             * @returns {vec2} out
             */
            vec2.random = function (out, scale) {
                scale = scale || 1.0;
                var r = GLMAT_RANDOM() * 2.0 * Math.PI;
                out[0] = Math.cos(r) * scale;
                out[1] = Math.sin(r) * scale;
                return out;
            };

            /**
             * Transforms the vec2 with a mat2
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the vector to transform
             * @param {mat2} m matrix to transform with
             * @returns {vec2} out
             */
            vec2.transformMat2 = function(out, a, m) {
                var x = a[0],
                    y = a[1];
                out[0] = m[0] * x + m[2] * y;
                out[1] = m[1] * x + m[3] * y;
                return out;
            };

            /**
             * Transforms the vec2 with a mat2d
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the vector to transform
             * @param {mat2d} m matrix to transform with
             * @returns {vec2} out
             */
            vec2.transformMat2d = function(out, a, m) {
                var x = a[0],
                    y = a[1];
                out[0] = m[0] * x + m[2] * y + m[4];
                out[1] = m[1] * x + m[3] * y + m[5];
                return out;
            };

            /**
             * Transforms the vec2 with a mat3
             * 3rd vector component is implicitly &#039;1&#039;
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the vector to transform
             * @param {mat3} m matrix to transform with
             * @returns {vec2} out
             */
            vec2.transformMat3 = function(out, a, m) {
                var x = a[0],
                    y = a[1];
                out[0] = m[0] * x + m[3] * y + m[6];
                out[1] = m[1] * x + m[4] * y + m[7];
                return out;
            };

            /**
             * Transforms the vec2 with a mat4
             * 3rd vector component is implicitly &#039;0&#039;
             * 4th vector component is implicitly &#039;1&#039;
             *
             * @param {vec2} out the receiving vector
             * @param {vec2} a the vector to transform
             * @param {mat4} m matrix to transform with
             * @returns {vec2} out
             */
            vec2.transformMat4 = function(out, a, m) {
                var x = a[0],
                    y = a[1];
                out[0] = m[0] * x + m[4] * y + m[12];
                out[1] = m[1] * x + m[5] * y + m[13];
                return out;
            };

            /**
             * Perform some operation over an array of vec2s.
             *
             * @param {Array} a the array of vectors to iterate over
             * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
             * @param {Number} offset Number of elements to skip at the beginning of the array
             * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
             * @param {Function} fn Function to call for each vector in the array
             * @param {Object} [arg] additional argument to pass to fn
             * @returns {Array} a
             * @function
             */
            vec2.forEach = (function() {
                var vec = vec2.create();

                return function(a, stride, offset, count, fn, arg) {
                    var i, l;
                    if(!stride) {
                        stride = 2;
                    }

                    if(!offset) {
                        offset = 0;
                    }

                    if(count) {
                        l = Math.min((count * stride) + offset, a.length);
                    } else {
                        l = a.length;
                    }

                    for(i = offset; i &lt; l; i += stride) {
                        vec[0] = a[i]; vec[1] = a[i+1];
                        fn(vec, vec, arg);
                        a[i] = vec[0]; a[i+1] = vec[1];
                    }

                    return a;
                };
            })();

            /**
             * Returns a string representation of a vector
             *
             * @param {vec2} vec vector to represent as a string
             * @returns {String} string representation of the vector
             */
            vec2.str = function (a) {
                return &#039;vec2(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;)&#039;;
            };

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.vec2 = vec2;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 3 Dimensional Vector
             * @name vec3
             */

            var vec3 = {};

            /**
             * Creates a new, empty vec3
             *
             * @returns {vec3} a new 3D vector
             */
            vec3.create = function() {
                var out = new GLMAT_ARRAY_TYPE(3);
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                return out;
            };

            /**
             * Creates a new vec3 initialized with values from an existing vector
             *
             * @param {vec3} a vector to clone
             * @returns {vec3} a new 3D vector
             */
            vec3.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(3);
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                return out;
            };

            /**
             * Creates a new vec3 initialized with the given values
             *
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @returns {vec3} a new 3D vector
             */
            vec3.fromValues = function(x, y, z) {
                var out = new GLMAT_ARRAY_TYPE(3);
                out[0] = x;
                out[1] = y;
                out[2] = z;
                return out;
            };

            /**
             * Copy the values from one vec3 to another
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the source vector
             * @returns {vec3} out
             */
            vec3.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                return out;
            };

            /**
             * Set the components of a vec3 to the given values
             *
             * @param {vec3} out the receiving vector
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @returns {vec3} out
             */
            vec3.set = function(out, x, y, z) {
                out[0] = x;
                out[1] = y;
                out[2] = z;
                return out;
            };

            /**
             * Adds two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.add = function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                out[2] = a[2] + b[2];
                return out;
            };

            /**
             * Subtracts vector b from vector a
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.subtract = function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                out[2] = a[2] - b[2];
                return out;
            };

            /**
             * Alias for {@link vec3.subtract}
             * @function
             */
            vec3.sub = vec3.subtract;

            /**
             * Multiplies two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.multiply = function(out, a, b) {
                out[0] = a[0] * b[0];
                out[1] = a[1] * b[1];
                out[2] = a[2] * b[2];
                return out;
            };

            /**
             * Alias for {@link vec3.multiply}
             * @function
             */
            vec3.mul = vec3.multiply;

            /**
             * Divides two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.divide = function(out, a, b) {
                out[0] = a[0] / b[0];
                out[1] = a[1] / b[1];
                out[2] = a[2] / b[2];
                return out;
            };

            /**
             * Alias for {@link vec3.divide}
             * @function
             */
            vec3.div = vec3.divide;

            /**
             * Returns the minimum of two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.min = function(out, a, b) {
                out[0] = Math.min(a[0], b[0]);
                out[1] = Math.min(a[1], b[1]);
                out[2] = Math.min(a[2], b[2]);
                return out;
            };

            /**
             * Returns the maximum of two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.max = function(out, a, b) {
                out[0] = Math.max(a[0], b[0]);
                out[1] = Math.max(a[1], b[1]);
                out[2] = Math.max(a[2], b[2]);
                return out;
            };

            /**
             * Scales a vec3 by a scalar number
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the vector to scale
             * @param {Number} b amount to scale the vector by
             * @returns {vec3} out
             */
            vec3.scale = function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                out[2] = a[2] * b;
                return out;
            };

            /**
             * Adds two vec3&#039;s after scaling the second operand by a scalar value
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @param {Number} scale the amount to scale b by before adding
             * @returns {vec3} out
             */
            vec3.scaleAndAdd = function(out, a, b, scale) {
                out[0] = a[0] + (b[0] * scale);
                out[1] = a[1] + (b[1] * scale);
                out[2] = a[2] + (b[2] * scale);
                return out;
            };

            /**
             * Calculates the euclidian distance between two vec3&#039;s
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} distance between a and b
             */
            vec3.distance = function(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1],
                    z = b[2] - a[2];
                return Math.sqrt(x*x + y*y + z*z);
            };

            /**
             * Alias for {@link vec3.distance}
             * @function
             */
            vec3.dist = vec3.distance;

            /**
             * Calculates the squared euclidian distance between two vec3&#039;s
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} squared distance between a and b
             */
            vec3.squaredDistance = function(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1],
                    z = b[2] - a[2];
                return x*x + y*y + z*z;
            };

            /**
             * Alias for {@link vec3.squaredDistance}
             * @function
             */
            vec3.sqrDist = vec3.squaredDistance;

            /**
             * Calculates the length of a vec3
             *
             * @param {vec3} a vector to calculate length of
             * @returns {Number} length of a
             */
            vec3.length = function (a) {
                var x = a[0],
                    y = a[1],
                    z = a[2];
                return Math.sqrt(x*x + y*y + z*z);
            };

            /**
             * Alias for {@link vec3.length}
             * @function
             */
            vec3.len = vec3.length;

            /**
             * Calculates the squared length of a vec3
             *
             * @param {vec3} a vector to calculate squared length of
             * @returns {Number} squared length of a
             */
            vec3.squaredLength = function (a) {
                var x = a[0],
                    y = a[1],
                    z = a[2];
                return x*x + y*y + z*z;
            };

            /**
             * Alias for {@link vec3.squaredLength}
             * @function
             */
            vec3.sqrLen = vec3.squaredLength;

            /**
             * Negates the components of a vec3
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a vector to negate
             * @returns {vec3} out
             */
            vec3.negate = function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                out[2] = -a[2];
                return out;
            };

            /**
             * Normalize a vec3
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a vector to normalize
             * @returns {vec3} out
             */
            vec3.normalize = function(out, a) {
                var x = a[0],
                    y = a[1],
                    z = a[2];
                var len = x*x + y*y + z*z;
                if (len &gt; 0) {
                    //TODO: evaluate use of glm_invsqrt here?
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                    out[2] = a[2] * len;
                }
                return out;
            };

            /**
             * Calculates the dot product of two vec3&#039;s
             *
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {Number} dot product of a and b
             */
            vec3.dot = function (a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            };

            /**
             * Computes the cross product of two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @returns {vec3} out
             */
            vec3.cross = function(out, a, b) {
                var ax = a[0], ay = a[1], az = a[2],
                    bx = b[0], by = b[1], bz = b[2];

                out[0] = ay * bz - az * by;
                out[1] = az * bx - ax * bz;
                out[2] = ax * by - ay * bx;
                return out;
            };

            /**
             * Performs a linear interpolation between two vec3&#039;s
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the first operand
             * @param {vec3} b the second operand
             * @param {Number} t interpolation amount between the two inputs
             * @returns {vec3} out
             */
            vec3.lerp = function (out, a, b, t) {
                var ax = a[0],
                    ay = a[1],
                    az = a[2];
                out[0] = ax + t * (b[0] - ax);
                out[1] = ay + t * (b[1] - ay);
                out[2] = az + t * (b[2] - az);
                return out;
            };

            /**
             * Generates a random vector with the given scale
             *
             * @param {vec3} out the receiving vector
             * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
             * @returns {vec3} out
             */
            vec3.random = function (out, scale) {
                scale = scale || 1.0;

                var r = GLMAT_RANDOM() * 2.0 * Math.PI;
                var z = (GLMAT_RANDOM() * 2.0) - 1.0;
                var zScale = Math.sqrt(1.0-z*z) * scale;

                out[0] = Math.cos(r) * zScale;
                out[1] = Math.sin(r) * zScale;
                out[2] = z * scale;
                return out;
            };

            /**
             * Transforms the vec3 with a mat4.
             * 4th vector component is implicitly &#039;1&#039;
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the vector to transform
             * @param {mat4} m matrix to transform with
             * @returns {vec3} out
             */
            vec3.transformMat4 = function(out, a, m) {
                var x = a[0], y = a[1], z = a[2];
                out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
                out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
                out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
                return out;
            };

            /**
             * Transforms the vec3 with a mat3.
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the vector to transform
             * @param {mat4} m the 3x3 matrix to transform with
             * @returns {vec3} out
             */
            vec3.transformMat3 = function(out, a, m) {
                var x = a[0], y = a[1], z = a[2];
                out[0] = x * m[0] + y * m[3] + z * m[6];
                out[1] = x * m[1] + y * m[4] + z * m[7];
                out[2] = x * m[2] + y * m[5] + z * m[8];
                return out;
            };

            /**
             * Transforms the vec3 with a quat
             *
             * @param {vec3} out the receiving vector
             * @param {vec3} a the vector to transform
             * @param {quat} q quaternion to transform with
             * @returns {vec3} out
             */
            vec3.transformQuat = function(out, a, q) {
                // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

                var x = a[0], y = a[1], z = a[2],
                    qx = q[0], qy = q[1], qz = q[2], qw = q[3],

                // calculate quat * vec
                    ix = qw * x + qy * z - qz * y,
                    iy = qw * y + qz * x - qx * z,
                    iz = qw * z + qx * y - qy * x,
                    iw = -qx * x - qy * y - qz * z;

                // calculate result * inverse quat
                out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return out;
            };

            /*
             * Rotate a 3D vector around the x-axis
             * @param {vec3} out The receiving vec3
             * @param {vec3} a The vec3 point to rotate
             * @param {vec3} b The origin of the rotation
             * @param {Number} c The angle of rotation
             * @returns {vec3} out
             */
            vec3.rotateX = function(out, a, b, c){
                var p = [], r=[];
                //Translate point to the origin
                p[0] = a[0] - b[0];
                p[1] = a[1] - b[1];
                p[2] = a[2] - b[2];

                //perform rotation
                r[0] = p[0];
                r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
                r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

                //translate to correct position
                out[0] = r[0] + b[0];
                out[1] = r[1] + b[1];
                out[2] = r[2] + b[2];

                return out;
            };

            /*
             * Rotate a 3D vector around the y-axis
             * @param {vec3} out The receiving vec3
             * @param {vec3} a The vec3 point to rotate
             * @param {vec3} b The origin of the rotation
             * @param {Number} c The angle of rotation
             * @returns {vec3} out
             */
            vec3.rotateY = function(out, a, b, c){
                var p = [], r=[];
                //Translate point to the origin
                p[0] = a[0] - b[0];
                p[1] = a[1] - b[1];
                p[2] = a[2] - b[2];

                //perform rotation
                r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
                r[1] = p[1];
                r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

                //translate to correct position
                out[0] = r[0] + b[0];
                out[1] = r[1] + b[1];
                out[2] = r[2] + b[2];

                return out;
            };

            /*
             * Rotate a 3D vector around the z-axis
             * @param {vec3} out The receiving vec3
             * @param {vec3} a The vec3 point to rotate
             * @param {vec3} b The origin of the rotation
             * @param {Number} c The angle of rotation
             * @returns {vec3} out
             */
            vec3.rotateZ = function(out, a, b, c){
                var p = [], r=[];
                //Translate point to the origin
                p[0] = a[0] - b[0];
                p[1] = a[1] - b[1];
                p[2] = a[2] - b[2];

                //perform rotation
                r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
                r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
                r[2] = p[2];

                //translate to correct position
                out[0] = r[0] + b[0];
                out[1] = r[1] + b[1];
                out[2] = r[2] + b[2];

                return out;
            };

            /**
             * Perform some operation over an array of vec3s.
             *
             * @param {Array} a the array of vectors to iterate over
             * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
             * @param {Number} offset Number of elements to skip at the beginning of the array
             * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
             * @param {Function} fn Function to call for each vector in the array
             * @param {Object} [arg] additional argument to pass to fn
             * @returns {Array} a
             * @function
             */
            vec3.forEach = (function() {
                var vec = vec3.create();

                return function(a, stride, offset, count, fn, arg) {
                    var i, l;
                    if(!stride) {
                        stride = 3;
                    }

                    if(!offset) {
                        offset = 0;
                    }

                    if(count) {
                        l = Math.min((count * stride) + offset, a.length);
                    } else {
                        l = a.length;
                    }

                    for(i = offset; i &lt; l; i += stride) {
                        vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
                        fn(vec, vec, arg);
                        a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
                    }

                    return a;
                };
            })();

            /**
             * Returns a string representation of a vector
             *
             * @param {vec3} vec vector to represent as a string
             * @returns {String} string representation of the vector
             */
            vec3.str = function (a) {
                return &#039;vec3(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;)&#039;;
            };

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.vec3 = vec3;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 4 Dimensional Vector
             * @name vec4
             */

            var vec4 = {};

            /**
             * Creates a new, empty vec4
             *
             * @returns {vec4} a new 4D vector
             */
            vec4.create = function() {
                var out = new GLMAT_ARRAY_TYPE(4);
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                return out;
            };

            /**
             * Creates a new vec4 initialized with values from an existing vector
             *
             * @param {vec4} a vector to clone
             * @returns {vec4} a new 4D vector
             */
            vec4.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(4);
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                return out;
            };

            /**
             * Creates a new vec4 initialized with the given values
             *
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @param {Number} w W component
             * @returns {vec4} a new 4D vector
             */
            vec4.fromValues = function(x, y, z, w) {
                var out = new GLMAT_ARRAY_TYPE(4);
                out[0] = x;
                out[1] = y;
                out[2] = z;
                out[3] = w;
                return out;
            };

            /**
             * Copy the values from one vec4 to another
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the source vector
             * @returns {vec4} out
             */
            vec4.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                return out;
            };

            /**
             * Set the components of a vec4 to the given values
             *
             * @param {vec4} out the receiving vector
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @param {Number} w W component
             * @returns {vec4} out
             */
            vec4.set = function(out, x, y, z, w) {
                out[0] = x;
                out[1] = y;
                out[2] = z;
                out[3] = w;
                return out;
            };

            /**
             * Adds two vec4&#039;s
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {vec4} out
             */
            vec4.add = function(out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                out[2] = a[2] + b[2];
                out[3] = a[3] + b[3];
                return out;
            };

            /**
             * Subtracts vector b from vector a
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {vec4} out
             */
            vec4.subtract = function(out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                out[2] = a[2] - b[2];
                out[3] = a[3] - b[3];
                return out;
            };

            /**
             * Alias for {@link vec4.subtract}
             * @function
             */
            vec4.sub = vec4.subtract;

            /**
             * Multiplies two vec4&#039;s
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {vec4} out
             */
            vec4.multiply = function(out, a, b) {
                out[0] = a[0] * b[0];
                out[1] = a[1] * b[1];
                out[2] = a[2] * b[2];
                out[3] = a[3] * b[3];
                return out;
            };

            /**
             * Alias for {@link vec4.multiply}
             * @function
             */
            vec4.mul = vec4.multiply;

            /**
             * Divides two vec4&#039;s
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {vec4} out
             */
            vec4.divide = function(out, a, b) {
                out[0] = a[0] / b[0];
                out[1] = a[1] / b[1];
                out[2] = a[2] / b[2];
                out[3] = a[3] / b[3];
                return out;
            };

            /**
             * Alias for {@link vec4.divide}
             * @function
             */
            vec4.div = vec4.divide;

            /**
             * Returns the minimum of two vec4&#039;s
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {vec4} out
             */
            vec4.min = function(out, a, b) {
                out[0] = Math.min(a[0], b[0]);
                out[1] = Math.min(a[1], b[1]);
                out[2] = Math.min(a[2], b[2]);
                out[3] = Math.min(a[3], b[3]);
                return out;
            };

            /**
             * Returns the maximum of two vec4&#039;s
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {vec4} out
             */
            vec4.max = function(out, a, b) {
                out[0] = Math.max(a[0], b[0]);
                out[1] = Math.max(a[1], b[1]);
                out[2] = Math.max(a[2], b[2]);
                out[3] = Math.max(a[3], b[3]);
                return out;
            };

            /**
             * Scales a vec4 by a scalar number
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the vector to scale
             * @param {Number} b amount to scale the vector by
             * @returns {vec4} out
             */
            vec4.scale = function(out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                out[2] = a[2] * b;
                out[3] = a[3] * b;
                return out;
            };

            /**
             * Adds two vec4&#039;s after scaling the second operand by a scalar value
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @param {Number} scale the amount to scale b by before adding
             * @returns {vec4} out
             */
            vec4.scaleAndAdd = function(out, a, b, scale) {
                out[0] = a[0] + (b[0] * scale);
                out[1] = a[1] + (b[1] * scale);
                out[2] = a[2] + (b[2] * scale);
                out[3] = a[3] + (b[3] * scale);
                return out;
            };

            /**
             * Calculates the euclidian distance between two vec4&#039;s
             *
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {Number} distance between a and b
             */
            vec4.distance = function(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1],
                    z = b[2] - a[2],
                    w = b[3] - a[3];
                return Math.sqrt(x*x + y*y + z*z + w*w);
            };

            /**
             * Alias for {@link vec4.distance}
             * @function
             */
            vec4.dist = vec4.distance;

            /**
             * Calculates the squared euclidian distance between two vec4&#039;s
             *
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {Number} squared distance between a and b
             */
            vec4.squaredDistance = function(a, b) {
                var x = b[0] - a[0],
                    y = b[1] - a[1],
                    z = b[2] - a[2],
                    w = b[3] - a[3];
                return x*x + y*y + z*z + w*w;
            };

            /**
             * Alias for {@link vec4.squaredDistance}
             * @function
             */
            vec4.sqrDist = vec4.squaredDistance;

            /**
             * Calculates the length of a vec4
             *
             * @param {vec4} a vector to calculate length of
             * @returns {Number} length of a
             */
            vec4.length = function (a) {
                var x = a[0],
                    y = a[1],
                    z = a[2],
                    w = a[3];
                return Math.sqrt(x*x + y*y + z*z + w*w);
            };

            /**
             * Alias for {@link vec4.length}
             * @function
             */
            vec4.len = vec4.length;

            /**
             * Calculates the squared length of a vec4
             *
             * @param {vec4} a vector to calculate squared length of
             * @returns {Number} squared length of a
             */
            vec4.squaredLength = function (a) {
                var x = a[0],
                    y = a[1],
                    z = a[2],
                    w = a[3];
                return x*x + y*y + z*z + w*w;
            };

            /**
             * Alias for {@link vec4.squaredLength}
             * @function
             */
            vec4.sqrLen = vec4.squaredLength;

            /**
             * Negates the components of a vec4
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a vector to negate
             * @returns {vec4} out
             */
            vec4.negate = function(out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                out[2] = -a[2];
                out[3] = -a[3];
                return out;
            };

            /**
             * Normalize a vec4
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a vector to normalize
             * @returns {vec4} out
             */
            vec4.normalize = function(out, a) {
                var x = a[0],
                    y = a[1],
                    z = a[2],
                    w = a[3];
                var len = x*x + y*y + z*z + w*w;
                if (len &gt; 0) {
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                    out[2] = a[2] * len;
                    out[3] = a[3] * len;
                }
                return out;
            };

            /**
             * Calculates the dot product of two vec4&#039;s
             *
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @returns {Number} dot product of a and b
             */
            vec4.dot = function (a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
            };

            /**
             * Performs a linear interpolation between two vec4&#039;s
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the first operand
             * @param {vec4} b the second operand
             * @param {Number} t interpolation amount between the two inputs
             * @returns {vec4} out
             */
            vec4.lerp = function (out, a, b, t) {
                var ax = a[0],
                    ay = a[1],
                    az = a[2],
                    aw = a[3];
                out[0] = ax + t * (b[0] - ax);
                out[1] = ay + t * (b[1] - ay);
                out[2] = az + t * (b[2] - az);
                out[3] = aw + t * (b[3] - aw);
                return out;
            };

            /**
             * Generates a random vector with the given scale
             *
             * @param {vec4} out the receiving vector
             * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
             * @returns {vec4} out
             */
            vec4.random = function (out, scale) {
                scale = scale || 1.0;

                //TODO: This is a pretty awful way of doing this. Find something better.
                out[0] = GLMAT_RANDOM();
                out[1] = GLMAT_RANDOM();
                out[2] = GLMAT_RANDOM();
                out[3] = GLMAT_RANDOM();
                vec4.normalize(out, out);
                vec4.scale(out, out, scale);
                return out;
            };

            /**
             * Transforms the vec4 with a mat4.
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the vector to transform
             * @param {mat4} m matrix to transform with
             * @returns {vec4} out
             */
            vec4.transformMat4 = function(out, a, m) {
                var x = a[0], y = a[1], z = a[2], w = a[3];
                out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
                out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
                out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
                out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
                return out;
            };

            /**
             * Transforms the vec4 with a quat
             *
             * @param {vec4} out the receiving vector
             * @param {vec4} a the vector to transform
             * @param {quat} q quaternion to transform with
             * @returns {vec4} out
             */
            vec4.transformQuat = function(out, a, q) {
                var x = a[0], y = a[1], z = a[2],
                    qx = q[0], qy = q[1], qz = q[2], qw = q[3],

                // calculate quat * vec
                    ix = qw * x + qy * z - qz * y,
                    iy = qw * y + qz * x - qx * z,
                    iz = qw * z + qx * y - qy * x,
                    iw = -qx * x - qy * y - qz * z;

                // calculate result * inverse quat
                out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                return out;
            };

            /**
             * Perform some operation over an array of vec4s.
             *
             * @param {Array} a the array of vectors to iterate over
             * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
             * @param {Number} offset Number of elements to skip at the beginning of the array
             * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
             * @param {Function} fn Function to call for each vector in the array
             * @param {Object} [arg] additional argument to pass to fn
             * @returns {Array} a
             * @function
             */
            vec4.forEach = (function() {
                var vec = vec4.create();

                return function(a, stride, offset, count, fn, arg) {
                    var i, l;
                    if(!stride) {
                        stride = 4;
                    }

                    if(!offset) {
                        offset = 0;
                    }

                    if(count) {
                        l = Math.min((count * stride) + offset, a.length);
                    } else {
                        l = a.length;
                    }

                    for(i = offset; i &lt; l; i += stride) {
                        vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
                        fn(vec, vec, arg);
                        a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
                    }

                    return a;
                };
            })();

            /**
             * Returns a string representation of a vector
             *
             * @param {vec4} vec vector to represent as a string
             * @returns {String} string representation of the vector
             */
            vec4.str = function (a) {
                return &#039;vec4(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;, &#039; + a[3] + &#039;)&#039;;
            };

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.vec4 = vec4;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 2x2 Matrix
             * @name mat2
             */

            var mat2 = {};

            /**
             * Creates a new identity mat2
             *
             * @returns {mat2} a new 2x2 matrix
             */
            mat2.create = function() {
                var out = new GLMAT_ARRAY_TYPE(4);
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                return out;
            };

            /**
             * Creates a new mat2 initialized with values from an existing matrix
             *
             * @param {mat2} a matrix to clone
             * @returns {mat2} a new 2x2 matrix
             */
            mat2.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(4);
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                return out;
            };

            /**
             * Copy the values from one mat2 to another
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the source matrix
             * @returns {mat2} out
             */
            mat2.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                return out;
            };

            /**
             * Set a mat2 to the identity matrix
             *
             * @param {mat2} out the receiving matrix
             * @returns {mat2} out
             */
            mat2.identity = function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                return out;
            };

            /**
             * Transpose the values of a mat2
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the source matrix
             * @returns {mat2} out
             */
            mat2.transpose = function(out, a) {
                // If we are transposing ourselves we can skip a few steps but have to cache some values
                if (out === a) {
                    var a1 = a[1];
                    out[1] = a[2];
                    out[2] = a1;
                } else {
                    out[0] = a[0];
                    out[1] = a[2];
                    out[2] = a[1];
                    out[3] = a[3];
                }

                return out;
            };

            /**
             * Inverts a mat2
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the source matrix
             * @returns {mat2} out
             */
            mat2.invert = function(out, a) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

                // Calculate the determinant
                    det = a0 * a3 - a2 * a1;

                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] =  a3 * det;
                out[1] = -a1 * det;
                out[2] = -a2 * det;
                out[3] =  a0 * det;

                return out;
            };

            /**
             * Calculates the adjugate of a mat2
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the source matrix
             * @returns {mat2} out
             */
            mat2.adjoint = function(out, a) {
                // Caching this value is nessecary if out == a
                var a0 = a[0];
                out[0] =  a[3];
                out[1] = -a[1];
                out[2] = -a[2];
                out[3] =  a0;

                return out;
            };

            /**
             * Calculates the determinant of a mat2
             *
             * @param {mat2} a the source matrix
             * @returns {Number} determinant of a
             */
            mat2.determinant = function (a) {
                return a[0] * a[3] - a[2] * a[1];
            };

            /**
             * Multiplies two mat2&#039;s
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the first operand
             * @param {mat2} b the second operand
             * @returns {mat2} out
             */
            mat2.multiply = function (out, a, b) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
                var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = a0 * b0 + a2 * b1;
                out[1] = a1 * b0 + a3 * b1;
                out[2] = a0 * b2 + a2 * b3;
                out[3] = a1 * b2 + a3 * b3;
                return out;
            };

            /**
             * Alias for {@link mat2.multiply}
             * @function
             */
            mat2.mul = mat2.multiply;

            /**
             * Rotates a mat2 by the given angle
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat2} out
             */
            mat2.rotate = function (out, a, rad) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                    s = Math.sin(rad),
                    c = Math.cos(rad);
                out[0] = a0 *  c + a2 * s;
                out[1] = a1 *  c + a3 * s;
                out[2] = a0 * -s + a2 * c;
                out[3] = a1 * -s + a3 * c;
                return out;
            };

            /**
             * Scales the mat2 by the dimensions in the given vec2
             *
             * @param {mat2} out the receiving matrix
             * @param {mat2} a the matrix to rotate
             * @param {vec2} v the vec2 to scale the matrix by
             * @returns {mat2} out
             **/
            mat2.scale = function(out, a, v) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                    v0 = v[0], v1 = v[1];
                out[0] = a0 * v0;
                out[1] = a1 * v0;
                out[2] = a2 * v1;
                out[3] = a3 * v1;
                return out;
            };

            /**
             * Returns a string representation of a mat2
             *
             * @param {mat2} mat matrix to represent as a string
             * @returns {String} string representation of the matrix
             */
            mat2.str = function (a) {
                return &#039;mat2(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;, &#039; + a[3] + &#039;)&#039;;
            };

            /**
             * Returns Frobenius norm of a mat2
             *
             * @param {mat2} a the matrix to calculate Frobenius norm of
             * @returns {Number} Frobenius norm
             */
            mat2.frob = function (a) {
                return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
            };

            /**
             * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
             * @param {mat2} L the lower triangular matrix
             * @param {mat2} D the diagonal matrix
             * @param {mat2} U the upper triangular matrix
             * @param {mat2} a the input matrix to factorize
             */

            mat2.LDU = function (L, D, U, a) {
                L[2] = a[2]/a[0];
                U[0] = a[0];
                U[1] = a[1];
                U[3] = a[3] - L[2] * U[1];
                return [L, D, U];
            };

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.mat2 = mat2;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 2x3 Matrix
             * @name mat2d
             *
             * @description
             * A mat2d contains six elements defined as:
             * &lt;pre&gt;
             * [a, c, tx,
             *  b, d, ty]
             * &lt;/pre&gt;
             * This is a short form for the 3x3 matrix:
             * &lt;pre&gt;
             * [a, c, tx,
             *  b, d, ty,
             *  0, 0, 1]
             * &lt;/pre&gt;
             * The last row is ignored so the array is shorter and operations are faster.
             */

            var mat2d = {};

            /**
             * Creates a new identity mat2d
             *
             * @returns {mat2d} a new 2x3 matrix
             */
            mat2d.create = function() {
                var out = new GLMAT_ARRAY_TYPE(6);
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                out[4] = 0;
                out[5] = 0;
                return out;
            };

            /**
             * Creates a new mat2d initialized with values from an existing matrix
             *
             * @param {mat2d} a matrix to clone
             * @returns {mat2d} a new 2x3 matrix
             */
            mat2d.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(6);
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                return out;
            };

            /**
             * Copy the values from one mat2d to another
             *
             * @param {mat2d} out the receiving matrix
             * @param {mat2d} a the source matrix
             * @returns {mat2d} out
             */
            mat2d.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                return out;
            };

            /**
             * Set a mat2d to the identity matrix
             *
             * @param {mat2d} out the receiving matrix
             * @returns {mat2d} out
             */
            mat2d.identity = function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                out[4] = 0;
                out[5] = 0;
                return out;
            };

            /**
             * Inverts a mat2d
             *
             * @param {mat2d} out the receiving matrix
             * @param {mat2d} a the source matrix
             * @returns {mat2d} out
             */
            mat2d.invert = function(out, a) {
                var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
                    atx = a[4], aty = a[5];

                var det = aa * ad - ab * ac;
                if(!det){
                    return null;
                }
                det = 1.0 / det;

                out[0] = ad * det;
                out[1] = -ab * det;
                out[2] = -ac * det;
                out[3] = aa * det;
                out[4] = (ac * aty - ad * atx) * det;
                out[5] = (ab * atx - aa * aty) * det;
                return out;
            };

            /**
             * Calculates the determinant of a mat2d
             *
             * @param {mat2d} a the source matrix
             * @returns {Number} determinant of a
             */
            mat2d.determinant = function (a) {
                return a[0] * a[3] - a[1] * a[2];
            };

            /**
             * Multiplies two mat2d&#039;s
             *
             * @param {mat2d} out the receiving matrix
             * @param {mat2d} a the first operand
             * @param {mat2d} b the second operand
             * @returns {mat2d} out
             */
            mat2d.multiply = function (out, a, b) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                    b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
                out[0] = a0 * b0 + a2 * b1;
                out[1] = a1 * b0 + a3 * b1;
                out[2] = a0 * b2 + a2 * b3;
                out[3] = a1 * b2 + a3 * b3;
                out[4] = a0 * b4 + a2 * b5 + a4;
                out[5] = a1 * b4 + a3 * b5 + a5;
                return out;
            };

            /**
             * Alias for {@link mat2d.multiply}
             * @function
             */
            mat2d.mul = mat2d.multiply;


            /**
             * Rotates a mat2d by the given angle
             *
             * @param {mat2d} out the receiving matrix
             * @param {mat2d} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat2d} out
             */
            mat2d.rotate = function (out, a, rad) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                    s = Math.sin(rad),
                    c = Math.cos(rad);
                out[0] = a0 *  c + a2 * s;
                out[1] = a1 *  c + a3 * s;
                out[2] = a0 * -s + a2 * c;
                out[3] = a1 * -s + a3 * c;
                out[4] = a4;
                out[5] = a5;
                return out;
            };

            /**
             * Scales the mat2d by the dimensions in the given vec2
             *
             * @param {mat2d} out the receiving matrix
             * @param {mat2d} a the matrix to translate
             * @param {vec2} v the vec2 to scale the matrix by
             * @returns {mat2d} out
             **/
            mat2d.scale = function(out, a, v) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                    v0 = v[0], v1 = v[1];
                out[0] = a0 * v0;
                out[1] = a1 * v0;
                out[2] = a2 * v1;
                out[3] = a3 * v1;
                out[4] = a4;
                out[5] = a5;
                return out;
            };

            /**
             * Translates the mat2d by the dimensions in the given vec2
             *
             * @param {mat2d} out the receiving matrix
             * @param {mat2d} a the matrix to translate
             * @param {vec2} v the vec2 to translate the matrix by
             * @returns {mat2d} out
             **/
            mat2d.translate = function(out, a, v) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
                    v0 = v[0], v1 = v[1];
                out[0] = a0;
                out[1] = a1;
                out[2] = a2;
                out[3] = a3;
                out[4] = a0 * v0 + a2 * v1 + a4;
                out[5] = a1 * v0 + a3 * v1 + a5;
                return out;
            };

            /**
             * Returns a string representation of a mat2d
             *
             * @param {mat2d} a matrix to represent as a string
             * @returns {String} string representation of the matrix
             */
            mat2d.str = function (a) {
                return &#039;mat2d(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;, &#039; +
                    a[3] + &#039;, &#039; + a[4] + &#039;, &#039; + a[5] + &#039;)&#039;;
            };

            /**
             * Returns Frobenius norm of a mat2d
             *
             * @param {mat2d} a the matrix to calculate Frobenius norm of
             * @returns {Number} Frobenius norm
             */
            mat2d.frob = function (a) {
                return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
            };

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.mat2d = mat2d;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 3x3 Matrix
             * @name mat3
             */

            var mat3 = {};

            /**
             * Creates a new identity mat3
             *
             * @returns {mat3} a new 3x3 matrix
             */
            mat3.create = function() {
                var out = new GLMAT_ARRAY_TYPE(9);
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 1;
                out[5] = 0;
                out[6] = 0;
                out[7] = 0;
                out[8] = 1;
                return out;
            };

            /**
             * Copies the upper-left 3x3 values into the given mat3.
             *
             * @param {mat3} out the receiving 3x3 matrix
             * @param {mat4} a   the source 4x4 matrix
             * @returns {mat3} out
             */
            mat3.fromMat4 = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[4];
                out[4] = a[5];
                out[5] = a[6];
                out[6] = a[8];
                out[7] = a[9];
                out[8] = a[10];
                return out;
            };

            /**
             * Creates a new mat3 initialized with values from an existing matrix
             *
             * @param {mat3} a matrix to clone
             * @returns {mat3} a new 3x3 matrix
             */
            mat3.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(9);
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                return out;
            };

            /**
             * Copy the values from one mat3 to another
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the source matrix
             * @returns {mat3} out
             */
            mat3.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                return out;
            };

            /**
             * Set a mat3 to the identity matrix
             *
             * @param {mat3} out the receiving matrix
             * @returns {mat3} out
             */
            mat3.identity = function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 1;
                out[5] = 0;
                out[6] = 0;
                out[7] = 0;
                out[8] = 1;
                return out;
            };

            /**
             * Transpose the values of a mat3
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the source matrix
             * @returns {mat3} out
             */
            mat3.transpose = function(out, a) {
                // If we are transposing ourselves we can skip a few steps but have to cache some values
                if (out === a) {
                    var a01 = a[1], a02 = a[2], a12 = a[5];
                    out[1] = a[3];
                    out[2] = a[6];
                    out[3] = a01;
                    out[5] = a[7];
                    out[6] = a02;
                    out[7] = a12;
                } else {
                    out[0] = a[0];
                    out[1] = a[3];
                    out[2] = a[6];
                    out[3] = a[1];
                    out[4] = a[4];
                    out[5] = a[7];
                    out[6] = a[2];
                    out[7] = a[5];
                    out[8] = a[8];
                }

                return out;
            };

            /**
             * Inverts a mat3
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the source matrix
             * @returns {mat3} out
             */
            mat3.invert = function(out, a) {
                var a00 = a[0], a01 = a[1], a02 = a[2],
                    a10 = a[3], a11 = a[4], a12 = a[5],
                    a20 = a[6], a21 = a[7], a22 = a[8],

                    b01 = a22 * a11 - a12 * a21,
                    b11 = -a22 * a10 + a12 * a20,
                    b21 = a21 * a10 - a11 * a20,

                // Calculate the determinant
                    det = a00 * b01 + a01 * b11 + a02 * b21;

                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = b01 * det;
                out[1] = (-a22 * a01 + a02 * a21) * det;
                out[2] = (a12 * a01 - a02 * a11) * det;
                out[3] = b11 * det;
                out[4] = (a22 * a00 - a02 * a20) * det;
                out[5] = (-a12 * a00 + a02 * a10) * det;
                out[6] = b21 * det;
                out[7] = (-a21 * a00 + a01 * a20) * det;
                out[8] = (a11 * a00 - a01 * a10) * det;
                return out;
            };

            /**
             * Calculates the adjugate of a mat3
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the source matrix
             * @returns {mat3} out
             */
            mat3.adjoint = function(out, a) {
                var a00 = a[0], a01 = a[1], a02 = a[2],
                    a10 = a[3], a11 = a[4], a12 = a[5],
                    a20 = a[6], a21 = a[7], a22 = a[8];

                out[0] = (a11 * a22 - a12 * a21);
                out[1] = (a02 * a21 - a01 * a22);
                out[2] = (a01 * a12 - a02 * a11);
                out[3] = (a12 * a20 - a10 * a22);
                out[4] = (a00 * a22 - a02 * a20);
                out[5] = (a02 * a10 - a00 * a12);
                out[6] = (a10 * a21 - a11 * a20);
                out[7] = (a01 * a20 - a00 * a21);
                out[8] = (a00 * a11 - a01 * a10);
                return out;
            };

            /**
             * Calculates the determinant of a mat3
             *
             * @param {mat3} a the source matrix
             * @returns {Number} determinant of a
             */
            mat3.determinant = function (a) {
                var a00 = a[0], a01 = a[1], a02 = a[2],
                    a10 = a[3], a11 = a[4], a12 = a[5],
                    a20 = a[6], a21 = a[7], a22 = a[8];

                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
            };

            /**
             * Multiplies two mat3&#039;s
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the first operand
             * @param {mat3} b the second operand
             * @returns {mat3} out
             */
            mat3.multiply = function (out, a, b) {
                var a00 = a[0], a01 = a[1], a02 = a[2],
                    a10 = a[3], a11 = a[4], a12 = a[5],
                    a20 = a[6], a21 = a[7], a22 = a[8],

                    b00 = b[0], b01 = b[1], b02 = b[2],
                    b10 = b[3], b11 = b[4], b12 = b[5],
                    b20 = b[6], b21 = b[7], b22 = b[8];

                out[0] = b00 * a00 + b01 * a10 + b02 * a20;
                out[1] = b00 * a01 + b01 * a11 + b02 * a21;
                out[2] = b00 * a02 + b01 * a12 + b02 * a22;

                out[3] = b10 * a00 + b11 * a10 + b12 * a20;
                out[4] = b10 * a01 + b11 * a11 + b12 * a21;
                out[5] = b10 * a02 + b11 * a12 + b12 * a22;

                out[6] = b20 * a00 + b21 * a10 + b22 * a20;
                out[7] = b20 * a01 + b21 * a11 + b22 * a21;
                out[8] = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
            };

            /**
             * Alias for {@link mat3.multiply}
             * @function
             */
            mat3.mul = mat3.multiply;

            /**
             * Translate a mat3 by the given vector
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the matrix to translate
             * @param {vec2} v vector to translate by
             * @returns {mat3} out
             */
            mat3.translate = function(out, a, v) {
                var a00 = a[0], a01 = a[1], a02 = a[2],
                    a10 = a[3], a11 = a[4], a12 = a[5],
                    a20 = a[6], a21 = a[7], a22 = a[8],
                    x = v[0], y = v[1];

                out[0] = a00;
                out[1] = a01;
                out[2] = a02;

                out[3] = a10;
                out[4] = a11;
                out[5] = a12;

                out[6] = x * a00 + y * a10 + a20;
                out[7] = x * a01 + y * a11 + a21;
                out[8] = x * a02 + y * a12 + a22;
                return out;
            };

            /**
             * Rotates a mat3 by the given angle
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat3} out
             */
            mat3.rotate = function (out, a, rad) {
                var a00 = a[0], a01 = a[1], a02 = a[2],
                    a10 = a[3], a11 = a[4], a12 = a[5],
                    a20 = a[6], a21 = a[7], a22 = a[8],

                    s = Math.sin(rad),
                    c = Math.cos(rad);

                out[0] = c * a00 + s * a10;
                out[1] = c * a01 + s * a11;
                out[2] = c * a02 + s * a12;

                out[3] = c * a10 - s * a00;
                out[4] = c * a11 - s * a01;
                out[5] = c * a12 - s * a02;

                out[6] = a20;
                out[7] = a21;
                out[8] = a22;
                return out;
            };

            /**
             * Scales the mat3 by the dimensions in the given vec2
             *
             * @param {mat3} out the receiving matrix
             * @param {mat3} a the matrix to rotate
             * @param {vec2} v the vec2 to scale the matrix by
             * @returns {mat3} out
             **/
            mat3.scale = function(out, a, v) {
                var x = v[0], y = v[1];

                out[0] = x * a[0];
                out[1] = x * a[1];
                out[2] = x * a[2];

                out[3] = y * a[3];
                out[4] = y * a[4];
                out[5] = y * a[5];

                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                return out;
            };

            /**
             * Copies the values from a mat2d into a mat3
             *
             * @param {mat3} out the receiving matrix
             * @param {mat2d} a the matrix to copy
             * @returns {mat3} out
             **/
            mat3.fromMat2d = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = 0;

                out[3] = a[2];
                out[4] = a[3];
                out[5] = 0;

                out[6] = a[4];
                out[7] = a[5];
                out[8] = 1;
                return out;
            };

            /**
             * Calculates a 3x3 matrix from the given quaternion
             *
             * @param {mat3} out mat3 receiving operation result
             * @param {quat} q Quaternion to create matrix from
             *
             * @returns {mat3} out
             */
            mat3.fromQuat = function (out, q) {
                var x = q[0], y = q[1], z = q[2], w = q[3],
                    x2 = x + x,
                    y2 = y + y,
                    z2 = z + z,

                    xx = x * x2,
                    yx = y * x2,
                    yy = y * y2,
                    zx = z * x2,
                    zy = z * y2,
                    zz = z * z2,
                    wx = w * x2,
                    wy = w * y2,
                    wz = w * z2;

                out[0] = 1 - yy - zz;
                out[3] = yx - wz;
                out[6] = zx + wy;

                out[1] = yx + wz;
                out[4] = 1 - xx - zz;
                out[7] = zy - wx;

                out[2] = zx - wy;
                out[5] = zy + wx;
                out[8] = 1 - xx - yy;

                return out;
            };

            /**
             * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
             *
             * @param {mat3} out mat3 receiving operation result
             * @param {mat4} a Mat4 to derive the normal matrix from
             *
             * @returns {mat3} out
             */
            mat3.normalFromMat4 = function (out, a) {
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                    b00 = a00 * a11 - a01 * a10,
                    b01 = a00 * a12 - a02 * a10,
                    b02 = a00 * a13 - a03 * a10,
                    b03 = a01 * a12 - a02 * a11,
                    b04 = a01 * a13 - a03 * a11,
                    b05 = a02 * a13 - a03 * a12,
                    b06 = a20 * a31 - a21 * a30,
                    b07 = a20 * a32 - a22 * a30,
                    b08 = a20 * a33 - a23 * a30,
                    b09 = a21 * a32 - a22 * a31,
                    b10 = a21 * a33 - a23 * a31,
                    b11 = a22 * a33 - a23 * a32,

                // Calculate the determinant
                    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

                out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

                out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

                return out;
            };

            /**
             * Returns a string representation of a mat3
             *
             * @param {mat3} mat matrix to represent as a string
             * @returns {String} string representation of the matrix
             */
            mat3.str = function (a) {
                return &#039;mat3(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;, &#039; +
                    a[3] + &#039;, &#039; + a[4] + &#039;, &#039; + a[5] + &#039;, &#039; +
                    a[6] + &#039;, &#039; + a[7] + &#039;, &#039; + a[8] + &#039;)&#039;;
            };

            /**
             * Returns Frobenius norm of a mat3
             *
             * @param {mat3} a the matrix to calculate Frobenius norm of
             * @returns {Number} Frobenius norm
             */
            mat3.frob = function (a) {
                return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
            };


            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.mat3 = mat3;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class 4x4 Matrix
             * @name mat4
             */

            var mat4 = {};

            /**
             * Creates a new identity mat4
             *
             * @returns {mat4} a new 4x4 matrix
             */
            mat4.create = function() {
                var out = new GLMAT_ARRAY_TYPE(16);
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 1;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 1;
                out[11] = 0;
                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;
                return out;
            };

            /**
             * Creates a new mat4 initialized with values from an existing matrix
             *
             * @param {mat4} a matrix to clone
             * @returns {mat4} a new 4x4 matrix
             */
            mat4.clone = function(a) {
                var out = new GLMAT_ARRAY_TYPE(16);
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                out[9] = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
                return out;
            };

            /**
             * Copy the values from one mat4 to another
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the source matrix
             * @returns {mat4} out
             */
            mat4.copy = function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                out[9] = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
                return out;
            };

            /**
             * Set a mat4 to the identity matrix
             *
             * @param {mat4} out the receiving matrix
             * @returns {mat4} out
             */
            mat4.identity = function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 1;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 1;
                out[11] = 0;
                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;
                return out;
            };

            /**
             * Transpose the values of a mat4
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the source matrix
             * @returns {mat4} out
             */
            mat4.transpose = function(out, a) {
                // If we are transposing ourselves we can skip a few steps but have to cache some values
                if (out === a) {
                    var a01 = a[1], a02 = a[2], a03 = a[3],
                        a12 = a[6], a13 = a[7],
                        a23 = a[11];

                    out[1] = a[4];
                    out[2] = a[8];
                    out[3] = a[12];
                    out[4] = a01;
                    out[6] = a[9];
                    out[7] = a[13];
                    out[8] = a02;
                    out[9] = a12;
                    out[11] = a[14];
                    out[12] = a03;
                    out[13] = a13;
                    out[14] = a23;
                } else {
                    out[0] = a[0];
                    out[1] = a[4];
                    out[2] = a[8];
                    out[3] = a[12];
                    out[4] = a[1];
                    out[5] = a[5];
                    out[6] = a[9];
                    out[7] = a[13];
                    out[8] = a[2];
                    out[9] = a[6];
                    out[10] = a[10];
                    out[11] = a[14];
                    out[12] = a[3];
                    out[13] = a[7];
                    out[14] = a[11];
                    out[15] = a[15];
                }

                return out;
            };

            /**
             * Inverts a mat4
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the source matrix
             * @returns {mat4} out
             */
            mat4.invert = function(out, a) {
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                    b00 = a00 * a11 - a01 * a10,
                    b01 = a00 * a12 - a02 * a10,
                    b02 = a00 * a13 - a03 * a10,
                    b03 = a01 * a12 - a02 * a11,
                    b04 = a01 * a13 - a03 * a11,
                    b05 = a02 * a13 - a03 * a12,
                    b06 = a20 * a31 - a21 * a30,
                    b07 = a20 * a32 - a22 * a30,
                    b08 = a20 * a33 - a23 * a30,
                    b09 = a21 * a32 - a22 * a31,
                    b10 = a21 * a33 - a23 * a31,
                    b11 = a22 * a33 - a23 * a32,

                // Calculate the determinant
                    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

                return out;
            };

            /**
             * Calculates the adjugate of a mat4
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the source matrix
             * @returns {mat4} out
             */
            mat4.adjoint = function(out, a) {
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
                out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
                out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
                out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
                out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
                out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
                out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
                out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
                out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
                out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
                out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
                out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
                out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
                out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
                out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
                out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
                return out;
            };

            /**
             * Calculates the determinant of a mat4
             *
             * @param {mat4} a the source matrix
             * @returns {Number} determinant of a
             */
            mat4.determinant = function (a) {
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

                    b00 = a00 * a11 - a01 * a10,
                    b01 = a00 * a12 - a02 * a10,
                    b02 = a00 * a13 - a03 * a10,
                    b03 = a01 * a12 - a02 * a11,
                    b04 = a01 * a13 - a03 * a11,
                    b05 = a02 * a13 - a03 * a12,
                    b06 = a20 * a31 - a21 * a30,
                    b07 = a20 * a32 - a22 * a30,
                    b08 = a20 * a33 - a23 * a30,
                    b09 = a21 * a32 - a22 * a31,
                    b10 = a21 * a33 - a23 * a31,
                    b11 = a22 * a33 - a23 * a32;

                // Calculate the determinant
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            };

            /**
             * Multiplies two mat4&#039;s
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the first operand
             * @param {mat4} b the second operand
             * @returns {mat4} out
             */
            mat4.multiply = function (out, a, b) {
                var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                // Cache only the current line of the second matrix
                var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                return out;
            };

            /**
             * Alias for {@link mat4.multiply}
             * @function
             */
            mat4.mul = mat4.multiply;

            /**
             * Translate a mat4 by the given vector
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the matrix to translate
             * @param {vec3} v vector to translate by
             * @returns {mat4} out
             */
            mat4.translate = function (out, a, v) {
                var x = v[0], y = v[1], z = v[2],
                    a00, a01, a02, a03,
                    a10, a11, a12, a13,
                    a20, a21, a22, a23;

                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }

                return out;
            };

            /**
             * Scales the mat4 by the dimensions in the given vec3
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the matrix to scale
             * @param {vec3} v the vec3 to scale the matrix by
             * @returns {mat4} out
             **/
            mat4.scale = function(out, a, v) {
                var x = v[0], y = v[1], z = v[2];

                out[0] = a[0] * x;
                out[1] = a[1] * x;
                out[2] = a[2] * x;
                out[3] = a[3] * x;
                out[4] = a[4] * y;
                out[5] = a[5] * y;
                out[6] = a[6] * y;
                out[7] = a[7] * y;
                out[8] = a[8] * z;
                out[9] = a[9] * z;
                out[10] = a[10] * z;
                out[11] = a[11] * z;
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
                return out;
            };

            /**
             * Rotates a mat4 by the given angle
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @param {vec3} axis the axis to rotate around
             * @returns {mat4} out
             */
            mat4.rotate = function (out, a, rad, axis) {
                var x = axis[0], y = axis[1], z = axis[2],
                    len = Math.sqrt(x * x + y * y + z * z),
                    s, c, t,
                    a00, a01, a02, a03,
                    a10, a11, a12, a13,
                    a20, a21, a22, a23,
                    b00, b01, b02,
                    b10, b11, b12,
                    b20, b21, b22;

                if (Math.abs(len) &lt; GLMAT_EPSILON) { return null; }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;

                s = Math.sin(rad);
                c = Math.cos(rad);
                t = 1 - c;

                a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                // Construct the elements of the rotation matrix
                b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
                b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
                b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

                // Perform rotation-specific matrix multiplication
                out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                out[11] = a03 * b20 + a13 * b21 + a23 * b22;

                if (a !== out) { // If the source and destination differ, copy the unchanged last row
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }
                return out;
            };

            /**
             * Rotates a matrix by the given angle around the X axis
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat4} out
             */
            mat4.rotateX = function (out, a, rad) {
                var s = Math.sin(rad),
                    c = Math.cos(rad),
                    a10 = a[4],
                    a11 = a[5],
                    a12 = a[6],
                    a13 = a[7],
                    a20 = a[8],
                    a21 = a[9],
                    a22 = a[10],
                    a23 = a[11];

                if (a !== out) { // If the source and destination differ, copy the unchanged rows
                    out[0]  = a[0];
                    out[1]  = a[1];
                    out[2]  = a[2];
                    out[3]  = a[3];
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }

                // Perform axis-specific matrix multiplication
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                return out;
            };

            /**
             * Rotates a matrix by the given angle around the Y axis
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat4} out
             */
            mat4.rotateY = function (out, a, rad) {
                var s = Math.sin(rad),
                    c = Math.cos(rad),
                    a00 = a[0],
                    a01 = a[1],
                    a02 = a[2],
                    a03 = a[3],
                    a20 = a[8],
                    a21 = a[9],
                    a22 = a[10],
                    a23 = a[11];

                if (a !== out) { // If the source and destination differ, copy the unchanged rows
                    out[4]  = a[4];
                    out[5]  = a[5];
                    out[6]  = a[6];
                    out[7]  = a[7];
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }

                // Perform axis-specific matrix multiplication
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                return out;
            };

            /**
             * Rotates a matrix by the given angle around the Z axis
             *
             * @param {mat4} out the receiving matrix
             * @param {mat4} a the matrix to rotate
             * @param {Number} rad the angle to rotate the matrix by
             * @returns {mat4} out
             */
            mat4.rotateZ = function (out, a, rad) {
                var s = Math.sin(rad),
                    c = Math.cos(rad),
                    a00 = a[0],
                    a01 = a[1],
                    a02 = a[2],
                    a03 = a[3],
                    a10 = a[4],
                    a11 = a[5],
                    a12 = a[6],
                    a13 = a[7];

                if (a !== out) { // If the source and destination differ, copy the unchanged last row
                    out[8]  = a[8];
                    out[9]  = a[9];
                    out[10] = a[10];
                    out[11] = a[11];
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }

                // Perform axis-specific matrix multiplication
                out[0] = a00 * c + a10 * s;
                out[1] = a01 * c + a11 * s;
                out[2] = a02 * c + a12 * s;
                out[3] = a03 * c + a13 * s;
                out[4] = a10 * c - a00 * s;
                out[5] = a11 * c - a01 * s;
                out[6] = a12 * c - a02 * s;
                out[7] = a13 * c - a03 * s;
                return out;
            };

            /**
             * Creates a matrix from a quaternion rotation and vector translation
             * This is equivalent to (but much faster than):
             *
             *     mat4.identity(dest);
             *     mat4.translate(dest, vec);
             *     var quatMat = mat4.create();
             *     quat4.toMat4(quat, quatMat);
             *     mat4.multiply(dest, quatMat);
             *
             * @param {mat4} out mat4 receiving operation result
             * @param {quat4} q Rotation quaternion
             * @param {vec3} v Translation vector
             * @returns {mat4} out
             */
            mat4.fromRotationTranslation = function (out, q, v) {
                // Quaternion math
                var x = q[0], y = q[1], z = q[2], w = q[3],
                    x2 = x + x,
                    y2 = y + y,
                    z2 = z + z,

                    xx = x * x2,
                    xy = x * y2,
                    xz = x * z2,
                    yy = y * y2,
                    yz = y * z2,
                    zz = z * z2,
                    wx = w * x2,
                    wy = w * y2,
                    wz = w * z2;

                out[0] = 1 - (yy + zz);
                out[1] = xy + wz;
                out[2] = xz - wy;
                out[3] = 0;
                out[4] = xy - wz;
                out[5] = 1 - (xx + zz);
                out[6] = yz + wx;
                out[7] = 0;
                out[8] = xz + wy;
                out[9] = yz - wx;
                out[10] = 1 - (xx + yy);
                out[11] = 0;
                out[12] = v[0];
                out[13] = v[1];
                out[14] = v[2];
                out[15] = 1;

                return out;
            };

            mat4.fromQuat = function (out, q) {
                var x = q[0], y = q[1], z = q[2], w = q[3],
                    x2 = x + x,
                    y2 = y + y,
                    z2 = z + z,

                    xx = x * x2,
                    yx = y * x2,
                    yy = y * y2,
                    zx = z * x2,
                    zy = z * y2,
                    zz = z * z2,
                    wx = w * x2,
                    wy = w * y2,
                    wz = w * z2;

                out[0] = 1 - yy - zz;
                out[1] = yx + wz;
                out[2] = zx - wy;
                out[3] = 0;

                out[4] = yx - wz;
                out[5] = 1 - xx - zz;
                out[6] = zy + wx;
                out[7] = 0;

                out[8] = zx + wy;
                out[9] = zy - wx;
                out[10] = 1 - xx - yy;
                out[11] = 0;

                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;

                return out;
            };

            /**
             * Generates a frustum matrix with the given bounds
             *
             * @param {mat4} out mat4 frustum matrix will be written into
             * @param {Number} left Left bound of the frustum
             * @param {Number} right Right bound of the frustum
             * @param {Number} bottom Bottom bound of the frustum
             * @param {Number} top Top bound of the frustum
             * @param {Number} near Near bound of the frustum
             * @param {Number} far Far bound of the frustum
             * @returns {mat4} out
             */
            mat4.frustum = function (out, left, right, bottom, top, near, far) {
                var rl = 1 / (right - left),
                    tb = 1 / (top - bottom),
                    nf = 1 / (near - far);
                out[0] = (near * 2) * rl;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = (near * 2) * tb;
                out[6] = 0;
                out[7] = 0;
                out[8] = (right + left) * rl;
                out[9] = (top + bottom) * tb;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (far * near * 2) * nf;
                out[15] = 0;
                return out;
            };

            /**
             * Generates a perspective projection matrix with the given bounds
             *
             * @param {mat4} out mat4 frustum matrix will be written into
             * @param {number} fovy Vertical field of view in radians
             * @param {number} aspect Aspect ratio. typically viewport width/height
             * @param {number} near Near bound of the frustum
             * @param {number} far Far bound of the frustum
             * @returns {mat4} out
             */
            mat4.perspective = function (out, fovy, aspect, near, far) {
                var f = 1.0 / Math.tan(fovy / 2),
                    nf = 1 / (near - far);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                return out;
            };

            /**
             * Generates a orthogonal projection matrix with the given bounds
             *
             * @param {mat4} out mat4 frustum matrix will be written into
             * @param {number} left Left bound of the frustum
             * @param {number} right Right bound of the frustum
             * @param {number} bottom Bottom bound of the frustum
             * @param {number} top Top bound of the frustum
             * @param {number} near Near bound of the frustum
             * @param {number} far Far bound of the frustum
             * @returns {mat4} out
             */
            mat4.ortho = function (out, left, right, bottom, top, near, far) {
                var lr = 1 / (left - right),
                    bt = 1 / (bottom - top),
                    nf = 1 / (near - far);
                out[0] = -2 * lr;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = -2 * bt;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 2 * nf;
                out[11] = 0;
                out[12] = (left + right) * lr;
                out[13] = (top + bottom) * bt;
                out[14] = (far + near) * nf;
                out[15] = 1;
                return out;
            };

            /**
             * Generates a look-at matrix with the given eye position, focal point, and up axis
             *
             * @param {mat4} out mat4 frustum matrix will be written into
             * @param {vec3} eye Position of the viewer
             * @param {vec3} center Point the viewer is looking at
             * @param {vec3} up vec3 pointing up
             * @returns {mat4} out
             */
            mat4.lookAt = function (out, eye, center, up) {
                var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
                    eyex = eye[0],
                    eyey = eye[1],
                    eyez = eye[2],
                    upx = up[0],
                    upy = up[1],
                    upz = up[2],
                    centerx = center[0],
                    centery = center[1],
                    centerz = center[2];

                if (Math.abs(eyex - centerx) &lt; GLMAT_EPSILON &amp;&amp;
                    Math.abs(eyey - centery) &lt; GLMAT_EPSILON &amp;&amp;
                    Math.abs(eyez - centerz) &lt; GLMAT_EPSILON) {
                    return mat4.identity(out);
                }

                z0 = eyex - centerx;
                z1 = eyey - centery;
                z2 = eyez - centerz;

                len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len;
                z1 *= len;
                z2 *= len;

                x0 = upy * z2 - upz * z1;
                x1 = upz * z0 - upx * z2;
                x2 = upx * z1 - upy * z0;
                len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                if (!len) {
                    x0 = 0;
                    x1 = 0;
                    x2 = 0;
                } else {
                    len = 1 / len;
                    x0 *= len;
                    x1 *= len;
                    x2 *= len;
                }

                y0 = z1 * x2 - z2 * x1;
                y1 = z2 * x0 - z0 * x2;
                y2 = z0 * x1 - z1 * x0;

                len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                if (!len) {
                    y0 = 0;
                    y1 = 0;
                    y2 = 0;
                } else {
                    len = 1 / len;
                    y0 *= len;
                    y1 *= len;
                    y2 *= len;
                }

                out[0] = x0;
                out[1] = y0;
                out[2] = z0;
                out[3] = 0;
                out[4] = x1;
                out[5] = y1;
                out[6] = z1;
                out[7] = 0;
                out[8] = x2;
                out[9] = y2;
                out[10] = z2;
                out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;

                return out;
            };

            /**
             * Returns a string representation of a mat4
             *
             * @param {mat4} mat matrix to represent as a string
             * @returns {String} string representation of the matrix
             */
            mat4.str = function (a) {
                return &#039;mat4(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;, &#039; + a[3] + &#039;, &#039; +
                    a[4] + &#039;, &#039; + a[5] + &#039;, &#039; + a[6] + &#039;, &#039; + a[7] + &#039;, &#039; +
                    a[8] + &#039;, &#039; + a[9] + &#039;, &#039; + a[10] + &#039;, &#039; + a[11] + &#039;, &#039; +
                    a[12] + &#039;, &#039; + a[13] + &#039;, &#039; + a[14] + &#039;, &#039; + a[15] + &#039;)&#039;;
            };

            /**
             * Returns Frobenius norm of a mat4
             *
             * @param {mat4} a the matrix to calculate Frobenius norm of
             * @returns {Number} Frobenius norm
             */
            mat4.frob = function (a) {
                return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
            };


            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.mat4 = mat4;
            }
            ;
            /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

             Redistribution and use in source and binary forms, with or without modification,
             are permitted provided that the following conditions are met:

             * Redistributions of source code must retain the above copyright notice, this
             list of conditions and the following disclaimer.
             * Redistributions in binary form must reproduce the above copyright notice,
             this list of conditions and the following disclaimer in the documentation 
             and/or other materials provided with the distribution.

             THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
             ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
             WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
             DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
             ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
             (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
             LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
             ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
             (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
             SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

            /**
             * @class Quaternion
             * @name quat
             */

            var quat = {};

            /**
             * Creates a new identity quat
             *
             * @returns {quat} a new quaternion
             */
            quat.create = function() {
                var out = new GLMAT_ARRAY_TYPE(4);
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                return out;
            };

            /**
             * Sets a quaternion to represent the shortest rotation from one
             * vector to another.
             *
             * Both vectors are assumed to be unit length.
             *
             * @param {quat} out the receiving quaternion.
             * @param {vec3} a the initial vector
             * @param {vec3} b the destination vector
             * @returns {quat} out
             */
            quat.rotationTo = (function() {
                var tmpvec3 = vec3.create();
                var xUnitVec3 = vec3.fromValues(1,0,0);
                var yUnitVec3 = vec3.fromValues(0,1,0);

                return function(out, a, b) {
                    var dot = vec3.dot(a, b);
                    if (dot &lt; -0.999999) {
                        vec3.cross(tmpvec3, xUnitVec3, a);
                        if (vec3.length(tmpvec3) &lt; 0.000001)
                            vec3.cross(tmpvec3, yUnitVec3, a);
                        vec3.normalize(tmpvec3, tmpvec3);
                        quat.setAxisAngle(out, tmpvec3, Math.PI);
                        return out;
                    } else if (dot &gt; 0.999999) {
                        out[0] = 0;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 1;
                        return out;
                    } else {
                        vec3.cross(tmpvec3, a, b);
                        out[0] = tmpvec3[0];
                        out[1] = tmpvec3[1];
                        out[2] = tmpvec3[2];
                        out[3] = 1 + dot;
                        return quat.normalize(out, out);
                    }
                };
            })();

            /**
             * Sets the specified quaternion with values corresponding to the given
             * axes. Each axis is a vec3 and is expected to be unit length and
             * perpendicular to all other specified axes.
             *
             * @param {vec3} view  the vector representing the viewing direction
             * @param {vec3} right the vector representing the local &quot;right&quot; direction
             * @param {vec3} up    the vector representing the local &quot;up&quot; direction
             * @returns {quat} out
             */
            quat.setAxes = (function() {
                var matr = mat3.create();

                return function(out, view, right, up) {
                    matr[0] = right[0];
                    matr[3] = right[1];
                    matr[6] = right[2];

                    matr[1] = up[0];
                    matr[4] = up[1];
                    matr[7] = up[2];

                    matr[2] = -view[0];
                    matr[5] = -view[1];
                    matr[8] = -view[2];

                    return quat.normalize(out, quat.fromMat3(out, matr));
                };
            })();

            /**
             * Creates a new quat initialized with values from an existing quaternion
             *
             * @param {quat} a quaternion to clone
             * @returns {quat} a new quaternion
             * @function
             */
            quat.clone = vec4.clone;

            /**
             * Creates a new quat initialized with the given values
             *
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @param {Number} w W component
             * @returns {quat} a new quaternion
             * @function
             */
            quat.fromValues = vec4.fromValues;

            /**
             * Copy the values from one quat to another
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a the source quaternion
             * @returns {quat} out
             * @function
             */
            quat.copy = vec4.copy;

            /**
             * Set the components of a quat to the given values
             *
             * @param {quat} out the receiving quaternion
             * @param {Number} x X component
             * @param {Number} y Y component
             * @param {Number} z Z component
             * @param {Number} w W component
             * @returns {quat} out
             * @function
             */
            quat.set = vec4.set;

            /**
             * Set a quat to the identity quaternion
             *
             * @param {quat} out the receiving quaternion
             * @returns {quat} out
             */
            quat.identity = function(out) {
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                return out;
            };

            /**
             * Sets a quat from the given angle and rotation axis,
             * then returns it.
             *
             * @param {quat} out the receiving quaternion
             * @param {vec3} axis the axis around which to rotate
             * @param {Number} rad the angle in radians
             * @returns {quat} out
             **/
            quat.setAxisAngle = function(out, axis, rad) {
                rad = rad * 0.5;
                var s = Math.sin(rad);
                out[0] = s * axis[0];
                out[1] = s * axis[1];
                out[2] = s * axis[2];
                out[3] = Math.cos(rad);
                return out;
            };

            /**
             * Adds two quat&#039;s
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a the first operand
             * @param {quat} b the second operand
             * @returns {quat} out
             * @function
             */
            quat.add = vec4.add;

            /**
             * Multiplies two quat&#039;s
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a the first operand
             * @param {quat} b the second operand
             * @returns {quat} out
             */
            quat.multiply = function(out, a, b) {
                var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                    bx = b[0], by = b[1], bz = b[2], bw = b[3];

                out[0] = ax * bw + aw * bx + ay * bz - az * by;
                out[1] = ay * bw + aw * by + az * bx - ax * bz;
                out[2] = az * bw + aw * bz + ax * by - ay * bx;
                out[3] = aw * bw - ax * bx - ay * by - az * bz;
                return out;
            };

            /**
             * Alias for {@link quat.multiply}
             * @function
             */
            quat.mul = quat.multiply;

            /**
             * Scales a quat by a scalar number
             *
             * @param {quat} out the receiving vector
             * @param {quat} a the vector to scale
             * @param {Number} b amount to scale the vector by
             * @returns {quat} out
             * @function
             */
            quat.scale = vec4.scale;

            /**
             * Rotates a quaternion by the given angle about the X axis
             *
             * @param {quat} out quat receiving operation result
             * @param {quat} a quat to rotate
             * @param {number} rad angle (in radians) to rotate
             * @returns {quat} out
             */
            quat.rotateX = function (out, a, rad) {
                rad *= 0.5;

                var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                    bx = Math.sin(rad), bw = Math.cos(rad);

                out[0] = ax * bw + aw * bx;
                out[1] = ay * bw + az * bx;
                out[2] = az * bw - ay * bx;
                out[3] = aw * bw - ax * bx;
                return out;
            };

            /**
             * Rotates a quaternion by the given angle about the Y axis
             *
             * @param {quat} out quat receiving operation result
             * @param {quat} a quat to rotate
             * @param {number} rad angle (in radians) to rotate
             * @returns {quat} out
             */
            quat.rotateY = function (out, a, rad) {
                rad *= 0.5;

                var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                    by = Math.sin(rad), bw = Math.cos(rad);

                out[0] = ax * bw - az * by;
                out[1] = ay * bw + aw * by;
                out[2] = az * bw + ax * by;
                out[3] = aw * bw - ay * by;
                return out;
            };

            /**
             * Rotates a quaternion by the given angle about the Z axis
             *
             * @param {quat} out quat receiving operation result
             * @param {quat} a quat to rotate
             * @param {number} rad angle (in radians) to rotate
             * @returns {quat} out
             */
            quat.rotateZ = function (out, a, rad) {
                rad *= 0.5;

                var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                    bz = Math.sin(rad), bw = Math.cos(rad);

                out[0] = ax * bw + ay * bz;
                out[1] = ay * bw - ax * bz;
                out[2] = az * bw + aw * bz;
                out[3] = aw * bw - az * bz;
                return out;
            };

            /**
             * Calculates the W component of a quat from the X, Y, and Z components.
             * Assumes that quaternion is 1 unit in length.
             * Any existing W component will be ignored.
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a quat to calculate W component of
             * @returns {quat} out
             */
            quat.calculateW = function (out, a) {
                var x = a[0], y = a[1], z = a[2];

                out[0] = x;
                out[1] = y;
                out[2] = z;
                out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
                return out;
            };

            /**
             * Calculates the dot product of two quat&#039;s
             *
             * @param {quat} a the first operand
             * @param {quat} b the second operand
             * @returns {Number} dot product of a and b
             * @function
             */
            quat.dot = vec4.dot;

            /**
             * Performs a linear interpolation between two quat&#039;s
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a the first operand
             * @param {quat} b the second operand
             * @param {Number} t interpolation amount between the two inputs
             * @returns {quat} out
             * @function
             */
            quat.lerp = vec4.lerp;

            /**
             * Performs a spherical linear interpolation between two quat
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a the first operand
             * @param {quat} b the second operand
             * @param {Number} t interpolation amount between the two inputs
             * @returns {quat} out
             */
            quat.slerp = function (out, a, b, t) {
                // benchmarks:
                //    http://jsperf.com/quaternion-slerp-implementations

                var ax = a[0], ay = a[1], az = a[2], aw = a[3],
                    bx = b[0], by = b[1], bz = b[2], bw = b[3];

                var        omega, cosom, sinom, scale0, scale1;

                // calc cosine
                cosom = ax * bx + ay * by + az * bz + aw * bw;
                // adjust signs (if necessary)
                if ( cosom &lt; 0.0 ) {
                    cosom = -cosom;
                    bx = - bx;
                    by = - by;
                    bz = - bz;
                    bw = - bw;
                }
                // calculate coefficients
                if ( (1.0 - cosom) &gt; 0.000001 ) {
                    // standard case (slerp)
                    omega  = Math.acos(cosom);
                    sinom  = Math.sin(omega);
                    scale0 = Math.sin((1.0 - t) * omega) / sinom;
                    scale1 = Math.sin(t * omega) / sinom;
                } else {
                    // &quot;from&quot; and &quot;to&quot; quaternions are very close 
                    //  ... so we can do a linear interpolation
                    scale0 = 1.0 - t;
                    scale1 = t;
                }
                // calculate final values
                out[0] = scale0 * ax + scale1 * bx;
                out[1] = scale0 * ay + scale1 * by;
                out[2] = scale0 * az + scale1 * bz;
                out[3] = scale0 * aw + scale1 * bw;

                return out;
            };

            /**
             * Calculates the inverse of a quat
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a quat to calculate inverse of
             * @returns {quat} out
             */
            quat.invert = function(out, a) {
                var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
                    dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
                    invDot = dot ? 1.0/dot : 0;

                // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

                out[0] = -a0*invDot;
                out[1] = -a1*invDot;
                out[2] = -a2*invDot;
                out[3] = a3*invDot;
                return out;
            };

            /**
             * Calculates the conjugate of a quat
             * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a quat to calculate conjugate of
             * @returns {quat} out
             */
            quat.conjugate = function (out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                out[2] = -a[2];
                out[3] = a[3];
                return out;
            };

            /**
             * Calculates the length of a quat
             *
             * @param {quat} a vector to calculate length of
             * @returns {Number} length of a
             * @function
             */
            quat.length = vec4.length;

            /**
             * Alias for {@link quat.length}
             * @function
             */
            quat.len = quat.length;

            /**
             * Calculates the squared length of a quat
             *
             * @param {quat} a vector to calculate squared length of
             * @returns {Number} squared length of a
             * @function
             */
            quat.squaredLength = vec4.squaredLength;

            /**
             * Alias for {@link quat.squaredLength}
             * @function
             */
            quat.sqrLen = quat.squaredLength;

            /**
             * Normalize a quat
             *
             * @param {quat} out the receiving quaternion
             * @param {quat} a quaternion to normalize
             * @returns {quat} out
             * @function
             */
            quat.normalize = vec4.normalize;

            /**
             * Creates a quaternion from the given 3x3 rotation matrix.
             *
             * NOTE: The resultant quaternion is not normalized, so you should be sure
             * to renormalize the quaternion yourself where necessary.
             *
             * @param {quat} out the receiving quaternion
             * @param {mat3} m rotation matrix
             * @returns {quat} out
             * @function
             */
            quat.fromMat3 = function(out, m) {
                // Algorithm in Ken Shoemake&#039;s article in 1987 SIGGRAPH course notes
                // article &quot;Quaternion Calculus and Fast Animation&quot;.
                var fTrace = m[0] + m[4] + m[8];
                var fRoot;

                if ( fTrace &gt; 0.0 ) {
                    // |w| &gt; 1/2, may as well choose w &gt; 1/2
                    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
                    out[3] = 0.5 * fRoot;
                    fRoot = 0.5/fRoot;  // 1/(4w)
                    out[0] = (m[7]-m[5])*fRoot;
                    out[1] = (m[2]-m[6])*fRoot;
                    out[2] = (m[3]-m[1])*fRoot;
                } else {
                    // |w| &lt;= 1/2
                    var i = 0;
                    if ( m[4] &gt; m[0] )
                        i = 1;
                    if ( m[8] &gt; m[i*3+i] )
                        i = 2;
                    var j = (i+1)%3;
                    var k = (i+2)%3;

                    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
                    out[i] = 0.5 * fRoot;
                    fRoot = 0.5 / fRoot;
                    out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
                    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
                    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
                }

                return out;
            };

            /**
             * Returns a string representation of a quatenion
             *
             * @param {quat} vec vector to represent as a string
             * @returns {String} string representation of the vector
             */
            quat.str = function (a) {
                return &#039;quat(&#039; + a[0] + &#039;, &#039; + a[1] + &#039;, &#039; + a[2] + &#039;, &#039; + a[3] + &#039;)&#039;;
            };

            if(typeof(exports) !== &#039;undefined&#039;) {
                exports.quat = quat;
            }
            ;













        })(shim.exports);
    })(this);

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-function/index.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    function constant(value) {
        return function() {
            return value;
        }
    }

    function interpolateNumber(a, b, t) {
        return (a * (1 - t)) + (b * t);
    }

    function interpolateArray(a, b, t) {
        var result = [];
        for (var i = 0; i &lt; a.length; i++) {
            result[i] = interpolateNumber(a[i], b[i], t);
        }
        return result;
    }

    exports[&#039;interpolated&#039;] = function(f) {
        if (!f.stops) {
            return constant(f);
        }

        var stops = f.stops,
            base = f.base || 1,
            interpolate = Array.isArray(stops[0][1]) ? interpolateArray : interpolateNumber;

        return function(z) {
            // find the two stops which the current z is between
            var low, high;

            for (var i = 0; i &lt; stops.length; i++) {
                var stop = stops[i];

                if (stop[0] &lt;= z) {
                    low = stop;
                }

                if (stop[0] &gt; z) {
                    high = stop;
                    break;
                }
            }

            if (low &amp;&amp; high) {
                var zoomDiff = high[0] - low[0],
                    zoomProgress = z - low[0],

                    t = base === 1 ?
                        zoomProgress / zoomDiff :
                        (Math.pow(base, zoomProgress) - 1) / (Math.pow(base, zoomDiff) - 1);

                return interpolate(low[1], high[1], t);

            } else if (low) {
                return low[1];

            } else if (high) {
                return high[1];
            }
        };
    };

    exports[&#039;piecewise-constant&#039;] = function(f) {
        if (!f.stops) {
            return constant(f);
        }

        var stops = f.stops;

        return function(z) {
            for (var i = 0; i &lt; stops.length; i++) {
                if (stops[i][0] &gt; z) {
                    return stops[i === 0 ? 0 : i - 1][1];
                }
            }

            return stops[stops.length - 1][1];
        }
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/lib/validate/latest.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var reference = require(&#039;../../reference/latest.js&#039;);
    var validate = require(&#039;./parsed&#039;);

    module.exports = function(style) {
        return validate(style, reference);
    };

},{&quot;../../reference/latest.js&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/reference/latest.js&quot;,&quot;./parsed&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/lib/validate/parsed.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/lib/validate/parsed.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var parseCSSColor = require(&#039;csscolorparser&#039;).parseCSSColor;
    var format = require(&#039;util&#039;).format;

    module.exports = function(style, reference) {

        var constants = style.constants || {},
            layers = {},
            errors = [];

        function error(key, val /*, message, ...*/) {
            var err = {
                message: (key ? key + &#039;: &#039; : &#039;&#039;) +
                    format.apply(format, Array.prototype.slice.call(arguments, 2))
            };

            if (val !== null &amp;&amp; val !== undefined &amp;&amp; val.__line__) {
                err.line = val.__line__;
            }

            errors.push(err);
        }

        // Main recursive validation function. Tracks:
        //
        // - key: string representing location of validation in style tree. Used only
        //   for more informative error reporting.
        // - val: current value from style being evaluated. May be anything from a
        //   high level object that needs to be descended into deeper or a simple
        //   scalar value.
        // - spec: current spec being evaluated. Tracks val.
        //
        function validate(key, val, spec) {
            var type = typeof_(val);

            // Constants
            if (type === &#039;string&#039; &amp;&amp; val[0] === &#039;@&#039;) {
                if (!(val in constants)) {
                    return error(key, val, &#039;constant &quot;%s&quot; not found&#039;, val);
                }
                val = constants[val];
                type = typeof_(val);
            }

            // Functions
            if (spec.function &amp;&amp; type === &#039;object&#039;) {
                return validate.function(key, val, spec);
            }

            if (spec.type) {
                var validator = validate[spec.type];
                if (validator) {
                    return validator(key, val, spec);
                }
                spec = reference[spec.type];
            }

            validate.object(key, val, spec);
        }

        validate.constants = function(key, val) {
            var type = typeof_(val);
            if (type !== &#039;object&#039;) {
                return error(key, val, &#039;object expected, %s found&#039;, type);
            }

            for (var k in val) {
                if (k[0] !== &#039;@&#039;) {
                    error(key + &#039;.&#039; + k, val[k], &#039;constants must start with &quot;@&quot;&#039;);
                }
            }
        };

        validate.source = function(key, val) {
            if (!val.type) {
                error(key, val, &#039;&quot;type&quot; is required&#039;);
                return;
            }

            var type = unbundle(val.type);
            switch (type) {
                case &#039;vector&#039;:
                case &#039;raster&#039;:
                    validate.object(key, val, reference.source_tile);

                    if (&#039;url&#039; in val) {
                        for (var prop in val) {
                            if ([&#039;type&#039;, &#039;url&#039;, &#039;tileSize&#039;].indexOf(prop) &lt; 0) {
                                error(key + &#039;.&#039; + prop, val[prop], &#039;a source with a &quot;url&quot; property may not include a &quot;%s&quot; property&#039;, prop);
                            }
                        }
                    }

                    break;
                case &#039;geojson&#039;:
                    validate.object(key, val, reference.source_geojson);
                    break;
                case &#039;video&#039;:
                    validate.object(key, val, reference.source_video);
                    break;
                default:
                    validate.enum(key + &#039;.type&#039;, val.type, {values: [&#039;vector&#039;, &#039;raster&#039;, &#039;geojson&#039;, &#039;video&#039;]});
            }
        };

        validate.layer = function(key, val) {
            if (!val.type &amp;&amp; !val.ref) {
                error(key, val, &#039;either &quot;type&quot; or &quot;ref&quot; is required&#039;);
            }

            var type = unbundle(val.type),
                ref = unbundle(val.ref);

            if (val.id) {
                if (layers[val.id]) {
                    error(key, val.id, &#039;duplicate layer id &quot;%s&quot;, previously used at line %d&#039;, val.id, layers[val.id]);
                } else {
                    layers[val.id] = val.id.__line__;
                }
            }

            if (&#039;ref&#039; in val) {
                [&#039;type&#039;, &#039;source&#039;, &#039;source-layer&#039;, &#039;filter&#039;, &#039;layout&#039;].forEach(function (p) {
                    if (p in val) {
                        error(key, val[p], &#039;&quot;%s&quot; is prohibited for ref layers&#039;, p);
                    }
                });

                var parent;

                style.layers.forEach(function(layer) {
                    if (layer.id == ref) parent = layer;
                });

                if (!parent) {
                    error(key, val.ref, &#039;ref layer &quot;%s&quot; not found&#039;, ref);
                } else if (parent.ref) {
                    error(key, val.ref, &#039;ref cannot reference another ref layer&#039;);
                } else {
                    type = parent.type;
                }
            } else if (type !== &#039;background&#039;) {
                if (!val.source) {
                    error(key, val, &#039;missing required property &quot;source&quot;&#039;);
                } else {
                    var source = style.sources[val.source];
                    if (!source) {
                        error(key, val.source, &#039;source &quot;%s&quot; not found&#039;, val.source);
                    } else if (source.type == &#039;vector&#039; &amp;&amp; type == &#039;raster&#039;) {
                        error(key, val.source, &#039;layer &quot;%s&quot; requires a raster source&#039;, val.id);
                    } else if (source.type == &#039;raster&#039; &amp;&amp; type != &#039;raster&#039;) {
                        error(key, val.source, &#039;layer &quot;%s&quot; requires a vector source&#039;, val.id);
                    }
                }
            }

            validate.object(key, val, reference.layer, {
                filter: validate.filter,
                layout: function(key, val) {
                    var spec = reference[&#039;layout_&#039; + type];
                    return type &amp;&amp; spec &amp;&amp; validate(key, val, spec);
                },
                paint: function(key, val) {
                    var spec = reference[&#039;paint_&#039; + type];
                    return type &amp;&amp; spec &amp;&amp; validate(key, val, spec);
                }
            });
        };

        validate.object = function (key, val, spec, validators) {
            validators = validators || {};

            var type = typeof_(val);
            if (type !== &#039;object&#039;) {
                return error(key, val, &#039;object expected, %s found&#039;, type);
            }

            for (var k in val) {
                var speckey = k.split(&#039;.&#039;)[0]; // treat &#039;paint.*&#039; as &#039;paint&#039;
                var def = spec[speckey] || spec[&#039;*&#039;];
                var transition = speckey.match(/^(.*)-transition$/);

                if (def) {
                    (validators[speckey] || validate)((key ? key + &#039;.&#039; : key) + k, val[k], def);
                } else if (transition &amp;&amp; spec[transition[1]] &amp;&amp; spec[transition[1]].transition) {
                    validate((key ? key + &#039;.&#039; : key) + k, val[k], reference.transition);
                    // tolerate root-level extra keys &amp; arbitrary layer properties
                } else if (key !== &#039;&#039; &amp;&amp; key.split(&#039;.&#039;).length !== 1) {
                    error(key, val[k], &#039;unknown property &quot;%s&quot;&#039;, k);
                }
            }

            for (var l in spec) {
                if (spec[l].required &amp;&amp; spec[l][&#039;default&#039;] === undefined &amp;&amp; val[l] === undefined) {
                    error(key, val, &#039;missing required property &quot;%s&quot;&#039;, l);
                }
            }
        };

        validate.array = function (key, val, spec, validator) {
            if (typeof_(val) !== &#039;array&#039;) {
                return error(key, val, &#039;array expected, %s found&#039;, typeof_(val));
            }

            if (spec.length &amp;&amp; val.length !== spec.length) {
                return error(key, val, &#039;array length %d expected, length %d found&#039;, spec.length, val.length);
            }

            var value = {
                &quot;type&quot;: spec.value
            };

            if (style.version &lt; 7) {
                value.function = spec.function;
            }

            if (typeof_(spec.value) === &#039;object&#039;) {
                value = spec.value;
            }

            for (var i = 0; i &lt; val.length; i++) {
                (validator || validate)(key + &#039;[&#039; + i + &#039;]&#039;, val[i], value);
            }
        };

        validate.filter = function(key, val) {
            var type;

            if (typeof_(val) !== &#039;array&#039;) {
                return error(key, val, &#039;array expected, %s found&#039;, typeof_(val));
            }

            if (val.length &lt; 1) {
                return error(key, val, &#039;filter array must have at least 1 element&#039;);
            }

            validate.enum(key + &#039;[0]&#039;, val[0], reference.filter_operator);

            switch (unbundle(val[0])) {
                case &#039;&lt;&#039;:
                case &#039;&lt;=&#039;:
                case &#039;&gt;&#039;:
                case &#039;&gt;=&#039;:
                    if (val.length &gt;= 2 &amp;&amp; val[1] == &#039;$type&#039;) {
                        error(key, val, &#039;&quot;$type&quot; cannot be use with operator &quot;%s&quot;&#039;, val[0]);
                    }
                /* falls through */
                case &#039;==&#039;:
                case &#039;!=&#039;:
                    if (val.length != 3) {
                        error(key, val, &#039;filter array for operator &quot;%s&quot; must have 3 elements&#039;, val[0]);
                    }
                /* falls through */
                case &#039;in&#039;:
                case &#039;!in&#039;:
                    if (val.length &gt;= 2) {
                        type = typeof_(val[1]);
                        if (type !== &#039;string&#039;) {
                            error(key + &#039;[1]&#039;, val[1], &#039;string expected, %s found&#039;, type);
                        } else if (val[1][0] === &#039;@&#039;) {
                            error(key + &#039;[1]&#039;, val[1], &#039;filter key cannot be a constant&#039;);
                        }
                    }
                    for (var i = 2; i &lt; val.length; i++) {
                        type = typeof_(val[i]);
                        if (val[1] == &#039;$type&#039;) {
                            validate.enum(key + &#039;[&#039; + i + &#039;]&#039;, val[i], reference.geometry_type);
                        } else if (type === &#039;string&#039; &amp;&amp; val[i][0] === &#039;@&#039;) {
                            error(key + &#039;[&#039; + i + &#039;]&#039;, val[i], &#039;filter value cannot be a constant&#039;);
                        } else if (type !== &#039;string&#039; &amp;&amp; type !== &#039;number&#039; &amp;&amp; type !== &#039;boolean&#039;) {
                            error(key + &#039;[&#039; + i + &#039;]&#039;, val[i], &#039;string, number, or boolean expected, %s found&#039;, type);
                        }
                    }
                    break;

                case &#039;any&#039;:
                case &#039;all&#039;:
                case &#039;none&#039;:
                    for (i = 1; i &lt; val.length; i++) {
                        validate.filter(key + &#039;[&#039; + i + &#039;]&#039;, val[i]);
                    }
                    break;
            }
        };

        validate.function = function(key, val, spec) {
            validate.object(key, val, reference.function, {
                stops: function (key, val, arraySpec) {
                    var lastStop = -Infinity;
                    validate.array(key, val, arraySpec, function validateStop(key, val) {
                        if (typeof_(val) !== &#039;array&#039;) {
                            return error(key, val, &#039;array expected, %s found&#039;, typeof_(val));
                        }

                        if (val.length !== 2) {
                            return error(key, val, &#039;array length %d expected, length %d found&#039;, 2, val.length);
                        }

                        validate(key + &#039;[0]&#039;, val[0], {type: &#039;number&#039;});
                        validate(key + &#039;[1]&#039;, val[1], spec);

                        if (typeof_(val[0]) === &#039;number&#039;) {
                            if (spec.function === &#039;piecewise-constant&#039; &amp;&amp; val[0] % 1 !== 0) {
                                error(key + &#039;[0]&#039;, val[0], &#039;zoom level for piecewise-constant functions must be an integer&#039;);
                            }

                            if (val[0] &lt; lastStop) {
                                error(key + &#039;[0]&#039;, val[0], &#039;array stops must appear in ascending order&#039;);
                            }

                            lastStop = val[0];
                        }
                    });

                    if (typeof_(val) === &#039;array&#039; &amp;&amp; val.length === 0) {
                        error(key, val, &#039;array must have at least one stop&#039;);
                    }
                }
            });
        };

        validate.enum = function (key, val, spec) {
            if (spec.values.indexOf(unbundle(val)) === -1) {
                error(key, val, &#039;expected one of [%s], %s found&#039;, spec.values.join(&#039;, &#039;), val);
            }
        };

        validate.color = function(key, val) {
            var type = typeof_(val);
            if (type !== &#039;string&#039;) {
                error(key, val, &#039;color expected, %s found&#039;, type);
            } else if (parseCSSColor(val) === null) {
                error(key, val, &#039;color expected, &quot;%s&quot; found&#039;, val);
            }
        };

        function typeValidator(expected) {
            return function(key, val, spec) {
                var actual = typeof_(val);
                if (actual !== expected) {
                    error(key, val, &#039;%s expected, %s found&#039;, expected, actual);
                }

                if (&#039;minimum&#039; in spec &amp;&amp; val &lt; spec.minimum) {
                    error(key, val, &#039;%s is less than the minimum value %s&#039;, val, spec.minimum);
                }

                if (&#039;maximum&#039; in spec &amp;&amp; val &gt; spec.maximum) {
                    error(key, val, &#039;%s is greater than the maximum value %s&#039;, val, spec.maximum);
                }
            };
        }

        validate.number = typeValidator(&#039;number&#039;);
        validate.string = typeValidator(&#039;string&#039;);
        validate.boolean = typeValidator(&#039;boolean&#039;);

        validate[&#039;*&#039;] = function() {};

        validate(&#039;&#039;, style, reference.$root);

        return errors;
    };

    function typeof_(val) {
        if (val instanceof Number)
            return &#039;number&#039;;
        if (val instanceof String)
            return &#039;string&#039;;
        if (val instanceof Boolean)
            return &#039;boolean&#039;;
        if (Array.isArray(val))
            return &#039;array&#039;;
        if (val === null)
            return &#039;null&#039;;
        return typeof val;
    }

    function unbundle(_) {
        if (_ instanceof Number ||
            _ instanceof String ||
            _ instanceof Boolean) {
            return _.valueOf();
        } else {
            return _;
        }
    }

},{&quot;csscolorparser&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/csscolorparser/csscolorparser.js&quot;,&quot;util&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/util/util.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/reference/latest.js&quot;:[function(require,module,exports){
    module.exports = require(&#039;./v7.json&#039;);

},{&quot;./v7.json&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/reference/v7.json&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/mapbox-gl-style-spec/reference/v7.json&quot;:[function(require,module,exports){
    module.exports={
        &quot;$version&quot;: 7,
        &quot;$root&quot;: {
            &quot;version&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;enum&quot;,
                &quot;values&quot;: [
                    7
                ],
                &quot;doc&quot;: &quot;Stylesheet version number. Must be 7.&quot;
            },
            &quot;name&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;A human-readable name for the style.&quot;
            },
            &quot;constants&quot;: {
                &quot;type&quot;: &quot;constants&quot;,
                &quot;doc&quot;: &quot;An object of constants to be referenced in layers.&quot;
            },
            &quot;sources&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;sources&quot;,
                &quot;doc&quot;: &quot;Data source specifications.&quot;
            },
            &quot;sprite&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended.&quot;
            },
            &quot;glyphs&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;A URL template for loading signed-distance-field glyph sets in PBF format. Valid tokens are {fontstack} and {range}.&quot;
            },
            &quot;transition&quot;: {
                &quot;type&quot;: &quot;transition&quot;,
                &quot;doc&quot;: &quot;A global transition definition to use as a default across properties.&quot;
            },
            &quot;layers&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;layer&quot;,
                &quot;doc&quot;: &quot;Layers will be drawn in the order of this array.&quot;
            }
        },
        &quot;constants&quot;: {
            &quot;*&quot;: {
                &quot;type&quot;: &quot;*&quot;,
                &quot;doc&quot;: &quot;A constant that will be replaced verbatim in the referencing place. This can be anything, including objects and arrays. All variable names must be prefixed with an `@` symbol.&quot;
            }
        },
        &quot;sources&quot;: {
            &quot;*&quot;: {
                &quot;type&quot;: &quot;source&quot;,
                &quot;doc&quot;: &quot;Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided.&quot;
            }
        },
        &quot;source&quot;: [
            &quot;source_tile&quot;,
            &quot;source_geojson&quot;,
            &quot;source_video&quot;
        ],
        &quot;source_tile&quot;: {
            &quot;type&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;enum&quot;,
                &quot;values&quot;: [
                    &quot;vector&quot;,
                    &quot;raster&quot;
                ],
                &quot;doc&quot;: &quot;The data type of the source.&quot;
            },
            &quot;url&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://&lt;mapid&gt;`.&quot;
            },
            &quot;tiles&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;An array of one or more tile source URLs, as in the TileJSON spec.&quot;
            },
            &quot;minzoom&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;doc&quot;: &quot;Minimum zoom level for which tiles are available, as in the TileJSON spec.&quot;
            },
            &quot;maxzoom&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 22,
                &quot;doc&quot;: &quot;Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels.&quot;
            },
            &quot;tileSize&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 512,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;The minimum visual size to display tiles for this layer. Only configurable for raster layers.&quot;
            },
            &quot;*&quot;: {
                &quot;type&quot;: &quot;*&quot;,
                &quot;doc&quot;: &quot;Other keys to configure the data source.&quot;
            }
        },
        &quot;source_geojson&quot;: {
            &quot;type&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;enum&quot;,
                &quot;values&quot;: [
                    &quot;geojson&quot;
                ]
            },
            &quot;data&quot;: {
                &quot;type&quot;: &quot;*&quot;
            }
        },
        &quot;source_video&quot;: {
            &quot;type&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;enum&quot;,
                &quot;values&quot;: [
                    &quot;video&quot;
                ]
            },
            &quot;url&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;URLs to video content in order of preferred format.&quot;
            },
            &quot;coordinates&quot;: {
                &quot;required&quot;: true,
                &quot;type&quot;: &quot;array&quot;,
                &quot;length&quot;: 4,
                &quot;value&quot;: {
                    &quot;type&quot;: &quot;array&quot;,
                    &quot;length&quot;: 2,
                    &quot;value&quot;: &quot;number&quot;
                }
            }
        },
        &quot;layer&quot;: {
            &quot;id&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;Unique layer name.&quot;
            },
            &quot;type&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;values&quot;: [
                    &quot;fill&quot;,
                    &quot;line&quot;,
                    &quot;symbol&quot;,
                    &quot;raster&quot;,
                    &quot;background&quot;
                ],
                &quot;doc&quot;: &quot;Rendering type of this layer.&quot;
            },
            &quot;ref&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient.&quot;
            },
            &quot;source&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;Name of a source description to be used for this layer.&quot;
            },
            &quot;source-layer&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;doc&quot;: &quot;Layer to use from a vector tile source. Required if the source supports multiple layers.&quot;
            },
            &quot;minzoom&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 22,
                &quot;doc&quot;: &quot;The minimum zoom level on which the layer gets parsed and appears on.&quot;
            },
            &quot;maxzoom&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 22,
                &quot;doc&quot;: &quot;The maximum zoom level on which the layer gets parsed and appears on.&quot;
            },
            &quot;interactive&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;doc&quot;: &quot;Enable querying of feature data from this layer for interactivity.&quot;,
                &quot;default&quot;: false
            },
            &quot;filter&quot;: {
                &quot;type&quot;: &quot;filter&quot;,
                &quot;doc&quot;: &quot;A expression specifying conditions on source features. Only features that match the filter are displayed.&quot;
            },
            &quot;layout&quot;: {
                &quot;type&quot;: &quot;layout&quot;,
                &quot;doc&quot;: &quot;Layout properties for the layer.&quot;
            },
            &quot;paint&quot;: {
                &quot;type&quot;: &quot;paint&quot;,
                &quot;doc&quot;: &quot;Default paint properties for this layer.&quot;
            },
            &quot;paint.*&quot;: {
                &quot;type&quot;: &quot;paint&quot;,
                &quot;doc&quot;: &quot;Class-specific paint properties for this layer. The class name is the part after the first dot.&quot;
            }
        },
        &quot;layout&quot;: [
            &quot;layout_fill&quot;,
            &quot;layout_line&quot;,
            &quot;layout_symbol&quot;,
            &quot;layout_raster&quot;,
            &quot;layout_background&quot;
        ],
        &quot;layout_background&quot;: {
            &quot;visibility&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;visible&quot;,
                    &quot;none&quot;
                ],
                &quot;default&quot;: &quot;visible&quot;,
                &quot;doc&quot;: &quot;The display of this layer. `none` hides this layer.&quot;
            }
        },
        &quot;layout_fill&quot;: {
            &quot;visibility&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;visible&quot;,
                    &quot;none&quot;
                ],
                &quot;default&quot;: &quot;visible&quot;,
                &quot;doc&quot;: &quot;The display of this layer. `none` hides this layer.&quot;
            }
        },
        &quot;layout_line&quot;: {
            &quot;line-cap&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;butt&quot;,
                    &quot;round&quot;,
                    &quot;square&quot;
                ],
                &quot;default&quot;: &quot;butt&quot;,
                &quot;doc&quot;: &quot;The display of line endings.&quot;
            },
            &quot;line-join&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;bevel&quot;,
                    &quot;round&quot;,
                    &quot;miter&quot;
                ],
                &quot;default&quot;: &quot;miter&quot;,
                &quot;doc&quot;: &quot;The display of lines when joining.&quot;
            },
            &quot;line-miter-limit&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 2,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Used to automatically convert miter joins to bevel joins for sharp angles.&quot;,
                &quot;requires&quot;: [
                    {
                        &quot;line-join&quot;: &quot;miter&quot;
                    }
                ]
            },
            &quot;line-round-limit&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Used to automatically convert round joins to miter joins for shallow angles.&quot;,
                &quot;requires&quot;: [
                    {
                        &quot;line-join&quot;: &quot;round&quot;
                    }
                ]
            },
            &quot;visibility&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;visible&quot;,
                    &quot;none&quot;
                ],
                &quot;default&quot;: &quot;visible&quot;,
                &quot;doc&quot;: &quot;The display of this layer. `none` hides this layer.&quot;
            }
        },
        &quot;layout_symbol&quot;: {
            &quot;symbol-placement&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;point&quot;,
                    &quot;line&quot;
                ],
                &quot;default&quot;: &quot;point&quot;,
                &quot;doc&quot;: &quot;Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons.&quot;
            },
            &quot;symbol-min-distance&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 250,
                &quot;minimum&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Minimum distance between two symbol anchors.&quot;,
                &quot;requires&quot;: [
                    {
                        &quot;symbol-placement&quot;: &quot;line&quot;
                    }
                ]
            },
            &quot;symbol-avoid-edges&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don&#039;t have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer.&quot;
            },
            &quot;icon-allow-overlap&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, the icon will be visible even if it collides with other icons and text.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-ignore-placement&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, the icon won&#039;t affect placement of other icons and text.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-optional&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, text can be shown without its corresponding icon.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;,
                    &quot;text-field&quot;
                ]
            },
            &quot;icon-rotation-alignment&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;map&quot;,
                    &quot;viewport&quot;
                ],
                &quot;default&quot;: &quot;viewport&quot;,
                &quot;doc&quot;: &quot;Orientation of icon when map is rotated.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-max-size&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;The maximum factor to scale the icon.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-image&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;doc&quot;: &quot;A string with {tokens} replaced, referencing the data property to pull from.&quot;,
                &quot;tokens&quot;: true
            },
            &quot;icon-rotate&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;period&quot;: 360,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;units&quot;: &quot;degrees&quot;,
                &quot;doc&quot;: &quot;Rotates the icon clockwise.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-padding&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 2,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Padding value around icon bounding box to avoid icon collisions.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-keep-upright&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, the icon may be flipped to prevent it from being rendered upside-down&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;,
                    {
                        &quot;icon-rotation-alignment&quot;: &quot;map&quot;
                    }
                ]
            },
            &quot;icon-offset&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;length&quot;: 2,
                &quot;default&quot;: [
                    0,
                    0
                ],
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Icon&#039;s offset distance. Values are [x, y] where negatives indicate left and up, respectively.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;text-rotation-alignment&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;map&quot;,
                    &quot;viewport&quot;
                ],
                &quot;default&quot;: &quot;viewport&quot;,
                &quot;doc&quot;: &quot;Orientation of icon or text when map is rotated.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-field&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: &quot;&quot;,
                &quot;tokens&quot;: true,
                &quot;doc&quot;: &quot;Value to use for a text label. Feature properties are specified using tokens like {field_name}.&quot;
            },
            &quot;text-font&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: &quot;Open Sans Regular, Arial Unicode MS Regular&quot;,
                &quot;doc&quot;: &quot;Font stack to use for displaying text.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-max-size&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 16,
                &quot;minimum&quot;: 0,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;The maximum size text will be laid out, to calculate collisions with.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-max-width&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 15,
                &quot;minimum&quot;: 0,
                &quot;units&quot;: &quot;em&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;The maximum line width for text wrapping.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-line-height&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1.2,
                &quot;units&quot;: &quot;em&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Text leading value for multi-line text.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-letter-spacing&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;units&quot;: &quot;em&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Text kerning value.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-justify&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;left&quot;,
                    &quot;center&quot;,
                    &quot;right&quot;
                ],
                &quot;default&quot;: &quot;center&quot;,
                &quot;doc&quot;: &quot;Text justification options.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-anchor&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;center&quot;,
                    &quot;left&quot;,
                    &quot;right&quot;,
                    &quot;top&quot;,
                    &quot;bottom&quot;,
                    &quot;top-left&quot;,
                    &quot;top-right&quot;,
                    &quot;bottom-left&quot;,
                    &quot;bottom-right&quot;
                ],
                &quot;default&quot;: &quot;center&quot;,
                &quot;doc&quot;: &quot;Which part of the text to place closest to the anchor.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-max-angle&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 45,
                &quot;units&quot;: &quot;degrees&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Maximum angle change between adjacent characters.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;,
                    {
                        &quot;symbol-placement&quot;: &quot;line&quot;
                    }
                ]
            },
            &quot;text-rotate&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;period&quot;: 360,
                &quot;units&quot;: &quot;degrees&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Rotates the text clockwise.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-padding&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 2,
                &quot;minimum&quot;: 0,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Padding value around text bounding box to avoid label collisions.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-keep-upright&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: true,
                &quot;doc&quot;: &quot;If true, the text may be flipped vertically to prevent it from being rendered upside-down.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;,
                    {
                        &quot;text-rotation-alignment&quot;: &quot;map&quot;
                    }
                ]
            },
            &quot;text-transform&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;none&quot;,
                    &quot;uppercase&quot;,
                    &quot;lowercase&quot;
                ],
                &quot;default&quot;: &quot;none&quot;,
                &quot;doc&quot;: &quot;Specifies how to capitalize text, similar to the CSS `text-transform` property.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-offset&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;doc&quot;: &quot;Specifies the distance that text is offset from its anchor horizontally and vertically.&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;units&quot;: &quot;ems&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;length&quot;: 2,
                &quot;default&quot;: [
                    0,
                    0
                ],
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-allow-overlap&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, the text will be visible even if it collides with other icons and labels.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-ignore-placement&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, the text won&#039;t affect placement of other icons and labels.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-optional&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: false,
                &quot;doc&quot;: &quot;If true, icons can be shown without their corresponding text.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;,
                    &quot;icon-image&quot;
                ]
            },
            &quot;visibility&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;visible&quot;,
                    &quot;none&quot;
                ],
                &quot;default&quot;: &quot;visible&quot;,
                &quot;doc&quot;: &quot;The display of this layer. `none` hides this layer.&quot;
            }
        },
        &quot;layout_raster&quot;: {
            &quot;visibility&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;visible&quot;,
                    &quot;none&quot;
                ],
                &quot;default&quot;: &quot;visible&quot;,
                &quot;doc&quot;: &quot;The display of this layer. `none` hides this layer.&quot;
            }
        },
        &quot;filter&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;value&quot;: &quot;*&quot;
        },
        &quot;filter_operator&quot;: {
            &quot;type&quot;: &quot;enum&quot;,
            &quot;values&quot;: [
                &quot;==&quot;,
                &quot;!=&quot;,
                &quot;&gt;&quot;,
                &quot;&gt;=&quot;,
                &quot;&lt;&quot;,
                &quot;&lt;=&quot;,
                &quot;in&quot;,
                &quot;!in&quot;,
                &quot;all&quot;,
                &quot;any&quot;,
                &quot;none&quot;
            ]
        },
        &quot;geometry_type&quot;: {
            &quot;type&quot;: &quot;enum&quot;,
            &quot;values&quot;: [
                &quot;Point&quot;,
                &quot;LineString&quot;,
                &quot;Polygon&quot;
            ]
        },
        &quot;function&quot;: {
            &quot;stops&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;required&quot;: true,
                &quot;doc&quot;: &quot;An array of stops.&quot;,
                &quot;value&quot;: &quot;function_stop&quot;
            },
            &quot;base&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;doc&quot;: &quot;The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly.&quot;
            }
        },
        &quot;function_stop&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;minimum&quot;: 0,
            &quot;maximum&quot;: 22,
            &quot;value&quot;: [
                &quot;number&quot;,
                &quot;color&quot;
            ],
            &quot;length&quot;: 2,
            &quot;doc&quot;: &quot;Zoom level and value pair.&quot;
        },
        &quot;paint&quot;: [
            &quot;paint_fill&quot;,
            &quot;paint_line&quot;,
            &quot;paint_symbol&quot;,
            &quot;paint_raster&quot;,
            &quot;paint_background&quot;
        ],
        &quot;paint_fill&quot;: {
            &quot;fill-antialias&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;default&quot;: true,
                &quot;doc&quot;: &quot;Whether or not the fill should be antialiased.&quot;
            },
            &quot;fill-opacity&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;doc&quot;: &quot;The opacity given to the fill color.&quot;,
                &quot;transition&quot;: true
            },
            &quot;fill-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;default&quot;: &quot;#000000&quot;,
                &quot;doc&quot;: &quot;The color of the fill.&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    {
                        &quot;!&quot;: &quot;fill-image&quot;
                    }
                ]
            },
            &quot;fill-outline-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;doc&quot;: &quot;The outline color of the fill. Matches the value of `fill-color` if unspecified.&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    {
                        &quot;!&quot;: &quot;fill-image&quot;
                    },
                    {
                        &quot;fill-antialias&quot;: true
                    }
                ]
            },
            &quot;fill-translate&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;length&quot;: 2,
                &quot;default&quot;: [
                    0,
                    0
                ],
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;The geometry&#039;s offset. Values are [x, y] where negatives indicate left and up, respectively.&quot;
            },
            &quot;fill-translate-anchor&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;map&quot;,
                    &quot;viewport&quot;
                ],
                &quot;doc&quot;: &quot;Control whether the translation is relative to the map (north) or viewport (screen)&quot;,
                &quot;default&quot;: &quot;map&quot;,
                &quot;requires&quot;: [
                    &quot;fill-translate&quot;
                ]
            },
            &quot;fill-image&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;Name of image in sprite to use for drawing image fills.&quot;
            }
        },
        &quot;paint_line&quot;: {
            &quot;line-opacity&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;doc&quot;: &quot;The opacity at which the line will be drawn.&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;transition&quot;: true
            },
            &quot;line-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;doc&quot;: &quot;The color with which the line will be drawn.&quot;,
                &quot;default&quot;: &quot;#000000&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    {
                        &quot;!&quot;: &quot;line-image&quot;
                    }
                ]
            },
            &quot;line-translate&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;length&quot;: 2,
                &quot;default&quot;: [
                    0,
                    0
                ],
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;The geometry&#039;s offset. Values are [x, y] where negatives indicate left and up, respectively.&quot;
            },
            &quot;line-translate-anchor&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;map&quot;,
                    &quot;viewport&quot;
                ],
                &quot;doc&quot;: &quot;Control whether the translation is relative to the map (north) or viewport (screen)&quot;,
                &quot;default&quot;: &quot;map&quot;,
                &quot;requires&quot;: [
                    &quot;line-translate&quot;
                ]
            },
            &quot;line-width&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Stroke thickness.&quot;
            },
            &quot;line-gap-width&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;doc&quot;: &quot;Draws a line casing outside of a line&#039;s actual path. Value indicates the width of the inner gap.&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;
            },
            &quot;line-blur&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Blur applied to the line, in pixels.&quot;
            },
            &quot;line-dasharray&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;doc&quot;: &quot;Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.&quot;,
                &quot;minimum&quot;: 0,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;line widths&quot;,
                &quot;requires&quot;: [
                    {
                        &quot;!&quot;: &quot;line-image&quot;
                    }
                ]
            },
            &quot;line-image&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;Name of image in sprite to use for drawing image lines.&quot;
            }
        },
        &quot;paint_symbol&quot;: {
            &quot;icon-opacity&quot;: {
                &quot;doc&quot;: &quot;The opacity at which the icon will be drawn.&quot;,
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-size&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;Scale factor for icon. 1 is original size, 3 triples the size.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;default&quot;: &quot;#000000&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;The color of the icon. This can only be used with sdf icons.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-halo-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;default&quot;: &quot;rgba(0, 0, 0, 0)&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;The color of the icon&#039;s halo. Icon halos can only be used with sdf icons.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-halo-width&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Distance of halo to the icon outline.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-halo-blur&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Fade out the halo towards the outside.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-translate&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;length&quot;: 2,
                &quot;default&quot;: [
                    0,
                    0
                ],
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;An icon&#039;s offset distance. Values are [x, y] where negatives indicate left and up, respectively.&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;
                ]
            },
            &quot;icon-translate-anchor&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;map&quot;,
                    &quot;viewport&quot;
                ],
                &quot;doc&quot;: &quot;Control whether the translation is relative to the map (north) or viewport (screen)&quot;,
                &quot;default&quot;: &quot;map&quot;,
                &quot;requires&quot;: [
                    &quot;icon-image&quot;,
                    &quot;icon-translate&quot;
                ]
            },
            &quot;text-opacity&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;doc&quot;: &quot;The opacity at which the text will be drawn.&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-size&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 16,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Font size. If unspecified, the text will be as big as allowed by the layer definition.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;doc&quot;: &quot;The color with which the text will be drawn.&quot;,
                &quot;default&quot;: &quot;#000000&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-halo-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;default&quot;: &quot;rgba(0, 0, 0, 0)&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;The color of the text&#039;s halo, which helps it stand out from backgrounds.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-halo-width&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-halo-blur&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;The halo&#039;s fadeout distance towards the outside.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-translate&quot;: {
                &quot;type&quot;: &quot;array&quot;,
                &quot;value&quot;: &quot;number&quot;,
                &quot;length&quot;: 2,
                &quot;default&quot;: [
                    0,
                    0
                ],
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;pixels&quot;,
                &quot;doc&quot;: &quot;Label offset. Values are [x, y] where negatives indicate left and up, respectively.&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;
                ]
            },
            &quot;text-translate-anchor&quot;: {
                &quot;type&quot;: &quot;enum&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;values&quot;: [
                    &quot;map&quot;,
                    &quot;viewport&quot;
                ],
                &quot;doc&quot;: &quot;Control whether the translation is relative to the map (north) or viewport (screen)&quot;,
                &quot;default&quot;: &quot;map&quot;,
                &quot;requires&quot;: [
                    &quot;text-field&quot;,
                    &quot;text-translate&quot;
                ]
            }
        },
        &quot;paint_raster&quot;: {
            &quot;raster-opacity&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;doc&quot;: &quot;The opacity at which the image will be drawn.&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true
            },
            &quot;raster-hue-rotate&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;period&quot;: 360,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;degrees&quot;,
                &quot;doc&quot;: &quot;Rotates hues around the color wheel.&quot;
            },
            &quot;raster-brightness-min&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Increase or reduce the brightness of the image. The value is the minimum brightness.&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;transition&quot;: true
            },
            &quot;raster-brightness-max&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;doc&quot;: &quot;Increase or reduce the brightness of the image. The value is the maximum brightness.&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;transition&quot;: true
            },
            &quot;raster-saturation&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;doc&quot;: &quot;Increase or reduce the saturation of the image.&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: -1,
                &quot;maximum&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true
            },
            &quot;raster-contrast&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;doc&quot;: &quot;Increase or reduce the contrast of the image.&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: -1,
                &quot;maximum&quot;: 1,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true
            },
            &quot;raster-fade-duration&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 300,
                &quot;minimum&quot;: 0,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;units&quot;: &quot;milliseconds&quot;,
                &quot;doc&quot;: &quot;Fade duration when a new tile is added.&quot;
            }
        },
        &quot;paint_background&quot;: {
            &quot;background-color&quot;: {
                &quot;type&quot;: &quot;color&quot;,
                &quot;default&quot;: &quot;#000000&quot;,
                &quot;doc&quot;: &quot;The color with which the background will be drawn.&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true,
                &quot;requires&quot;: [
                    {
                        &quot;!&quot;: &quot;background-image&quot;
                    }
                ]
            },
            &quot;background-image&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;function&quot;: &quot;piecewise-constant&quot;,
                &quot;transition&quot;: true,
                &quot;doc&quot;: &quot;Optionally an image which is drawn as the background.&quot;
            },
            &quot;background-opacity&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 1,
                &quot;minimum&quot;: 0,
                &quot;maximum&quot;: 1,
                &quot;doc&quot;: &quot;The opacity at which the background will be drawn.&quot;,
                &quot;function&quot;: &quot;interpolated&quot;,
                &quot;transition&quot;: true
            }
        },
        &quot;transition&quot;: {
            &quot;duration&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 300,
                &quot;minimum&quot;: 0,
                &quot;units&quot;: &quot;milliseconds&quot;,
                &quot;doc&quot;: &quot;Time allotted for transitions to complete.&quot;
            },
            &quot;delay&quot;: {
                &quot;type&quot;: &quot;number&quot;,
                &quot;default&quot;: 0,
                &quot;minimum&quot;: 0,
                &quot;units&quot;: &quot;milliseconds&quot;,
                &quot;doc&quot;: &quot;Length of time before a transition begins.&quot;
            }
        }
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/buffer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

    module.exports = Buffer;

    var ieee754 = require(&#039;ieee754&#039;);

    var BufferMethods;

    function Buffer(length) {
        var arr;
        if (length &amp;&amp; length.length) {
            arr = length;
            length = arr.length;
        }
        var buf = new Uint8Array(length || 0);
        if (arr) buf.set(arr);

        buf.readUInt32LE = BufferMethods.readUInt32LE;
        buf.writeUInt32LE = BufferMethods.writeUInt32LE;
        buf.readInt32LE = BufferMethods.readInt32LE;
        buf.writeInt32LE = BufferMethods.writeInt32LE;
        buf.readFloatLE = BufferMethods.readFloatLE;
        buf.writeFloatLE = BufferMethods.writeFloatLE;
        buf.readDoubleLE = BufferMethods.readDoubleLE;
        buf.writeDoubleLE = BufferMethods.writeDoubleLE;
        buf.toString = BufferMethods.toString;
        buf.write = BufferMethods.write;
        buf.slice = BufferMethods.slice;
        buf.copy = BufferMethods.copy;

        buf._isBuffer = true;
        return buf;
    }

    var lastStr, lastStrEncoded;

    BufferMethods = {
        readUInt32LE: function(pos) {
            return ((this[pos]) |
                (this[pos + 1] &lt;&lt; 8) |
                (this[pos + 2] &lt;&lt; 16)) +
                (this[pos + 3] * 0x1000000);
        },

        writeUInt32LE: function(val, pos) {
            this[pos] = val;
            this[pos + 1] = (val &gt;&gt;&gt; 8);
            this[pos + 2] = (val &gt;&gt;&gt; 16);
            this[pos + 3] = (val &gt;&gt;&gt; 24);
        },

        readInt32LE: function(pos) {
            return ((this[pos]) |
                (this[pos + 1] &lt;&lt; 8) |
                (this[pos + 2] &lt;&lt; 16)) +
                (this[pos + 3] &lt;&lt; 24);
        },

        readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
        readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

        writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
        writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

        toString: function(encoding, start, end) {
            var str = &#039;&#039;,
                tmp = &#039;&#039;;

            start = start || 0;
            end = Math.min(this.length, end || this.length);

            for (var i = start; i &lt; end; i++) {
                var ch = this[i];
                if (ch &lt;= 0x7F) {
                    str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                    tmp = &#039;&#039;;
                } else {
                    tmp += &#039;%&#039; + ch.toString(16);
                }
            }

            str += decodeURIComponent(tmp);

            return str;
        },

        write: function(str, pos) {
            var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
            for (var i = 0; i &lt; bytes.length; i++) {
                this[pos + i] = bytes[i];
            }
        },

        slice: function(start, end) {
            return this.subarray(start, end);
        },

        copy: function(buf, pos) {
            pos = pos || 0;
            for (var i = 0; i &lt; this.length; i++) {
                buf[pos + i] = this[i];
            }
        }
    };

    BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

    Buffer.byteLength = function(str) {
        lastStr = str;
        lastStrEncoded = encodeString(str);
        return lastStrEncoded.length;
    };

    Buffer.isBuffer = function(buf) {
        return !!(buf &amp;&amp; buf._isBuffer);
    };

    function encodeString(str) {
        var length = str.length,
            bytes = [];

        for (var i = 0, c, lead; i &lt; length; i++) {
            c = str.charCodeAt(i); // code point

            if (c &gt; 0xD7FF &amp;&amp; c &lt; 0xE000) {

                if (lead) {
                    if (c &lt; 0xDC00) {
                        bytes.push(0xEF, 0xBF, 0xBD);
                        lead = c;
                        continue;

                    } else {
                        c = lead - 0xD800 &lt;&lt; 10 | c - 0xDC00 | 0x10000;
                        lead = null;
                    }

                } else {
                    if (c &gt; 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                    else lead = c;

                    continue;
                }

            } else if (lead) {
                bytes.push(0xEF, 0xBF, 0xBD);
                lead = null;
            }

            if (c &lt; 0x80) bytes.push(c);
            else if (c &lt; 0x800) bytes.push(c &gt;&gt; 0x6 | 0xC0, c &amp; 0x3F | 0x80);
            else if (c &lt; 0x10000) bytes.push(c &gt;&gt; 0xC | 0xE0, c &gt;&gt; 0x6 &amp; 0x3F | 0x80, c &amp; 0x3F | 0x80);
            else bytes.push(c &gt;&gt; 0x12 | 0xF0, c &gt;&gt; 0xC &amp; 0x3F | 0x80, c &gt;&gt; 0x6 &amp; 0x3F | 0x80, c &amp; 0x3F | 0x80);
        }
        return bytes;
    }

},{&quot;ieee754&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/node_modules/ieee754/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/index.js&quot;:[function(require,module,exports){
    (function (global){
        &#039;use strict&#039;;

        module.exports = Pbf;

        var Buffer = global.Buffer || require(&#039;./buffer&#039;);

        function Pbf(buf) {
            this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
            this.pos = 0;
            this.length = this.buf.length;
        }

        Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
        Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
        Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
        Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

        var SHIFT_LEFT_32 = (1 &lt;&lt; 16) * (1 &lt;&lt; 16),
            SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
            POW_2_63 = Math.pow(2, 63);

        Pbf.prototype = {

            destroy: function() {
                this.buf = null;
            },

            // === READING =================================================================

            readFields: function(readField, result, end) {
                end = end || this.length;

                while (this.pos &lt; end) {
                    var val = this.readVarint(),
                        tag = val &gt;&gt; 3,
                        startPos = this.pos;

                    readField(tag, result, this);

                    if (this.pos === startPos) this.skip(val);
                }
                return result;
            },

            readMessage: function(readField, result) {
                return this.readFields(readField, result, this.readVarint() + this.pos);
            },

            readFixed32: function() {
                var val = this.buf.readUInt32LE(this.pos);
                this.pos += 4;
                return val;
            },

            readSFixed32: function() {
                var val = this.buf.readInt32LE(this.pos);
                this.pos += 4;
                return val;
            },

            // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

            readFixed64: function() {
                var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
                this.pos += 8;
                return val;
            },

            readSFixed64: function() {
                var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
                this.pos += 8;
                return val;
            },

            readFloat: function() {
                var val = this.buf.readFloatLE(this.pos);
                this.pos += 4;
                return val;
            },

            readDouble: function() {
                var val = this.buf.readDoubleLE(this.pos);
                this.pos += 8;
                return val;
            },

            readVarint: function() {
                var buf = this.buf,
                    val, b, b0, b1, b2, b3;

                b0 = buf[this.pos++]; if (b0 &lt; 0x80) return b0;                 b0 = b0 &amp; 0x7f;
                b1 = buf[this.pos++]; if (b1 &lt; 0x80) return b0 | b1 &lt;&lt; 7;       b1 = (b1 &amp; 0x7f) &lt;&lt; 7;
                b2 = buf[this.pos++]; if (b2 &lt; 0x80) return b0 | b1 | b2 &lt;&lt; 14; b2 = (b2 &amp; 0x7f) &lt;&lt; 14;
                b3 = buf[this.pos++]; if (b3 &lt; 0x80) return b0 | b1 | b2 | b3 &lt;&lt; 21;

                val = b0 | b1 | b2 | (b3 &amp; 0x7f) &lt;&lt; 21;

                b = buf[this.pos++]; val += (b &amp; 0x7f) * 0x10000000;         if (b &lt; 0x80) return val;
                b = buf[this.pos++]; val += (b &amp; 0x7f) * 0x800000000;        if (b &lt; 0x80) return val;
                b = buf[this.pos++]; val += (b &amp; 0x7f) * 0x40000000000;      if (b &lt; 0x80) return val;
                b = buf[this.pos++]; val += (b &amp; 0x7f) * 0x2000000000000;    if (b &lt; 0x80) return val;
                b = buf[this.pos++]; val += (b &amp; 0x7f) * 0x100000000000000;  if (b &lt; 0x80) return val;
                b = buf[this.pos++]; val += (b &amp; 0x7f) * 0x8000000000000000; if (b &lt; 0x80) return val;

                throw new Error(&#039;Expected varint not more than 10 bytes&#039;);
            },

            readVarint64: function() {
                var startPos = this.pos,
                    val = this.readVarint();

                if (val &lt; POW_2_63) return val;

                var pos = this.pos - 2;
                while (this.buf[pos] === 0xff) pos--;
                if (pos &lt; startPos) pos = startPos;

                val = 0;
                for (var i = 0; i &lt; pos - startPos + 1; i++) {
                    var b = ~this.buf[startPos + i] &amp; 0x7f;
                    val += i &lt; 4 ? b &lt;&lt; i * 7 : b * Math.pow(2, i * 7);
                }

                return -val - 1;
            },

            readSVarint: function() {
                var num = this.readVarint();
                return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
            },

            readBoolean: function() {
                return Boolean(this.readVarint());
            },

            readString: function() {
                var end = this.readVarint() + this.pos,
                    str = this.buf.toString(&#039;utf8&#039;, this.pos, end);
                this.pos = end;
                return str;
            },

            readBytes: function() {
                var end = this.readVarint() + this.pos,
                    buffer = this.buf.slice(this.pos, end);
                this.pos = end;
                return buffer;
            },

            // verbose for performance reasons; doesn&#039;t affect gzipped size

            readPackedVarint: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readVarint());
                return arr;
            },
            readPackedSVarint: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readSVarint());
                return arr;
            },
            readPackedBoolean: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readBoolean());
                return arr;
            },
            readPackedFloat: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readFloat());
                return arr;
            },
            readPackedDouble: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readDouble());
                return arr;
            },
            readPackedFixed32: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readFixed32());
                return arr;
            },
            readPackedSFixed32: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readSFixed32());
                return arr;
            },
            readPackedFixed64: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readFixed64());
                return arr;
            },
            readPackedSFixed64: function() {
                var end = this.readVarint() + this.pos, arr = [];
                while (this.pos &lt; end) arr.push(this.readSFixed64());
                return arr;
            },

            skip: function(val) {
                var type = val &amp; 0x7;
                if (type === Pbf.Varint) while (this.buf[this.pos++] &gt; 0x7f) {}
                else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
                else if (type === Pbf.Fixed32) this.pos += 4;
                else if (type === Pbf.Fixed64) this.pos += 8;
                else throw new Error(&#039;Unimplemented type: &#039; + type);
            },

            // === WRITING =================================================================

            writeTag: function(tag, type) {
                this.writeVarint((tag &lt;&lt; 3) | type);
            },

            realloc: function(min) {
                var length = this.length || 16;

                while (length &lt; this.pos + min) length *= 2;

                if (length !== this.length) {
                    var buf = new Buffer(length);
                    this.buf.copy(buf);
                    this.buf = buf;
                    this.length = length;
                }
            },

            finish: function() {
                this.length = this.pos;
                this.pos = 0;
                return this.buf.slice(0, this.length);
            },

            writeFixed32: function(val) {
                this.realloc(4);
                this.buf.writeUInt32LE(val, this.pos);
                this.pos += 4;
            },

            writeSFixed32: function(val) {
                this.realloc(4);
                this.buf.writeInt32LE(val, this.pos);
                this.pos += 4;
            },

            writeFixed64: function(val) {
                this.realloc(8);
                this.buf.writeInt32LE(val &amp; -1, this.pos);
                this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
                this.pos += 8;
            },

            writeSFixed64: function(val) {
                this.realloc(8);
                this.buf.writeInt32LE(val &amp; -1, this.pos);
                this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
                this.pos += 8;
            },

            writeVarint: function(val) {
                val = +val;

                if (val &lt;= 0x7f) {
                    this.realloc(1);
                    this.buf[this.pos++] = val;

                } else if (val &lt;= 0x3fff) {
                    this.realloc(2);
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 0) &amp; 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 7) &amp; 0x7f);

                } else if (val &lt;= 0x1fffff) {
                    this.realloc(3);
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 0) &amp; 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 7) &amp; 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 14) &amp; 0x7f);

                } else if (val &lt;= 0xfffffff) {
                    this.realloc(4);
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 0) &amp; 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 7) &amp; 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 14) &amp; 0x7f) | 0x80;
                    this.buf[this.pos++] = ((val &gt;&gt;&gt; 21) &amp; 0x7f);

                } else {
                    var pos = this.pos;
                    while (val &gt;= 0x80) {
                        this.realloc(1);
                        this.buf[this.pos++] = (val &amp; 0xff) | 0x80;
                        val /= 0x80;
                    }
                    this.realloc(1);
                    this.buf[this.pos++] = val | 0;
                    if (this.pos - pos &gt; 10) throw new Error(&#039;Given varint doesn\&#039;t fit into 10 bytes&#039;);
                }
            },

            writeSVarint: function(val) {
                this.writeVarint(val &lt; 0 ? -val * 2 - 1 : val * 2);
            },

            writeBoolean: function(val) {
                this.writeVarint(Boolean(val));
            },

            writeString: function(str) {
                str = String(str);
                var bytes = Buffer.byteLength(str);
                this.writeVarint(bytes);
                this.realloc(bytes);
                this.buf.write(str, this.pos);
                this.pos += bytes;
            },

            writeFloat: function(val) {
                this.realloc(4);
                this.buf.writeFloatLE(val, this.pos);
                this.pos += 4;
            },

            writeDouble: function(val) {
                this.realloc(8);
                this.buf.writeDoubleLE(val, this.pos);
                this.pos += 8;
            },

            writeBytes: function(buffer) {
                var len = buffer.length;
                this.writeVarint(len);
                this.realloc(len);
                for (var i = 0; i &lt; len; i++) this.buf[this.pos++] = buffer[i];
            },

            writeMessage: function(tag, fn, obj) {
                this.writeTag(tag, Pbf.Bytes);

                this.pos++; // reserve 1 byte for short message length

                // write the message directly to the buffer and see how much was written
                var startPos = this.pos;
                fn(obj, this);
                var len = this.pos - startPos;

                var varintLen =
                        len &lt;= 0x7f ? 1 :
                        len &lt;= 0x3fff ? 2 :
                        len &lt;= 0x1fffff ? 3 :
                        len &lt;= 0xfffffff ? 4 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

                // if 1 byte isn&#039;t enough for encoding message length, shift the data to the right
                if (varintLen &gt; 1) {
                    this.realloc(varintLen - 1);
                    for (var i = this.pos - 1; i &gt;= startPos; i--) this.buf[i + varintLen - 1] = this.buf[i];
                }

                // finally, write the message length in the reserved place and restore the position
                this.pos = startPos - 1;
                this.writeVarint(len);
                this.pos += len;
            },

            writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
            writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
            writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
            writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
            writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
            writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
            writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
            writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
            writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

            writeBytesField: function(tag, buffer) {
                this.writeTag(tag, Pbf.Bytes);
                this.writeBytes(buffer);
            },
            writeFixed32Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed32);
                this.writeFixed32(val);
            },
            writeSFixed32Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed32);
                this.writeSFixed32(val);
            },
            writeFixed64Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed64);
                this.writeFixed64(val);
            },
            writeSFixed64Field: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed64);
                this.writeSFixed64(val);
            },
            writeVarintField: function(tag, val) {
                this.writeTag(tag, Pbf.Varint);
                this.writeVarint(val);
            },
            writeSVarintField: function(tag, val) {
                this.writeTag(tag, Pbf.Varint);
                this.writeSVarint(val);
            },
            writeStringField: function(tag, str) {
                this.writeTag(tag, Pbf.Bytes);
                this.writeString(str);
            },
            writeFloatField: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed32);
                this.writeFloat(val);
            },
            writeDoubleField: function(tag, val) {
                this.writeTag(tag, Pbf.Fixed64);
                this.writeDouble(val);
            },
            writeBooleanField: function(tag, val) {
                this.writeVarintField(tag, Boolean(val));
            }
        };

        function writePackedVarint(arr, pbf)   { for (var i = 0; i &lt; arr.length; i++) pbf.writeVarint(arr[i]);   }
        function writePackedSVarint(arr, pbf)  { for (var i = 0; i &lt; arr.length; i++) pbf.writeSVarint(arr[i]);  }
        function writePackedFloat(arr, pbf)    { for (var i = 0; i &lt; arr.length; i++) pbf.writeFloat(arr[i]);    }
        function writePackedDouble(arr, pbf)   { for (var i = 0; i &lt; arr.length; i++) pbf.writeDouble(arr[i]);   }
        function writePackedBoolean(arr, pbf)  { for (var i = 0; i &lt; arr.length; i++) pbf.writeBoolean(arr[i]);  }
        function writePackedFixed32(arr, pbf)  { for (var i = 0; i &lt; arr.length; i++) pbf.writeFixed32(arr[i]);  }
        function writePackedSFixed32(arr, pbf) { for (var i = 0; i &lt; arr.length; i++) pbf.writeSFixed32(arr[i]); }
        function writePackedFixed64(arr, pbf)  { for (var i = 0; i &lt; arr.length; i++) pbf.writeFixed64(arr[i]);  }
        function writePackedSFixed64(arr, pbf) { for (var i = 0; i &lt; arr.length; i++) pbf.writeSFixed64(arr[i]); }

    }).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})

},{&quot;./buffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/buffer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/pbf/node_modules/ieee754/index.js&quot;:[function(require,module,exports){
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 &lt;&lt; eLen) - 1,
            eBias = eMax &gt;&gt; 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s &amp; ((1 &lt;&lt; (-nBits)) - 1);
        s &gt;&gt;= (-nBits);
        nBits += eLen;
        for (; nBits &gt; 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

        m = e &amp; ((1 &lt;&lt; (-nBits)) - 1);
        e &gt;&gt;= (-nBits);
        nBits += mLen;
        for (; nBits &gt; 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };

    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 &lt;&lt; eLen) - 1,
            eBias = eMax &gt;&gt; 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) &lt; 1) {
                e--;
                c *= 2;
            }
            if (e + eBias &gt;= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c &gt;= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias &gt;= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias &gt;= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8);

        e = (e &lt;&lt; mLen) | m;
        eLen += mLen;
        for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8);

        buffer[offset + i - d] |= s * 128;
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    module.exports = Point;

    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    Point.prototype = {
        clone: function() { return new Point(this.x, this.y); },

        add:     function(p) { return this.clone()._add(p);     },
        sub:     function(p) { return this.clone()._sub(p);     },
        mult:    function(k) { return this.clone()._mult(k);    },
        div:     function(k) { return this.clone()._div(k);     },
        rotate:  function(a) { return this.clone()._rotate(a);  },
        matMult: function(m) { return this.clone()._matMult(m); },
        unit:    function() { return this.clone()._unit(); },
        perp:    function() { return this.clone()._perp(); },
        round:   function() { return this.clone()._round(); },

        mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },

        equals: function(p) {
            return this.x === p.x &amp;&amp;
                this.y === p.y;
        },

        dist: function(p) {
            return Math.sqrt(this.distSqr(p));
        },

        distSqr: function(p) {
            var dx = p.x - this.x,
                dy = p.y - this.y;
            return dx * dx + dy * dy;
        },

        angle: function() {
            return Math.atan2(this.y, this.x);
        },

        angleTo: function(b) {
            return Math.atan2(this.y - b.y, this.x - b.x);
        },

        angleWith: function(b) {
            return this.angleWithSep(b.x, b.y);
        },

        // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
        angleWithSep: function(x, y) {
            return Math.atan2(
                    this.x * y - this.y * x,
                    this.x * x + this.y * y);
        },

        _matMult: function(m) {
            var x = m[0] * this.x + m[1] * this.y,
                y = m[2] * this.x + m[3] * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _add: function(p) {
            this.x += p.x;
            this.y += p.y;
            return this;
        },

        _sub: function(p) {
            this.x -= p.x;
            this.y -= p.y;
            return this;
        },

        _mult: function(k) {
            this.x *= k;
            this.y *= k;
            return this;
        },

        _div: function(k) {
            this.x /= k;
            this.y /= k;
            return this;
        },

        _unit: function() {
            this._div(this.mag());
            return this;
        },

        _perp: function() {
            var y = this.y;
            this.y = this.x;
            this.x = -y;
            return this;
        },

        _rotate: function(angle) {
            var cos = Math.cos(angle),
                sin = Math.sin(angle),
                x = cos * this.x - sin * this.y,
                y = sin * this.x + cos * this.y;
            this.x = x;
            this.y = y;
            return this;
        },

        _round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        }
    };

// constructs Point from an array if necessary
    Point.convert = function (a) {
        if (a instanceof Point) {
            return a;
        }
        if (Array.isArray(a)) {
            return new Point(a[0], a[1]);
        }
        return a;
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/rbush/rbush.js&quot;:[function(require,module,exports){
    /*
     (c) 2013, Vladimir Agafonkin
     RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
     https://github.com/mourner/rbush
     */

    (function () { &#039;use strict&#039;;

        function rbush(maxEntries, format) {

            // jshint newcap: false, validthis: true
            if (!(this instanceof rbush)) return new rbush(maxEntries, format);

            // max entries in a node is 9 by default; min node fill is 40% for best performance
            this._maxEntries = Math.max(4, maxEntries || 9);
            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

            if (format) {
                this._initFormat(format);
            }

            this.clear();
        }

        rbush.prototype = {

            all: function () {
                return this._all(this.data, []);
            },

            search: function (bbox) {

                var node = this.data,
                    result = [],
                    toBBox = this.toBBox;

                if (!intersects(bbox, node.bbox)) return result;

                var nodesToSearch = [],
                    i, len, child, childBBox;

                while (node) {
                    for (i = 0, len = node.children.length; i &lt; len; i++) {

                        child = node.children[i];
                        childBBox = node.leaf ? toBBox(child) : child.bbox;

                        if (intersects(bbox, childBBox)) {
                            if (node.leaf) result.push(child);
                            else if (contains(bbox, childBBox)) this._all(child, result);
                            else nodesToSearch.push(child);
                        }
                    }
                    node = nodesToSearch.pop();
                }

                return result;
            },

            load: function (data) {
                if (!(data &amp;&amp; data.length)) return this;

                if (data.length &lt; this._minEntries) {
                    for (var i = 0, len = data.length; i &lt; len; i++) {
                        this.insert(data[i]);
                    }
                    return this;
                }

                // recursively build the tree with the given data from stratch using OMT algorithm
                var node = this._build(data.slice(), 0, data.length - 1, 0);

                if (!this.data.children.length) {
                    // save as is if tree is empty
                    this.data = node;

                } else if (this.data.height === node.height) {
                    // split root if trees have the same height
                    this._splitRoot(this.data, node);

                } else {
                    if (this.data.height &lt; node.height) {
                        // swap trees if inserted one is bigger
                        var tmpNode = this.data;
                        this.data = node;
                        node = tmpNode;
                    }

                    // insert the small tree into the large tree at appropriate level
                    this._insert(node, this.data.height - node.height - 1, true);
                }

                return this;
            },

            insert: function (item) {
                if (item) this._insert(item, this.data.height - 1);
                return this;
            },

            clear: function () {
                this.data = {
                    children: [],
                    height: 1,
                    bbox: empty(),
                    leaf: true
                };
                return this;
            },

            remove: function (item) {
                if (!item) return this;

                var node = this.data,
                    bbox = this.toBBox(item),
                    path = [],
                    indexes = [],
                    i, parent, index, goingUp;

                // depth-first iterative tree traversal
                while (node || path.length) {

                    if (!node) { // go up
                        node = path.pop();
                        parent = path[path.length - 1];
                        i = indexes.pop();
                        goingUp = true;
                    }

                    if (node.leaf) { // check current node
                        index = node.children.indexOf(item);

                        if (index !== -1) {
                            // item found, remove the item and condense tree upwards
                            node.children.splice(index, 1);
                            path.push(node);
                            this._condense(path);
                            return this;
                        }
                    }

                    if (!goingUp &amp;&amp; !node.leaf &amp;&amp; contains(node.bbox, bbox)) { // go down
                        path.push(node);
                        indexes.push(i);
                        i = 0;
                        parent = node;
                        node = node.children[0];

                    } else if (parent) { // go right
                        i++;
                        node = parent.children[i];
                        goingUp = false;

                    } else node = null; // nothing found
                }

                return this;
            },

            toBBox: function (item) { return item; },

            compareMinX: function (a, b) { return a[0] - b[0]; },
            compareMinY: function (a, b) { return a[1] - b[1]; },

            toJSON: function () { return this.data; },

            fromJSON: function (data) {
                this.data = data;
                return this;
            },

            _all: function (node, result) {
                var nodesToSearch = [];
                while (node) {
                    if (node.leaf) result.push.apply(result, node.children);
                    else nodesToSearch.push.apply(nodesToSearch, node.children);

                    node = nodesToSearch.pop();
                }
                return result;
            },

            _build: function (items, left, right, height) {

                var N = right - left + 1,
                    M = this._maxEntries,
                    node;

                if (N &lt;= M) {
                    // reached leaf level; return leaf
                    node = {
                        children: items.slice(left, right + 1),
                        height: 1,
                        bbox: null,
                        leaf: true
                    };
                    calcBBox(node, this.toBBox);
                    return node;
                }

                if (!height) {
                    // target height of the bulk-loaded tree
                    height = Math.ceil(Math.log(N) / Math.log(M));

                    // target number of root entries to maximize storage utilization
                    M = Math.ceil(N / Math.pow(M, height - 1));
                }

                // TODO eliminate recursion?

                node = {
                    children: [],
                    height: height,
                    bbox: null
                };

                // split the items into M mostly square tiles

                var N2 = Math.ceil(N / M),
                    N1 = N2 * Math.ceil(Math.sqrt(M)),
                    i, j, right2, right3;

                multiSelect(items, left, right, N1, this.compareMinX);

                for (i = left; i &lt;= right; i += N1) {

                    right2 = Math.min(i + N1 - 1, right);

                    multiSelect(items, i, right2, N2, this.compareMinY);

                    for (j = i; j &lt;= right2; j += N2) {

                        right3 = Math.min(j + N2 - 1, right2);

                        // pack each entry recursively
                        node.children.push(this._build(items, j, right3, height - 1));
                    }
                }

                calcBBox(node, this.toBBox);

                return node;
            },

            _chooseSubtree: function (bbox, node, level, path) {

                var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

                while (true) {
                    path.push(node);

                    if (node.leaf || path.length - 1 === level) break;

                    minArea = minEnlargement = Infinity;

                    for (i = 0, len = node.children.length; i &lt; len; i++) {
                        child = node.children[i];
                        area = bboxArea(child.bbox);
                        enlargement = enlargedArea(bbox, child.bbox) - area;

                        // choose entry with the least area enlargement
                        if (enlargement &lt; minEnlargement) {
                            minEnlargement = enlargement;
                            minArea = area &lt; minArea ? area : minArea;
                            targetNode = child;

                        } else if (enlargement === minEnlargement) {
                            // otherwise choose one with the smallest area
                            if (area &lt; minArea) {
                                minArea = area;
                                targetNode = child;
                            }
                        }
                    }

                    node = targetNode;
                }

                return node;
            },

            _insert: function (item, level, isNode) {

                var toBBox = this.toBBox,
                    bbox = isNode ? item.bbox : toBBox(item),
                    insertPath = [];

                // find the best node for accommodating the item, saving all nodes along the path too
                var node = this._chooseSubtree(bbox, this.data, level, insertPath);

                // put the item into the node
                node.children.push(item);
                extend(node.bbox, bbox);

                // split on node overflow; propagate upwards if necessary
                while (level &gt;= 0) {
                    if (insertPath[level].children.length &gt; this._maxEntries) {
                        this._split(insertPath, level);
                        level--;
                    } else break;
                }

                // adjust bboxes along the insertion path
                this._adjustParentBBoxes(bbox, insertPath, level);
            },

            // split overflowed node into two
            _split: function (insertPath, level) {

                var node = insertPath[level],
                    M = node.children.length,
                    m = this._minEntries;

                this._chooseSplitAxis(node, m, M);

                var newNode = {
                    children: node.children.splice(this._chooseSplitIndex(node, m, M)),
                    height: node.height
                };

                if (node.leaf) newNode.leaf = true;

                calcBBox(node, this.toBBox);
                calcBBox(newNode, this.toBBox);

                if (level) insertPath[level - 1].children.push(newNode);
                else this._splitRoot(node, newNode);
            },

            _splitRoot: function (node, newNode) {
                // split root node
                this.data = {
                    children: [node, newNode],
                    height: node.height + 1
                };
                calcBBox(this.data, this.toBBox);
            },

            _chooseSplitIndex: function (node, m, M) {

                var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

                minOverlap = minArea = Infinity;

                for (i = m; i &lt;= M - m; i++) {
                    bbox1 = distBBox(node, 0, i, this.toBBox);
                    bbox2 = distBBox(node, i, M, this.toBBox);

                    overlap = intersectionArea(bbox1, bbox2);
                    area = bboxArea(bbox1) + bboxArea(bbox2);

                    // choose distribution with minimum overlap
                    if (overlap &lt; minOverlap) {
                        minOverlap = overlap;
                        index = i;

                        minArea = area &lt; minArea ? area : minArea;

                    } else if (overlap === minOverlap) {
                        // otherwise choose distribution with minimum area
                        if (area &lt; minArea) {
                            minArea = area;
                            index = i;
                        }
                    }
                }

                return index;
            },

            // sorts node children by the best axis for split
            _chooseSplitAxis: function (node, m, M) {

                var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                    compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                    xMargin = this._allDistMargin(node, m, M, compareMinX),
                    yMargin = this._allDistMargin(node, m, M, compareMinY);

                // if total distributions margin value is minimal for x, sort by minX,
                // otherwise it&#039;s already sorted by minY
                if (xMargin &lt; yMargin) node.children.sort(compareMinX);
            },

            // total margin of all possible split distributions where each node is at least m full
            _allDistMargin: function (node, m, M, compare) {

                node.children.sort(compare);

                var toBBox = this.toBBox,
                    leftBBox = distBBox(node, 0, m, toBBox),
                    rightBBox = distBBox(node, M - m, M, toBBox),
                    margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                    i, child;

                for (i = m; i &lt; M - m; i++) {
                    child = node.children[i];
                    extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);
                    margin += bboxMargin(leftBBox);
                }

                for (i = M - m - 1; i &gt;= m; i--) {
                    child = node.children[i];
                    extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);
                    margin += bboxMargin(rightBBox);
                }

                return margin;
            },

            _adjustParentBBoxes: function (bbox, path, level) {
                // adjust bboxes along the given tree path
                for (var i = level; i &gt;= 0; i--) {
                    extend(path[i].bbox, bbox);
                }
            },

            _condense: function (path) {
                // go through the path, removing empty nodes and updating bboxes
                for (var i = path.length - 1, siblings; i &gt;= 0; i--) {
                    if (path[i].children.length === 0) {
                        if (i &gt; 0) {
                            siblings = path[i - 1].children;
                            siblings.splice(siblings.indexOf(path[i]), 1);

                        } else this.clear();

                    } else calcBBox(path[i], this.toBBox);
                }
            },

            _initFormat: function (format) {
                // data format (minX, minY, maxX, maxY accessors)

                // uses eval-type function compilation instead of just accepting a toBBox function
                // because the algorithms are very sensitive to sorting functions performance,
                // so they should be dead simple and without inner calls

                // jshint evil: true

                var compareArr = [&#039;return a&#039;, &#039; - b&#039;, &#039;;&#039;];

                this.compareMinX = new Function(&#039;a&#039;, &#039;b&#039;, compareArr.join(format[0]));
                this.compareMinY = new Function(&#039;a&#039;, &#039;b&#039;, compareArr.join(format[1]));

                this.toBBox = new Function(&#039;a&#039;, &#039;return [a&#039; + format.join(&#039;, a&#039;) + &#039;];&#039;);
            }
        };


// calculate node&#039;s bbox from bboxes of its children
        function calcBBox(node, toBBox) {
            node.bbox = distBBox(node, 0, node.children.length, toBBox);
        }

// min bounding rectangle of node children from k to p-1
        function distBBox(node, k, p, toBBox) {
            var bbox = empty();

            for (var i = k, child; i &lt; p; i++) {
                child = node.children[i];
                extend(bbox, node.leaf ? toBBox(child) : child.bbox);
            }

            return bbox;
        }

        function empty() { return [Infinity, Infinity, -Infinity, -Infinity]; }

        function extend(a, b) {
            a[0] = Math.min(a[0], b[0]);
            a[1] = Math.min(a[1], b[1]);
            a[2] = Math.max(a[2], b[2]);
            a[3] = Math.max(a[3], b[3]);
            return a;
        }

        function compareNodeMinX(a, b) { return a.bbox[0] - b.bbox[0]; }
        function compareNodeMinY(a, b) { return a.bbox[1] - b.bbox[1]; }

        function bboxArea(a)   { return (a[2] - a[0]) * (a[3] - a[1]); }
        function bboxMargin(a) { return (a[2] - a[0]) + (a[3] - a[1]); }

        function enlargedArea(a, b) {
            return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
                (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
        }

        function intersectionArea(a, b) {
            var minX = Math.max(a[0], b[0]),
                minY = Math.max(a[1], b[1]),
                maxX = Math.min(a[2], b[2]),
                maxY = Math.min(a[3], b[3]);

            return Math.max(0, maxX - minX) *
                Math.max(0, maxY - minY);
        }

        function contains(a, b) {
            return a[0] &lt;= b[0] &amp;&amp;
                a[1] &lt;= b[1] &amp;&amp;
                b[2] &lt;= a[2] &amp;&amp;
                b[3] &lt;= a[3];
        }

        function intersects(a, b) {
            return b[0] &lt;= a[2] &amp;&amp;
                b[1] &lt;= a[3] &amp;&amp;
                b[2] &gt;= a[0] &amp;&amp;
                b[3] &gt;= a[1];
        }

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide &amp; conquer approach

        function multiSelect(arr, left, right, n, compare) {
            var stack = [left, right],
                mid;

            while (stack.length) {
                right = stack.pop();
                left = stack.pop();

                if (right - left &lt;= n) continue;

                mid = left + Math.ceil((right - left) / n / 2) * n;
                select(arr, left, right, mid, compare);

                stack.push(left, mid, mid, right);
            }
        }

// sort array between left and right (inclusive) so that the smallest k elements come first (unordered)
        function select(arr, left, right, k, compare) {
            var n, i, z, s, sd, newLeft, newRight, t, j;

            while (right &gt; left) {
                if (right - left &gt; 600) {
                    n = right - left + 1;
                    i = k - left + 1;
                    z = Math.log(n);
                    s = 0.5 * Math.exp(2 * z / 3);
                    sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 &lt; 0 ? -1 : 1);
                    newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
                    newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
                    select(arr, newLeft, newRight, k, compare);
                }

                t = arr[k];
                i = left;
                j = right;

                swap(arr, left, k);
                if (compare(arr[right], t) &gt; 0) swap(arr, left, right);

                while (i &lt; j) {
                    swap(arr, i, j);
                    i++;
                    j--;
                    while (compare(arr[i], t) &lt; 0) i++;
                    while (compare(arr[j], t) &gt; 0) j--;
                }

                if (compare(arr[left], t) === 0) swap(arr, left, j);
                else {
                    j++;
                    swap(arr, j, right);
                }

                if (j &lt;= k) left = j + 1;
                if (k &lt;= j) right = j - 1;
            }
        }

        function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }


// export as AMD/CommonJS module or global variable
        if (typeof define === &#039;function&#039; &amp;&amp; define.amd) define(&#039;rbush&#039;, function() { return rbush; });
        else if (typeof module !== &#039;undefined&#039;) module.exports = rbush;
        else if (typeof self !== &#039;undefined&#039;) self.rbush = rbush;
        else window.rbush = rbush;

    })();

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/unitbezier/index.js&quot;:[function(require,module,exports){
    /*
     * Copyright (C) 2008 Apple Inc. All Rights Reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions
     * are met:
     * 1. Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     *
     * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#039;&#039; AND ANY
     * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
     * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
     * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
     * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * Ported from Webkit
     * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
     */

    module.exports = UnitBezier;

    function UnitBezier(p1x, p1y, p2x, p2y) {
        // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
        this.cx = 3.0 * p1x;
        this.bx = 3.0 * (p2x - p1x) - this.cx;
        this.ax = 1.0 - this.cx - this.bx;

        this.cy = 3.0 * p1y;
        this.by = 3.0 * (p2y - p1y) - this.cy;
        this.ay = 1.0 - this.cy - this.by;

        this.p1x = p1x;
        this.p1y = p2y;
        this.p2x = p2x;
        this.p2y = p2y;
    }

    UnitBezier.prototype.sampleCurveX = function(t) {
        // `ax t^3 + bx t^2 + cx t&#039; expanded using Horner&#039;s rule.
        return ((this.ax * t + this.bx) * t + this.cx) * t;
    };

    UnitBezier.prototype.sampleCurveY = function(t) {
        return ((this.ay * t + this.by) * t + this.cy) * t;
    };

    UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
    };

    UnitBezier.prototype.solveCurveX = function(x, epsilon) {
        if (typeof epsilon === &#039;undefined&#039;) epsilon = 1e-6;

        var t0, t1, t2, x2, i;

        // First try a few iterations of Newton&#039;s method -- normally very fast.
        for (t2 = x, i = 0; i &lt; 8; i++) {

            x2 = this.sampleCurveX(t2) - x;
            if (Math.abs(x2) &lt; epsilon) return t2;

            var d2 = this.sampleCurveDerivativeX(t2);
            if (Math.abs(d2) &lt; 1e-6) break;

            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 &lt; t0) return t0;
        if (t2 &gt; t1) return t1;

        while (t0 &lt; t1) {

            x2 = this.sampleCurveX(t2);
            if (Math.abs(x2 - x) &lt; epsilon) return t2;

            if (x &gt; x2) {
                t0 = t2;
            } else {
                t1 = t2;
            }

            t2 = (t1 - t0) * 0.5 + t0;
        }

        // Failure.
        return t2;
    };

    UnitBezier.prototype.solve = function(x, epsilon) {
        return this.sampleCurveY(this.solveCurveX(x, epsilon));
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/index.js&quot;:[function(require,module,exports){
    module.exports.VectorTile = require(&#039;./lib/vectortile.js&#039;);
    module.exports.VectorTileFeature = require(&#039;./lib/vectortilefeature.js&#039;);
    module.exports.VectorTileLayer = require(&#039;./lib/vectortilelayer.js&#039;);

},{&quot;./lib/vectortile.js&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortile.js&quot;,&quot;./lib/vectortilefeature.js&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortilefeature.js&quot;,&quot;./lib/vectortilelayer.js&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortilelayer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortile.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var VectorTileLayer = require(&#039;./vectortilelayer&#039;);

    module.exports = VectorTile;

    function VectorTile(pbf, end) {
        this.layers = pbf.readFields(readTile, {}, end);
    }

    function readTile(tag, layers, pbf) {
        if (tag === 3) {
            var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
            if (layer.length) layers[layer.name] = layer;
        }
    }


},{&quot;./vectortilelayer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortilelayer.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortilefeature.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var Point = require(&#039;point-geometry&#039;);

    module.exports = VectorTileFeature;

    function VectorTileFeature(pbf, end, extent, keys, values) {
        // Public
        this.properties = {};
        this.extent = extent;
        this.type = 0;

        // Private
        this._pbf = pbf;
        this._geometry = -1;
        this._keys = keys;
        this._values = values;

        pbf.readFields(readFeature, this, end);
    }

    function readFeature(tag, feature, pbf) {
        if (tag == 1) feature._id = pbf.readVarint();
        else if (tag == 2) readTag(pbf, feature);
        else if (tag == 3) feature.type = pbf.readVarint();
        else if (tag == 4) feature._geometry = pbf.pos;
    }

    function readTag(pbf, feature) {
        var end = pbf.readVarint() + pbf.pos;

        while (pbf.pos &lt; end) {
            var key = feature._keys[pbf.readVarint()],
                value = feature._values[pbf.readVarint()];
            feature.properties[key] = value;
        }
    }

    VectorTileFeature.types = [&#039;Unknown&#039;, &#039;Point&#039;, &#039;LineString&#039;, &#039;Polygon&#039;];

    VectorTileFeature.prototype.loadGeometry = function() {
        var pbf = this._pbf;
        pbf.pos = this._geometry;

        var end = pbf.readVarint() + pbf.pos,
            cmd = 1,
            length = 0,
            x = 0,
            y = 0,
            lines = [],
            line;

        while (pbf.pos &lt; end) {
            if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen &amp; 0x7;
                length = cmdLen &gt;&gt; 3;
            }

            length--;

            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();

                if (cmd === 1) { // moveTo
                    if (line) lines.push(line);
                    line = [];
                }

                line.push(new Point(x, y));

            } else if (cmd === 7) {
                line.push(line[0].clone()); // closePolygon

            } else {
                throw new Error(&#039;unknown command &#039; + cmd);
            }
        }

        if (line) lines.push(line);

        return lines;
    };

    VectorTileFeature.prototype.bbox = function() {
        var pbf = this._pbf;
        pbf.pos = this._geometry;

        var end = pbf.readVarint() + pbf.pos,
            cmd = 1,
            length = 0,
            x = 0,
            y = 0,
            x1 = Infinity,
            x2 = -Infinity,
            y1 = Infinity,
            y2 = -Infinity;

        while (pbf.pos &lt; end) {
            if (!length) {
                var cmdLen = pbf.readVarint();
                cmd = cmdLen &amp; 0x7;
                length = cmdLen &gt;&gt; 3;
            }

            length--;

            if (cmd === 1 || cmd === 2) {
                x += pbf.readSVarint();
                y += pbf.readSVarint();
                if (x &lt; x1) x1 = x;
                if (x &gt; x2) x2 = x;
                if (y &lt; y1) y1 = y;
                if (y &gt; y2) y2 = y;

            } else if (cmd !== 7) {
                throw new Error(&#039;unknown command &#039; + cmd);
            }
        }

        return [x1, y1, x2, y2];
    };

    VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
        var size = this.extent * Math.pow(2, z),
            x0 = this.extent * x,
            y0 = this.extent * y,
            coords = this.loadGeometry(),
            type = VectorTileFeature.types[this.type];

        for (var i = 0; i &lt; coords.length; i++) {
            var line = coords[i];
            for (var j = 0; j &lt; line.length; j++) {
                var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
                line[j] = [
                        (p.x + x0) * 360 / size - 180,
                        360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
                ];
            }
        }

        if (type === &#039;Point&#039; &amp;&amp; coords.length === 1) {
            coords = coords[0][0];
        } else if (type === &#039;Point&#039;) {
            coords = coords[0];
            type = &#039;MultiPoint&#039;;
        } else if (type === &#039;LineString&#039; &amp;&amp; coords.length === 1) {
            coords = coords[0];
        } else if (type === &#039;LineString&#039;) {
            type = &#039;MultiLineString&#039;;
        }

        return {
            type: &quot;Feature&quot;,
            geometry: {
                type: type,
                coordinates: coords
            },
            properties: this.properties
        };
    };

},{&quot;point-geometry&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/point-geometry/index.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortilelayer.js&quot;:[function(require,module,exports){
    &#039;use strict&#039;;

    var VectorTileFeature = require(&#039;./vectortilefeature.js&#039;);

    module.exports = VectorTileLayer;

    function VectorTileLayer(pbf, end) {
        // Public
        this.version = 1;
        this.name = null;
        this.extent = 4096;
        this.length = 0;

        // Private
        this._pbf = pbf;
        this._keys = [];
        this._values = [];
        this._features = [];

        pbf.readFields(readLayer, this, end);

        this.length = this._features.length;
    }

    function readLayer(tag, layer, pbf) {
        if (tag === 15) layer.version = pbf.readVarint();
        else if (tag === 1) layer.name = pbf.readString();
        else if (tag === 5) layer.extent = pbf.readVarint();
        else if (tag === 2) layer._features.push(pbf.pos);
        else if (tag === 3) layer._keys.push(pbf.readString());
        else if (tag === 4) layer._values.push(readValueMessage(pbf));
    }

    function readValueMessage(pbf) {
        var value = null,
            end = pbf.readVarint() + pbf.pos;

        while (pbf.pos &lt; end) {
            var tag = pbf.readVarint() &gt;&gt; 3;

            value = tag === 1 ? pbf.readString() :
                    tag === 2 ? pbf.readFloat() :
                    tag === 3 ? pbf.readDouble() :
                    tag === 4 ? pbf.readVarint64() :
                    tag === 5 ? pbf.readVarint() :
                    tag === 6 ? pbf.readSVarint() :
                    tag === 7 ? pbf.readBoolean() : null;
        }

        return value;
    }

// return feature `i` from this layer as a `VectorTileFeature`
    VectorTileLayer.prototype.feature = function(i) {
        if (i &lt; 0 || i &gt;= this._features.length) throw new Error(&#039;feature index out of bounds&#039;);

        this._pbf.pos = this._features[i];

        var end = this._pbf.readVarint() + this._pbf.pos;
        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    };

},{&quot;./vectortilefeature.js&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/vector-tile/lib/vectortilefeature.js&quot;}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/inherits/inherits_browser.js&quot;:[function(require,module,exports){
    if (typeof Object.create === &#039;function&#039;) {
        // implementation from standard node.js &#039;util&#039; module
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        };
    } else {
        // old school shim for old browsers
        module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
        }
    }

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/process/browser.js&quot;:[function(require,module,exports){
// shim for using process in browser

    var process = module.exports = {};

    process.nextTick = (function () {
        var canSetImmediate = typeof window !== &#039;undefined&#039;
            &amp;&amp; window.setImmediate;
        var canPost = typeof window !== &#039;undefined&#039;
                &amp;&amp; window.postMessage &amp;&amp; window.addEventListener
            ;

        if (canSetImmediate) {
            return function (f) { return window.setImmediate(f) };
        }

        if (canPost) {
            var queue = [];
            window.addEventListener(&#039;message&#039;, function (ev) {
                var source = ev.source;
                if ((source === window || source === null) &amp;&amp; ev.data === &#039;process-tick&#039;) {
                    ev.stopPropagation();
                    if (queue.length &gt; 0) {
                        var fn = queue.shift();
                        fn();
                    }
                }
            }, true);

            return function nextTick(fn) {
                queue.push(fn);
                window.postMessage(&#039;process-tick&#039;, &#039;*&#039;);
            };
        }

        return function nextTick(fn) {
            setTimeout(fn, 0);
        };
    })();

    process.title = &#039;browser&#039;;
    process.browser = true;
    process.env = {};
    process.argv = [];

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error(&#039;process.binding is not supported&#039;);
    }

// TODO(shtylman)
    process.cwd = function () { return &#039;/&#039; };
    process.chdir = function (dir) {
        throw new Error(&#039;process.chdir is not supported&#039;);
    };

},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/util/support/isBufferBrowser.js&quot;:[function(require,module,exports){
    module.exports = function isBuffer(arg) {
        return arg &amp;&amp; typeof arg === &#039;object&#039;
            &amp;&amp; typeof arg.copy === &#039;function&#039;
            &amp;&amp; typeof arg.fill === &#039;function&#039;
            &amp;&amp; typeof arg.readUInt8 === &#039;function&#039;;
    }
},{}],&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/util/util.js&quot;:[function(require,module,exports){
    (function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function(f) {
            if (!isString(f)) {
                var objects = [];
                for (var i = 0; i &lt; arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                }
                return objects.join(&#039; &#039;);
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
                if (x === &#039;%%&#039;) return &#039;%&#039;;
                if (i &gt;= len) return x;
                switch (x) {
                    case &#039;%s&#039;: return String(args[i++]);
                    case &#039;%d&#039;: return Number(args[i++]);
                    case &#039;%j&#039;:
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return &#039;[Circular]&#039;;
                        }
                    default:
                        return x;
                }
            });
            for (var x = args[i]; i &lt; len; x = args[++i]) {
                if (isNull(x) || !isObject(x)) {
                    str += &#039; &#039; + x;
                } else {
                    str += &#039; &#039; + inspect(x);
                }
            }
            return str;
        };


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
                return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
            }

            if (process.noDeprecation === true) {
                return fn;
            }

            var warned = false;
            function deprecated() {
                if (!warned) {
                    if (process.throwDeprecation) {
                        throw new Error(msg);
                    } else if (process.traceDeprecation) {
                        console.trace(msg);
                    } else {
                        console.error(msg);
                    }
                    warned = true;
                }
                return fn.apply(this, arguments);
            }

            return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
                debugEnviron = process.env.NODE_DEBUG || &#039;&#039;;
            set = set.toUpperCase();
            if (!debugs[set]) {
                if (new RegExp(&#039;\\b&#039; + set + &#039;\\b&#039;, &#039;i&#039;).test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error(&#039;%s %d: %s&#039;, set, pid, msg);
                    };
                } else {
                    debugs[set] = function() {};
                }
            }
            return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
            // default options
            var ctx = {
                seen: [],
                stylize: stylizeNoColor
            };
            // legacy...
            if (arguments.length &gt;= 3) ctx.depth = arguments[2];
            if (arguments.length &gt;= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
                // legacy...
                ctx.showHidden = opts;
            } else if (opts) {
                // got an &quot;options&quot; object
                exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
            &#039;bold&#039; : [1, 22],
            &#039;italic&#039; : [3, 23],
            &#039;underline&#039; : [4, 24],
            &#039;inverse&#039; : [7, 27],
            &#039;white&#039; : [37, 39],
            &#039;grey&#039; : [90, 39],
            &#039;black&#039; : [30, 39],
            &#039;blue&#039; : [34, 39],
            &#039;cyan&#039; : [36, 39],
            &#039;green&#039; : [32, 39],
            &#039;magenta&#039; : [35, 39],
            &#039;red&#039; : [31, 39],
            &#039;yellow&#039; : [33, 39]
        };

// Don&#039;t use &#039;blue&#039; not visible on cmd.exe
        inspect.styles = {
            &#039;special&#039;: &#039;cyan&#039;,
            &#039;number&#039;: &#039;yellow&#039;,
            &#039;boolean&#039;: &#039;yellow&#039;,
            &#039;undefined&#039;: &#039;grey&#039;,
            &#039;null&#039;: &#039;bold&#039;,
            &#039;string&#039;: &#039;green&#039;,
            &#039;date&#039;: &#039;magenta&#039;,
            // &quot;name&quot;: intentionally not styling
            &#039;regexp&#039;: &#039;red&#039;
        };


        function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
                return &#039;\u001b[&#039; + inspect.colors[style][0] + &#039;m&#039; + str +
                    &#039;\u001b[&#039; + inspect.colors[style][1] + &#039;m&#039;;
            } else {
                return str;
            }
        }


        function stylizeNoColor(str, styleType) {
            return str;
        }


        function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
                hash[val] = true;
            });

            return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect &amp;&amp;
                value &amp;&amp;
                isFunction(value.inspect) &amp;&amp;
                // Filter out the util module, it&#039;s inspect function is special
                value.inspect !== exports.inspect &amp;&amp;
                // Also filter out any prototype objects using the circular check.
                !(value.constructor &amp;&amp; value.constructor.prototype === value)) {
                var ret = value.inspect(recurseTimes, ctx);
                if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                }
                return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
                return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
                keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn&#039;t make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (isError(value)
                &amp;&amp; (keys.indexOf(&#039;message&#039;) &gt;= 0 || keys.indexOf(&#039;description&#039;) &gt;= 0)) {
                return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
                if (isFunction(value)) {
                    var name = value.name ? &#039;: &#039; + value.name : &#039;&#039;;
                    return ctx.stylize(&#039;[Function&#039; + name + &#039;]&#039;, &#039;special&#039;);
                }
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), &#039;regexp&#039;);
                }
                if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), &#039;date&#039;);
                }
                if (isError(value)) {
                    return formatError(value);
                }
            }

            var base = &#039;&#039;, array = false, braces = [&#039;{&#039;, &#039;}&#039;];

            // Make Array say that they are Array
            if (isArray(value)) {
                array = true;
                braces = [&#039;[&#039;, &#039;]&#039;];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
                var n = value.name ? &#039;: &#039; + value.name : &#039;&#039;;
                base = &#039; [Function&#039; + n + &#039;]&#039;;
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
                base = &#039; &#039; + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
                base = &#039; &#039; + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
                base = &#039; &#039; + formatError(value);
            }

            if (keys.length === 0 &amp;&amp; (!array || value.length == 0)) {
                return braces[0] + base + braces[1];
            }

            if (recurseTimes &lt; 0) {
                if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), &#039;regexp&#039;);
                } else {
                    return ctx.stylize(&#039;[Object]&#039;, &#039;special&#039;);
                }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
                output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
                output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
            if (isUndefined(value))
                return ctx.stylize(&#039;undefined&#039;, &#039;undefined&#039;);
            if (isString(value)) {
                var simple = &#039;\&#039;&#039; + JSON.stringify(value).replace(/^&quot;|&quot;$/g, &#039;&#039;)
                    .replace(/&#039;/g, &quot;\\&#039;&quot;)
                    .replace(/\\&quot;/g, &#039;&quot;&#039;) + &#039;\&#039;&#039;;
                return ctx.stylize(simple, &#039;string&#039;);
            }
            if (isNumber(value))
                return ctx.stylize(&#039;&#039; + value, &#039;number&#039;);
            if (isBoolean(value))
                return ctx.stylize(&#039;&#039; + value, &#039;boolean&#039;);
            // For some reason typeof null is &quot;object&quot;, so special case here.
            if (isNull(value))
                return ctx.stylize(&#039;null&#039;, &#039;null&#039;);
        }


        function formatError(value) {
            return &#039;[&#039; + Error.prototype.toString.call(value) + &#039;]&#039;;
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i &lt; l; ++i) {
                if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        String(i), true));
                } else {
                    output.push(&#039;&#039;);
                }
            }
            keys.forEach(function(key) {
                if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                        key, true));
                }
            });
            return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
                if (desc.set) {
                    str = ctx.stylize(&#039;[Getter/Setter]&#039;, &#039;special&#039;);
                } else {
                    str = ctx.stylize(&#039;[Getter]&#039;, &#039;special&#039;);
                }
            } else {
                if (desc.set) {
                    str = ctx.stylize(&#039;[Setter]&#039;, &#039;special&#039;);
                }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
                name = &#039;[&#039; + key + &#039;]&#039;;
            }
            if (!str) {
                if (ctx.seen.indexOf(desc.value) &lt; 0) {
                    if (isNull(recurseTimes)) {
                        str = formatValue(ctx, desc.value, null);
                    } else {
                        str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf(&#039;\n&#039;) &gt; -1) {
                        if (array) {
                            str = str.split(&#039;\n&#039;).map(function(line) {
                                return &#039;  &#039; + line;
                            }).join(&#039;\n&#039;).substr(2);
                        } else {
                            str = &#039;\n&#039; + str.split(&#039;\n&#039;).map(function(line) {
                                return &#039;   &#039; + line;
                            }).join(&#039;\n&#039;);
                        }
                    }
                } else {
                    str = ctx.stylize(&#039;[Circular]&#039;, &#039;special&#039;);
                }
            }
            if (isUndefined(name)) {
                if (array &amp;&amp; key.match(/^\d+$/)) {
                    return str;
                }
                name = JSON.stringify(&#039;&#039; + key);
                if (name.match(/^&quot;([a-zA-Z_][a-zA-Z_0-9]*)&quot;$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, &#039;name&#039;);
                } else {
                    name = name.replace(/&#039;/g, &quot;\\&#039;&quot;)
                        .replace(/\\&quot;/g, &#039;&quot;&#039;)
                        .replace(/(^&quot;|&quot;$)/g, &quot;&#039;&quot;);
                    name = ctx.stylize(name, &#039;string&#039;);
                }
            }

            return name + &#039;: &#039; + str;
        }


        function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
                numLinesEst++;
                if (cur.indexOf(&#039;\n&#039;) &gt;= 0) numLinesEst++;
                return prev + cur.replace(/\u001b\[\d\d?m/g, &#039;&#039;).length + 1;
            }, 0);

            if (length &gt; 60) {
                return braces[0] +
                    (base === &#039;&#039; ? &#039;&#039; : base + &#039;\n &#039;) +
                    &#039; &#039; +
                    output.join(&#039;,\n  &#039;) +
                    &#039; &#039; +
                    braces[1];
            }

            return braces[0] + base + &#039; &#039; + output.join(&#039;, &#039;) + &#039; &#039; + braces[1];
        }


// NOTE: These type checking functions intentionally don&#039;t use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
            return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
            return typeof arg === &#039;boolean&#039;;
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
            return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
            return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
            return typeof arg === &#039;number&#039;;
        }
        exports.isNumber = isNumber;

        function isString(arg) {
            return typeof arg === &#039;string&#039;;
        }
        exports.isString = isString;

        function isSymbol(arg) {
            return typeof arg === &#039;symbol&#039;;
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
            return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
            return isObject(re) &amp;&amp; objectToString(re) === &#039;[object RegExp]&#039;;
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
            return typeof arg === &#039;object&#039; &amp;&amp; arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
            return isObject(d) &amp;&amp; objectToString(d) === &#039;[object Date]&#039;;
        }
        exports.isDate = isDate;

        function isError(e) {
            return isObject(e) &amp;&amp;
                (objectToString(e) === &#039;[object Error]&#039; || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
            return typeof arg === &#039;function&#039;;
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
            return arg === null ||
                typeof arg === &#039;boolean&#039; ||
                typeof arg === &#039;number&#039; ||
                typeof arg === &#039;string&#039; ||
                typeof arg === &#039;symbol&#039; ||  // ES6 symbol
                typeof arg === &#039;undefined&#039;;
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require(&#039;./support/isBuffer&#039;);

        function objectToString(o) {
            return Object.prototype.toString.call(o);
        }


        function pad(n) {
            return n &lt; 10 ? &#039;0&#039; + n.toString(10) : n.toString(10);
        }


        var months = [&#039;Jan&#039;, &#039;Feb&#039;, &#039;Mar&#039;, &#039;Apr&#039;, &#039;May&#039;, &#039;Jun&#039;, &#039;Jul&#039;, &#039;Aug&#039;, &#039;Sep&#039;,
            &#039;Oct&#039;, &#039;Nov&#039;, &#039;Dec&#039;];

// 26 Feb 16:19:34
        function timestamp() {
            var d = new Date();
            var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(&#039;:&#039;);
            return [d.getDate(), months[d.getMonth()], time].join(&#039; &#039;);
        }


// log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function() {
            console.log(&#039;%s - %s&#039;, timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require(&#039;inherits&#039;);

        exports._extend = function(origin, add) {
            // Don&#039;t do anything if add isn&#039;t an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
                origin[keys[i]] = add[keys[i]];
            }
            return origin;
        };

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

    }).call(this,require(&#039;_process&#039;),typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})

},{&quot;./support/isBuffer&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/util/support/isBufferBrowser.js&quot;,&quot;_process&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/process/browser.js&quot;,&quot;inherits&quot;:&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/node_modules/watchify/node_modules/browserify/node_modules/inherits/inherits_browser.js&quot;}]},{},[&quot;/Users/crunsh/Documents/Bewerbung/Referenzen/mapbox-gl-js/js/mapbox-gl.js&quot;])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2J1ZmZlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9idWZmZXJfc2V0LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL2RhdGEvYnVmZmVyL2NvbGxpc2lvbl9ib3hfdmVydGV4X2J1ZmZlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9maWxsX3ZlcnRleF9idWZmZXIuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvZ2x5cGhfdmVydGV4X2J1ZmZlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9pY29uX3ZlcnRleF9idWZmZXIuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvbGluZV9lbGVtZW50X2J1ZmZlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9kYXRhL2J1ZmZlci9saW5lX3ZlcnRleF9idWZmZXIuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvb3V0bGluZV9lbGVtZW50c19idWZmZXIuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9idWZmZXIvdHJpYW5nbGVfZWxlbWVudF9idWZmZXIuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9jcmVhdGVfYnVja2V0LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL2RhdGEvZWxlbWVudF9ncm91cHMuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9mZWF0dXJlX3RyZWUuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZGF0YS9maWxsX2J1Y2tldC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9kYXRhL2xpbmVfYnVja2V0LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL2RhdGEvc3ltYm9sX2J1Y2tldC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9nZW8vY29vcmRpbmF0ZS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9nZW8vbGF0X2xuZy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9nZW8vbGF0X2xuZ19ib3VuZHMuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvZ2VvL3RyYW5zZm9ybS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9saWIvZGVidWd0ZXh0LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL21hcGJveC1nbC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd19iYWNrZ3JvdW5kLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3X2NvbGxpc2lvbl9kZWJ1Zy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd19kZWJ1Zy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd19maWxsLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3X2xpbmUuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvcmVuZGVyL2RyYXdfcmFzdGVyLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3JlbmRlci9kcmF3X3N5bWJvbC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZHJhd192ZXJ0aWNlcy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZnJhbWVfaGlzdG9yeS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvZ2xfdXRpbC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvbGluZV9hdGxhcy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvcGFpbnRlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9yZW5kZXIvc2hhZGVycy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvZ2VvanNvbl9zb3VyY2UuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc291cmNlL2dlb2pzb25fd3JhcHBlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvcmFzdGVyX3RpbGVfc291cmNlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3NvdXJjZS9zb3VyY2UuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc291cmNlL3RpbGUuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc291cmNlL3RpbGVfY29vcmQuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc291cmNlL3RpbGVfcHlyYW1pZC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zb3VyY2UvdmVjdG9yX3RpbGVfc291cmNlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3NvdXJjZS92aWRlb19zb3VyY2UuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc291cmNlL3dvcmtlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zb3VyY2Uvd29ya2VyX3RpbGUuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3R5bGUvYW5pbWF0aW9uX2xvb3AuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3R5bGUvaW1hZ2Vfc3ByaXRlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N0eWxlL2xheW91dF9wcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N0eWxlL3BhaW50X3Byb3BlcnRpZXMuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3R5bGUvcmVmZXJlbmNlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N0eWxlL3N0eWxlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N0eWxlL3N0eWxlX2NvbnN0YW50LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N0eWxlL3N0eWxlX2RlY2xhcmF0aW9uLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N0eWxlL3N0eWxlX2RlY2xhcmF0aW9uX3NldC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZV9sYXllci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zdHlsZS9zdHlsZV90cmFuc2l0aW9uLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9hbmNob3IuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2Jpbl9wYWNrLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9jaGVja19tYXhfYW5nbGUuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2NsaXBfbGluZS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvY29sbGlzaW9uX2JveC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvY29sbGlzaW9uX2ZlYXR1cmUuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2NvbGxpc2lvbl90aWxlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3N5bWJvbC9nZXRfYW5jaG9ycy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvZ2x5cGhfYXRsYXMuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3ltYm9sL2dseXBoX3NvdXJjZS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvbWVyZ2VsaW5lcy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvcXVhZHMuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3ltYm9sL3Jlc29sdmVfaWNvbnMuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvc3ltYm9sL3Jlc29sdmVfdGV4dC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvc2hhcGluZy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy9zeW1ib2wvc3ByaXRlX2F0bGFzLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3VpL2NvbnRyb2wvYXR0cmlidXRpb24uanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdWkvY29udHJvbC9jb250cm9sLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3VpL2NvbnRyb2wvbmF2aWdhdGlvbi5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy91aS9lYXNpbmdzLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3VpL2hhbmRsZXJzLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3VpL2hhc2guanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdWkvaW50ZXJhY3Rpb24uanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdWkvbWFwLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3VpL3BvcHVwLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3V0aWwvYWN0b3IuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2FqYXguanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdXRpbC9icm93c2VyL2NhbnZhcy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy91dGlsL2Jyb3dzZXIvZGlzcGF0Y2hlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy91dGlsL2Jyb3dzZXIvZG9tLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3V0aWwvY29uZmlnLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3V0aWwvZXZlbnRlZC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy91dGlsL2dseXBocy5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9qcy91dGlsL2ludGVycG9sYXRlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3V0aWwvbWFwYm94LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3V0aWwvbXJ1X2NhY2hlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL2pzL3V0aWwvdG9rZW4uanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvanMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9jc3Njb2xvcnBhcnNlci9jc3Njb2xvcnBhcnNlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvZmVhdHVyZS1maWx0ZXIvaW5kZXguanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NsaXAuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NvbnZlcnQuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2luZGV4LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9zaW1wbGlmeS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvdGlsZS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2Rpc3QvZ2wtbWF0cml4LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9tYXBib3gtZ2wtZnVuY3Rpb24vaW5kZXguanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS9sYXRlc3QuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS9wYXJzZWQuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS9sYXRlc3QuanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS92Ny5qc29uIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9wYmYvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3BiZi9pbmRleC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvcGJmL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy9wb2ludC1nZW9tZXRyeS9pbmRleC5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvcmJ1c2gvcmJ1c2guanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3VuaXRiZXppZXIvaW5kZXguanMiLCIvVXNlcnMvY3J1bnNoL0RvY3VtZW50cy9CZXdlcmJ1bmcvUmVmZXJlbnplbi9tYXBib3gtZ2wtanMvbm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2luZGV4LmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZS5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy92ZWN0b3ItdGlsZS9saWIvdmVjdG9ydGlsZWxheWVyLmpzIiwiL1VzZXJzL2NydW5zaC9Eb2N1bWVudHMvQmV3ZXJidW5nL1JlZmVyZW56ZW4vbWFwYm94LWdsLWpzL25vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9jcnVuc2gvRG9jdW1lbnRzL0Jld2VyYnVuZy9SZWZlcmVuemVuL21hcGJveC1nbC1qcy9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMveUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHBJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbi8vIGEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIGEgc2luZ2xlIGFycmF5YnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuXG5mdW5jdGlvbiBCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmRlZmF1bHRMZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGVmYXVsdExlbmd0aDtcbiAgICAgICAgdGhpcy5zZXR1cFZpZXdzKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBvbmx5IHJlY3JlYXRlIGJ1ZmZlcnMgYWZ0ZXIgcmVjZWl2aW5nIHRoZW0gZnJvbSB3b3JrZXJzIGZvciBiaW5kaW5nIHRvIGdsLFxuICAgICAgICAvLyBzbyB3ZSBvbmx5IG5lZWQgdGhlc2UgMiBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuYXJyYXkgPSBidWZmZXIuYXJyYXk7XG4gICAgICAgIHRoaXMucG9zID0gYnVmZmVyLnBvcztcbiAgICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUgPSB7XG4gICAgcG9zOiAwLFxuICAgIGl0ZW1TaXplOiA0LCAvLyBieXRlcyBpbiBvbmUgaXRlbVxuICAgIGRlZmF1bHRMZW5ndGg6IDgxOTIsIC8vIGluaXRpYWwgYnVmZmVyIHNpemVcbiAgICBhcnJheVR5cGU6ICdBUlJBWV9CVUZGRVInLCAvLyBnbCBidWZmZXIgdHlwZVxuXG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLyB0aGlzLml0ZW1TaXplO1xuICAgIH0sXG5cbiAgICBzZXR1cFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2V0IHVwIHZpZXdzIGZvciBlYWNoIHR5cGUgdG8gYWRkIGRhdGEgb2YgZGlmZmVyZW50IHR5cGVzIHRvIHRoZSBzYW1lIGJ1ZmZlclxuICAgICAgICB0aGlzLnVieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3IEludDhBcnJheSh0aGlzLmFycmF5KTtcbiAgICAgICAgdGhpcy51c2hvcnRzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICB0aGlzLnNob3J0cyA9IG5ldyBJbnQxNkFycmF5KHRoaXMuYXJyYXkpO1xuICAgIH0sXG5cbiAgICAvLyBiaW5kcyB0aGUgYnVmZmVyIHRvIGEgd2ViZ2wgY29udGV4dFxuICAgIGJpbmQ6IGZ1bmN0aW9uKGdsKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2xbdGhpcy5hcnJheVR5cGVdO1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKHR5cGUsIHRoaXMuYXJyYXkuc2xpY2UoMCwgdGhpcy5wb3MpLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgICAgIC8vIGR1bXAgYXJyYXkgYnVmZmVyIG9uY2UgaXQncyBib3VuZCB0byBnbFxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbihnbCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlciBzaXplIGJ5IDUwJSBpZiBhIG5ldyBpdGVtIGRvZXNuJ3QgZml0XG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy5wb3MgKyB0aGlzLml0ZW1TaXplKSB7XG5cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHRoaXMucG9zICsgdGhpcy5pdGVtU2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsZW5ndGggYnkgNTAlIGJ1dCBrZWVwIGl0IGV2ZW5cbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGgucm91bmQodGhpcy5sZW5ndGggKiAxLjUgLyAyKSAqIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFycmF5IGJ1ZmZlcnMgY2FuJ3QgYmUgcmVzaXplZCwgc28gd2UgY3JlYXRlIGEgbmV3IG9uZSBhbmQgcmVzZXQgYWxsIGJ5dGVzIHRoZXJlXG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEFycmF5QnVmZmVyKHRoaXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHVieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYXJyYXkpO1xuICAgICAgICAgICAgdWJ5dGVzLnNldCh0aGlzLnVieXRlcyk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0dXBWaWV3cygpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExpbmVWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2xpbmVfdmVydGV4X2J1ZmZlcicpO1xudmFyIExpbmVFbGVtZW50QnVmZmVyID0gcmVxdWlyZSgnLi9saW5lX2VsZW1lbnRfYnVmZmVyJyk7XG52YXIgRmlsbFZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vZmlsbF92ZXJ0ZXhfYnVmZmVyJyk7XG52YXIgRmlsbEVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL3RyaWFuZ2xlX2VsZW1lbnRfYnVmZmVyJyk7XG52YXIgT3V0bGluZUVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL291dGxpbmVfZWxlbWVudHNfYnVmZmVyJyk7XG52YXIgR2x5cGhWZXJ0ZXhCdWZmZXIgPSByZXF1aXJlKCcuL2dseXBoX3ZlcnRleF9idWZmZXInKTtcbnZhciBHbHlwaEVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL3RyaWFuZ2xlX2VsZW1lbnRfYnVmZmVyJyk7XG52YXIgSWNvblZlcnRleEJ1ZmZlciA9IHJlcXVpcmUoJy4vaWNvbl92ZXJ0ZXhfYnVmZmVyJyk7XG52YXIgSWNvbkVsZW1lbnRCdWZmZXIgPSByZXF1aXJlKCcuL3RyaWFuZ2xlX2VsZW1lbnRfYnVmZmVyJyk7XG52YXIgQ29sbGlzaW9uQm94VmVydGV4QnVmZmVyID0gcmVxdWlyZSgnLi9jb2xsaXNpb25fYm94X3ZlcnRleF9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihidWZmZXJzZXQpIHtcbiAgICBidWZmZXJzZXQgPSBidWZmZXJzZXQgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2x5cGhWZXJ0ZXg6IG5ldyBHbHlwaFZlcnRleEJ1ZmZlcihidWZmZXJzZXQuZ2x5cGhWZXJ0ZXgpLFxuICAgICAgICBnbHlwaEVsZW1lbnQ6IG5ldyBHbHlwaEVsZW1lbnRCdWZmZXIoYnVmZmVyc2V0LmdseXBoRWxlbWVudCksXG4gICAgICAgIGljb25WZXJ0ZXg6IG5ldyBJY29uVmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5pY29uVmVydGV4KSxcbiAgICAgICAgaWNvbkVsZW1lbnQ6IG5ldyBJY29uRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQuaWNvbkVsZW1lbnQpLFxuICAgICAgICBmaWxsVmVydGV4OiBuZXcgRmlsbFZlcnRleEJ1ZmZlcihidWZmZXJzZXQuZmlsbFZlcnRleCksXG4gICAgICAgIGZpbGxFbGVtZW50OiBuZXcgRmlsbEVsZW1lbnRCdWZmZXIoYnVmZmVyc2V0LmZpbGxFbGVtZW50KSxcbiAgICAgICAgb3V0bGluZUVsZW1lbnQ6IG5ldyBPdXRsaW5lRWxlbWVudEJ1ZmZlcihidWZmZXJzZXQub3V0bGluZUVsZW1lbnQpLFxuICAgICAgICBsaW5lVmVydGV4OiBuZXcgTGluZVZlcnRleEJ1ZmZlcihidWZmZXJzZXQubGluZVZlcnRleCksXG4gICAgICAgIGxpbmVFbGVtZW50OiBuZXcgTGluZUVsZW1lbnRCdWZmZXIoYnVmZmVyc2V0LmxpbmVFbGVtZW50KSxcbiAgICAgICAgY29sbGlzaW9uQm94VmVydGV4OiBuZXcgQ29sbGlzaW9uQm94VmVydGV4QnVmZmVyKGJ1ZmZlcnNldC5jb2xsaXNpb25Cb3hWZXJ0ZXgpXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25Cb3hWZXJ0ZXhCdWZmZXI7XG5cbmZ1bmN0aW9uIENvbGxpc2lvbkJveFZlcnRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5Db2xsaXNpb25Cb3hWZXJ0ZXhCdWZmZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1ZmZlciwge1xuICAgIGl0ZW1TaXplOiAxMiwgLy8gYnl0ZXMgcGVyIHZlcnRleCAoMiAqIHNob3J0ICsgMSAqIHNob3J0ICsgMiAqIGJ5dGUgPSA4IGJ5dGVzKVxuICAgIGRlZmF1bHRMZW5ndGg6IDMyNzY4LFxuXG4gICAgLy8gYWRkIGEgdmVydGV4IHRvIHRoaXMgYnVmZmVyO1xuICAgIC8vIHgsIHkgLSB2ZXJ0ZXggcG9zaXRpb25cbiAgICAvLyBleCwgZXkgLSBleHRydWRlIG5vcm1hbFxuICAgIGFkZDogZnVuY3Rpb24ocG9pbnQsIGV4dHJ1ZGUsIG1heFpvb20sIHBsYWNlbWVudFpvb20pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgcG9zMiA9IHBvcyAvIDIsXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSBwb2ludC54O1xuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSBwb2ludC55O1xuXG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAyXSA9IE1hdGgucm91bmQoZXh0cnVkZS54KTtcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDNdID0gTWF0aC5yb3VuZChleHRydWRlLnkpO1xuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyA4XSA9IE1hdGguZmxvb3IobWF4Wm9vbSAqIDEwKTtcbiAgICAgICAgdGhpcy51Ynl0ZXNbcG9zICsgOV0gPSBNYXRoLmZsb29yKHBsYWNlbWVudFpvb20gKiAxMCk7XG5cbiAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsbFZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gRmlsbFZlcnRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5GaWxsVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWZmZXIsIHtcbiAgICBpdGVtU2l6ZTogNCwgLy8gYnl0ZXMgcGVyIHZlcnRleCAoMiAqIHNob3J0ID09IDQgYnl0ZXMpXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHBvczIgPSB0aGlzLnBvcyAvIDI7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMF0gPSB4O1xuICAgICAgICB0aGlzLnNob3J0c1twb3MyICsgMV0gPSB5O1xuXG4gICAgICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gR2x5cGhWZXJ0ZXhCdWZmZXIoYnVmZmVyKSB7XG4gICAgQnVmZmVyLmNhbGwodGhpcywgYnVmZmVyKTtcbn1cblxuXG5HbHlwaFZlcnRleEJ1ZmZlci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVmZmVyLCB7XG4gICAgZGVmYXVsdExlbmd0aDogMjA0OCAqIDE2LFxuICAgIGl0ZW1TaXplOiAxNixcblxuICAgIGFkZDogZnVuY3Rpb24oeCwgeSwgb3gsIG95LCB0eCwgdHksIG1pbnpvb20sIG1heHpvb20sIGxhYmVsbWluem9vbSkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3MsXG4gICAgICAgICAgICBwb3MyID0gcG9zIC8gMjtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IHg7XG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAxXSA9IHk7XG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAyXSA9IE1hdGgucm91bmQob3ggKiA2NCk7IC8vIHVzZSAxLzY0IHBpeGVscyBmb3IgcGxhY2VtZW50XG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAzXSA9IE1hdGgucm91bmQob3kgKiA2NCk7XG5cbiAgICAgICAgLy8gYV9kYXRhMVxuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyA4XSAvKiB0ZXggKi8gPSBNYXRoLmZsb29yKHR4IC8gNCk7XG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDldIC8qIHRleCAqLyA9IE1hdGguZmxvb3IodHkgLyA0KTtcbiAgICAgICAgdGhpcy51Ynl0ZXNbcG9zICsgMTBdIC8qIGxhYmVsbWluem9vbSAqLyA9IE1hdGguZmxvb3IoKGxhYmVsbWluem9vbSkgKiAxMCk7XG5cbiAgICAgICAgLy8gYV9kYXRhMlxuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyAxMl0gLyogbWluem9vbSAqLyA9IE1hdGguZmxvb3IoKG1pbnpvb20pICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyAxM10gLyogbWF4em9vbSAqLyA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4em9vbSwgMjUpICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuXG4gICAgICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKGdsLCBzaGFkZXIsIG9mZnNldCkge1xuICAgICAgICBCdWZmZXIucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzLCBnbCk7XG5cbiAgICAgICAgdmFyIHN0cmlkZSA9IHRoaXMuaXRlbVNpemU7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9vZmZzZXQsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyA0KTtcblxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2RhdGExLCA0LCBnbC5VTlNJR05FRF9CWVRFLCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyA4KTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9kYXRhMiwgMiwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgb2Zmc2V0ICsgMTIpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhWZXJ0ZXhCdWZmZXI7XG5cbmZ1bmN0aW9uIEdseXBoVmVydGV4QnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cbkdseXBoVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWZmZXIsIHtcbiAgICBkZWZhdWx0TGVuZ3RoOiAyMDQ4ICogMTYsXG4gICAgaXRlbVNpemU6IDE2LFxuXG4gICAgYWRkOiBmdW5jdGlvbih4LCB5LCBveCwgb3ksIHR4LCB0eSwgbWluem9vbSwgbWF4em9vbSwgbGFiZWxtaW56b29tKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgIHBvczIgPSBwb3MgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDBdID0geDtcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0geTtcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDJdID0gTWF0aC5yb3VuZChveCAqIDY0KTsgLy8gdXNlIDEvNjQgcGl4ZWxzIGZvciBwbGFjZW1lbnRcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDNdID0gTWF0aC5yb3VuZChveSAqIDY0KTtcblxuICAgICAgICAvLyBhX2RhdGExXG4gICAgICAgIHRoaXMudWJ5dGVzW3BvcyArIDhdIC8qIHRleCAqLyA9IHR4IC8gNDtcbiAgICAgICAgdGhpcy51Ynl0ZXNbcG9zICsgOV0gLyogdGV4ICovID0gdHkgLyA0O1xuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyAxMF0gLyogbGFiZWxtaW56b29tICovID0gTWF0aC5mbG9vcigobGFiZWxtaW56b29tIHx8IDApICogMTApO1xuXG4gICAgICAgIC8vIGFfZGF0YTJcbiAgICAgICAgdGhpcy51Ynl0ZXNbcG9zICsgMTJdIC8qIG1pbnpvb20gKi8gPSBNYXRoLmZsb29yKChtaW56b29tIHx8IDApICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuICAgICAgICB0aGlzLnVieXRlc1twb3MgKyAxM10gLyogbWF4em9vbSAqLyA9IE1hdGguZmxvb3IoTWF0aC5taW4obWF4em9vbSB8fCAyNSwgMjUpICogMTApOyAvLyAxLzEwIHpvb20gbGV2ZWxzOiB6MTYgPT0gMTYwLlxuXG4gICAgICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKGdsLCBzaGFkZXIsIG9mZnNldCkge1xuICAgICAgICBCdWZmZXIucHJvdG90eXBlLmJpbmQuY2FsbCh0aGlzLCBnbCk7XG5cbiAgICAgICAgdmFyIHN0cmlkZSA9IHRoaXMuaXRlbVNpemU7XG5cbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyAwKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9vZmZzZXQsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9kYXRhMSwgNCwgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIHN0cmlkZSwgb2Zmc2V0ICsgOCk7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfZGF0YTIsIDIsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIG9mZnNldCArIDEyKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVFbGVtZW50QnVmZmVyO1xuXG5mdW5jdGlvbiBMaW5lRWxlbWVudEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5MaW5lRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVmZmVyLCB7XG4gICAgaXRlbVNpemU6IDYsIC8vIGJ5dGVzIHBlciB0cmlhbmdsZSAoMyAqIHVuc2lnbmVkIHNob3J0ID09IDYgYnl0ZXMpXG4gICAgYXJyYXlUeXBlOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInLFxuXG4gICAgYWRkOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XG4gICAgICAgIHRoaXMudXNob3J0c1twb3MyICsgMV0gPSBiO1xuICAgICAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDJdID0gYztcblxuICAgICAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVZlcnRleEJ1ZmZlcjtcblxuZnVuY3Rpb24gTGluZVZlcnRleEJ1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG4vLyBzY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBzbyB0aGF0IHRoZSBub3JtYWwgbGVuZ3RoIGlzIHRoaXMgdmFsdWUuXG4vLyBjb250YWlucyB0aGUgXCJ0ZXh0dXJlXCIgbm9ybWFscyAoLTEuLjEpLiB0aGlzIGlzIGRpc3RpbmN0IGZyb20gdGhlIGV4dHJ1ZGVcbi8vIG5vcm1hbHMgZm9yIGxpbmUgam9pbnMsIGJlY2F1c2UgdGhlIHgtdmFsdWUgcmVtYWlucyAwIGZvciB0aGUgdGV4dHVyZVxuLy8gbm9ybWFsIGFycmF5LCB3aGlsZSB0aGUgZXh0cnVkZSBub3JtYWwgYWN0dWFsbHkgbW92ZXMgdGhlIHZlcnRleCB0byBjcmVhdGVcbi8vIHRoZSBhY3V0ZS9iZXZlbGxlZCBsaW5lIGpvaW4uXG5MaW5lVmVydGV4QnVmZmVyLmV4dHJ1ZGVTY2FsZSA9IDYzO1xuXG5MaW5lVmVydGV4QnVmZmVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWZmZXIsIHtcbiAgICBpdGVtU2l6ZTogOCwgLy8gYnl0ZXMgcGVyIHZlcnRleCAoMiAqIHNob3J0ICsgMSAqIHNob3J0ICsgMiAqIGJ5dGUgPSA4IGJ5dGVzKVxuICAgIGRlZmF1bHRMZW5ndGg6IDMyNzY4LFxuXG4gICAgLy8gYWRkIGEgdmVydGV4IHRvIHRoaXMgYnVmZmVyO1xuICAgIC8vIHgsIHkgLSB2ZXJ0ZXggcG9zaXRpb25cbiAgICAvLyBleCwgZXkgLSBleHRydWRlIG5vcm1hbFxuICAgIC8vIHR4LCB0eSAtIHRleHR1cmUgbm9ybWFsXG4gICAgYWRkOiBmdW5jdGlvbihwb2ludCwgZXh0cnVkZSwgdHgsIHR5LCBsaW5lc29mYXIpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgcG9zMiA9IHBvcyAvIDIsXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICBleHRydWRlU2NhbGUgPSBMaW5lVmVydGV4QnVmZmVyLmV4dHJ1ZGVTY2FsZTtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2hvcnRzW3BvczIgKyAwXSA9IChNYXRoLmZsb29yKHBvaW50LngpICogMikgfCB0eDtcbiAgICAgICAgdGhpcy5zaG9ydHNbcG9zMiArIDFdID0gKE1hdGguZmxvb3IocG9pbnQueSkgKiAyKSB8IHR5O1xuXG4gICAgICAgIHRoaXMuYnl0ZXNbcG9zICsgNF0gPSBNYXRoLnJvdW5kKGV4dHJ1ZGVTY2FsZSAqIGV4dHJ1ZGUueCk7XG4gICAgICAgIHRoaXMuYnl0ZXNbcG9zICsgNV0gPSBNYXRoLnJvdW5kKGV4dHJ1ZGVTY2FsZSAqIGV4dHJ1ZGUueSk7XG4gICAgICAgIHRoaXMuYnl0ZXNbcG9zICsgNl0gPSAobGluZXNvZmFyIHx8IDApIC8gMTI4O1xuICAgICAgICB0aGlzLmJ5dGVzW3BvcyArIDddID0gKGxpbmVzb2ZhciB8fCAwKSAlIDEyODtcblxuICAgICAgICB0aGlzLnBvcyArPSB0aGlzLml0ZW1TaXplO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPdXRsaW5lRWxlbWVudHNCdWZmZXI7XG5cbmZ1bmN0aW9uIE91dGxpbmVFbGVtZW50c0J1ZmZlcihidWZmZXIpIHtcbiAgICBCdWZmZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xufVxuXG5PdXRsaW5lRWxlbWVudHNCdWZmZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1ZmZlciwge1xuICAgIGl0ZW1TaXplOiA0LCAvLyBieXRlcyBwZXIgbGluZSAoMiAqIHVuc2lnbmVkIHNob3J0ID09IDQgYnl0ZXMpXG4gICAgYXJyYXlUeXBlOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInLFxuXG4gICAgYWRkOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHZhciBwb3MyID0gdGhpcy5wb3MgLyAyO1xuXG4gICAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgICAgdGhpcy51c2hvcnRzW3BvczIgKyAwXSA9IGE7XG4gICAgICAgIHRoaXMudXNob3J0c1twb3MyICsgMV0gPSBiO1xuXG4gICAgICAgIHRoaXMucG9zICs9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmlhbmdsZUVsZW1lbnRzQnVmZmVyO1xuXG5mdW5jdGlvbiBUcmlhbmdsZUVsZW1lbnRzQnVmZmVyKGJ1ZmZlcikge1xuICAgIEJ1ZmZlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG59XG5cblRyaWFuZ2xlRWxlbWVudHNCdWZmZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1ZmZlciwge1xuICAgIGl0ZW1TaXplOiA2LCAvLyBieXRlcyBwZXIgdHJpYW5nbGUgKDMgKiB1bnNpZ25lZCBzaG9ydCA9PSA2IGJ5dGVzKVxuICAgIGFycmF5VHlwZTogJ0VMRU1FTlRfQVJSQVlfQlVGRkVSJyxcblxuICAgIGFkZDogZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICB2YXIgcG9zMiA9IHRoaXMucG9zIC8gMjtcblxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIHRoaXMudXNob3J0c1twb3MyICsgMF0gPSBhO1xuICAgICAgICB0aGlzLnVzaG9ydHNbcG9zMiArIDFdID0gYjtcbiAgICAgICAgdGhpcy51c2hvcnRzW3BvczIgKyAyXSA9IGM7XG5cbiAgICAgICAgdGhpcy5wb3MgKz0gdGhpcy5pdGVtU2l6ZTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCdWNrZXQ7XG5cbnZhciBMaW5lQnVja2V0ID0gcmVxdWlyZSgnLi9saW5lX2J1Y2tldCcpO1xudmFyIEZpbGxCdWNrZXQgPSByZXF1aXJlKCcuL2ZpbGxfYnVja2V0Jyk7XG52YXIgU3ltYm9sQnVja2V0ID0gcmVxdWlyZSgnLi9zeW1ib2xfYnVja2V0Jyk7XG52YXIgTGF5b3V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL3N0eWxlL2xheW91dF9wcm9wZXJ0aWVzJyk7XG52YXIgZmVhdHVyZUZpbHRlciA9IHJlcXVpcmUoJ2ZlYXR1cmUtZmlsdGVyJyk7XG52YXIgU3R5bGVEZWNsYXJhdGlvblNldCA9IHJlcXVpcmUoJy4uL3N0eWxlL3N0eWxlX2RlY2xhcmF0aW9uX3NldCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVCdWNrZXQobGF5ZXIsIGJ1ZmZlcnMsIGNvbGxpc2lvbiwgeiwgb3ZlcnNjYWxpbmcsIGNvbGxpc2lvbkRlYnVnKSB7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBTdHlsZURlY2xhcmF0aW9uU2V0KCdsYXlvdXQnLCBsYXllci50eXBlLCBsYXllci5sYXlvdXQsIHt9KS52YWx1ZXMoKSxcbiAgICAgICAgZmFrZVpvb21IaXN0b3J5ID0geyBsYXN0SW50ZWdlclpvb206IEluZmluaXR5LCBsYXN0SW50ZWdlclpvb21UaW1lOiAwLCBsYXN0Wm9vbTogMCB9LFxuICAgICAgICBsYXlvdXQgPSB7fTtcblxuICAgIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG4gICAgICAgIGxheW91dFtrXSA9IHZhbHVlc1trXS5jYWxjdWxhdGUoeiwgZmFrZVpvb21IaXN0b3J5KTtcbiAgICB9XG5cbiAgICB2YXIgQnVja2V0Q2xhc3MgPVxuICAgICAgICBsYXllci50eXBlID09PSAnbGluZScgPyBMaW5lQnVja2V0IDpcbiAgICAgICAgbGF5ZXIudHlwZSA9PT0gJ2ZpbGwnID8gRmlsbEJ1Y2tldCA6XG4gICAgICAgIGxheWVyLnR5cGUgPT09ICdzeW1ib2wnID8gU3ltYm9sQnVja2V0IDogbnVsbDtcblxuICAgIHZhciBidWNrZXQgPSBuZXcgQnVja2V0Q2xhc3MoYnVmZmVycywgbmV3IExheW91dFByb3BlcnRpZXNbbGF5ZXIudHlwZV0obGF5b3V0KSwgY29sbGlzaW9uLCBvdmVyc2NhbGluZywgY29sbGlzaW9uRGVidWcpO1xuXG4gICAgYnVja2V0LmlkID0gbGF5ZXIuaWQ7XG4gICAgYnVja2V0LnR5cGUgPSBsYXllci50eXBlO1xuICAgIGJ1Y2tldFsnc291cmNlLWxheWVyJ10gPSBsYXllclsnc291cmNlLWxheWVyJ107XG4gICAgYnVja2V0LmludGVyYWN0aXZlID0gbGF5ZXIuaW50ZXJhY3RpdmU7XG4gICAgYnVja2V0Lm1pblpvb20gPSBsYXllci5taW56b29tO1xuICAgIGJ1Y2tldC5tYXhab29tID0gbGF5ZXIubWF4em9vbTtcbiAgICBidWNrZXQuZmlsdGVyID0gZmVhdHVyZUZpbHRlcihsYXllci5maWx0ZXIpO1xuICAgIGJ1Y2tldC5mZWF0dXJlcyA9IFtdO1xuXG4gICAgcmV0dXJuIGJ1Y2tldDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50R3JvdXBzO1xuXG5mdW5jdGlvbiBFbGVtZW50R3JvdXBzKHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlciwgc2Vjb25kRWxlbWVudEJ1ZmZlcikge1xuXG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXI7XG4gICAgdGhpcy5lbGVtZW50QnVmZmVyID0gZWxlbWVudEJ1ZmZlcjtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRCdWZmZXIgPSBzZWNvbmRFbGVtZW50QnVmZmVyO1xuICAgIHRoaXMuZ3JvdXBzID0gW107XG59XG5cbkVsZW1lbnRHcm91cHMucHJvdG90eXBlLm1ha2VSb29tRm9yID0gZnVuY3Rpb24obnVtVmVydGljZXMpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudCB8fCB0aGlzLmN1cnJlbnQudmVydGV4TGVuZ3RoICsgbnVtVmVydGljZXMgPiA2NTUzNSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgRWxlbWVudEdyb3VwKHRoaXMudmVydGV4QnVmZmVyLmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEJ1ZmZlciAmJiB0aGlzLmVsZW1lbnRCdWZmZXIuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRFbGVtZW50QnVmZmVyICYmIHRoaXMuc2Vjb25kRWxlbWVudEJ1ZmZlci5pbmRleCk7XG4gICAgICAgIHRoaXMuZ3JvdXBzLnB1c2godGhpcy5jdXJyZW50KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBFbGVtZW50R3JvdXAodmVydGV4U3RhcnRJbmRleCwgZWxlbWVudFN0YXJ0SW5kZXgsIHNlY29uZEVsZW1lbnRTdGFydEluZGV4KSB7XG4gICAgLy8gdGhlIG9mZnNldCBpbnRvIHRoZSB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggaW4gdGhpcyBncm91cFxuICAgIHRoaXMudmVydGV4U3RhcnRJbmRleCA9IHZlcnRleFN0YXJ0SW5kZXg7XG4gICAgdGhpcy5lbGVtZW50U3RhcnRJbmRleCA9IGVsZW1lbnRTdGFydEluZGV4O1xuICAgIHRoaXMuc2Vjb25kRWxlbWVudFN0YXJ0SW5kZXggPSBzZWNvbmRFbGVtZW50U3RhcnRJbmRleDtcbiAgICB0aGlzLmVsZW1lbnRMZW5ndGggPSAwO1xuICAgIHRoaXMudmVydGV4TGVuZ3RoID0gMDtcbiAgICB0aGlzLnNlY29uZEVsZW1lbnRMZW5ndGggPSAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4uL3NvdXJjZS90aWxlX2Nvb3JkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmVhdHVyZVRyZWU7XG5cbmZ1bmN0aW9uIEZlYXR1cmVUcmVlKHRpbGVJZCkge1xuICAgIHRoaXMuY29vcmQgPSBUaWxlQ29vcmQuZnJvbUlEKHRpbGVJZCk7XG4gICAgdGhpcy5ydHJlZSA9IHJidXNoKDkpO1xuICAgIHRoaXMudG9CZUluc2VydGVkID0gW107XG59XG5cbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihiYm94LCBsYXllcnMsIGZlYXR1cmUpIHtcbiAgICBiYm94LmxheWVycyA9IGxheWVycztcbiAgICBiYm94LmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIHRoaXMudG9CZUluc2VydGVkLnB1c2goYmJveCk7XG59O1xuXG4vLyBidWxrIGluc2VydCBpbnRvIHRyZWVcbkZlYXR1cmVUcmVlLnByb3RvdHlwZS5fbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucnRyZWUubG9hZCh0aGlzLnRvQmVJbnNlcnRlZCk7XG4gICAgdGhpcy50b0JlSW5zZXJ0ZWQgPSBbXTtcbn07XG5cbi8vIEZpbmRzIGZlYXR1cmVzIGluIHRoaXMgdGlsZSBhdCBhIHBhcnRpY3VsYXIgcG9zaXRpb24uXG5GZWF0dXJlVHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihhcmdzLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnRvQmVJbnNlcnRlZC5sZW5ndGgpIHRoaXMuX2xvYWQoKTtcblxuICAgIHZhciBwYXJhbXMgPSBhcmdzLnBhcmFtcyB8fCB7fSxcbiAgICAgICAgcmFkaXVzID0gKHBhcmFtcy5yYWRpdXMgfHwgMCkgKiA0MDk2IC8gYXJncy5zY2FsZSxcbiAgICAgICAgeCA9IGFyZ3MueCxcbiAgICAgICAgeSA9IGFyZ3MueSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLnJ0cmVlLnNlYXJjaChbIHggLSByYWRpdXMsIHkgLSByYWRpdXMsIHggKyByYWRpdXMsIHkgKyByYWRpdXMgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IG1hdGNoaW5nW2ldLmZlYXR1cmUsXG4gICAgICAgICAgICBsYXllcnMgPSBtYXRjaGluZ1tpXS5sYXllcnMsXG4gICAgICAgICAgICB0eXBlID0gdnQuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXNbZmVhdHVyZS50eXBlXTtcblxuICAgICAgICBpZiAocGFyYW1zLiR0eXBlICYmIHR5cGUgIT09IHBhcmFtcy4kdHlwZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWdlb21ldHJ5Q29udGFpbnNQb2ludChmZWF0dXJlLmxvYWRHZW9tZXRyeSgpLCB0eXBlLCBuZXcgUG9pbnQoeCwgeSksIHJhZGl1cykpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB2YXIgZ2VvSlNPTiA9IGZlYXR1cmUudG9HZW9KU09OKHRoaXMuY29vcmQueCwgdGhpcy5jb29yZC55LCB0aGlzLmNvb3JkLnopO1xuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxheWVycy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2xdO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmxheWVyICYmIGxheWVyICE9PSBwYXJhbXMubGF5ZXIuaWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHV0aWwuZXh0ZW5kKHtsYXllcjogbGF5ZXJ9LCBnZW9KU09OKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gZ2VvbWV0cnlDb250YWluc1BvaW50KHJpbmdzLCB0eXBlLCBwLCByYWRpdXMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1BvaW50JyA/IHBvaW50Q29udGFpbnNQb2ludChyaW5ncywgcCwgcmFkaXVzKSA6XG4gICAgICAgICAgIHR5cGUgPT09ICdMaW5lU3RyaW5nJyA/IGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIDpcbiAgICAgICAgICAgdHlwZSA9PT0gJ1BvbHlnb24nID8gcG9seUNvbnRhaW5zUG9pbnQocmluZ3MsIHApIHx8IGxpbmVDb250YWluc1BvaW50KHJpbmdzLCBwLCByYWRpdXMpIDogZmFsc2U7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTAxNzI1LzMzMTM3OS5cbmZ1bmN0aW9uIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIHtcbiAgICB2YXIgbDIgPSB2LmRpc3RTcXIodyk7XG4gICAgaWYgKGwyID09PSAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIHZhciB0ID0gKChwLnggLSB2LngpICogKHcueCAtIHYueCkgKyAocC55IC0gdi55KSAqICh3LnkgLSB2LnkpKSAvIGwyO1xuICAgIGlmICh0IDwgMCkgcmV0dXJuIHAuZGlzdFNxcih2KTtcbiAgICBpZiAodCA+IDEpIHJldHVybiBwLmRpc3RTcXIodyk7XG4gICAgcmV0dXJuIHAuZGlzdFNxcih3LnN1Yih2KS5fbXVsdCh0KS5fYWRkKHYpKTtcbn1cblxuZnVuY3Rpb24gbGluZUNvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cykge1xuICAgIHZhciByID0gcmFkaXVzICogcmFkaXVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIC8vIEZpbmQgbGluZSBzZWdtZW50cyB0aGF0IGhhdmUgYSBkaXN0YW5jZSA8PSByYWRpdXNeMiB0byBwXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIHRyZWF0IHRoZSBsaW5lIGFzIFwiY29udGFpbmluZyBwb2ludCBwXCIuXG4gICAgICAgICAgICB2YXIgdiA9IHJpbmdbaiAtIDFdLCB3ID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmIChkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSA8IHIpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcG9pbnQgaW4gcG9seWdvbiByYXkgY2FzdGluZyBhbGdvcml0aG1cbmZ1bmN0aW9uIHBvbHlDb250YWluc1BvaW50KHJpbmdzLCBwKSB7XG4gICAgdmFyIGMgPSBmYWxzZSxcbiAgICAgICAgcmluZywgcDEsIHAyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5ncy5sZW5ndGg7IGsrKykge1xuICAgICAgICByaW5nID0gcmluZ3Nba107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmluZy5sZW5ndGggLSAxOyBpIDwgcmluZy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHAxID0gcmluZ1tpXTtcbiAgICAgICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgICAgIGlmICgoKHAxLnkgPiBwLnkpICE9PSAocDIueSA+IHAueSkpICYmIChwLnggPCAocDIueCAtIHAxLngpICogKHAueSAtIHAxLnkpIC8gKHAyLnkgLSBwMS55KSArIHAxLngpKSB7XG4gICAgICAgICAgICAgICAgYyA9ICFjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBwb2ludENvbnRhaW5zUG9pbnQocmluZ3MsIHAsIHJhZGl1cykge1xuICAgIHZhciByID0gcmFkaXVzICogcmFkaXVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChyaW5nW2pdLmRpc3RTcXIocCkgPD0gcikgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudF9ncm91cHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsQnVja2V0O1xuXG5mdW5jdGlvbiBGaWxsQnVja2V0KGJ1ZmZlcnMpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMuZWxlbWVudEdyb3VwcyA9IG5ldyBFbGVtZW50R3JvdXBzKGJ1ZmZlcnMuZmlsbFZlcnRleCwgYnVmZmVycy5maWxsRWxlbWVudCwgYnVmZmVycy5vdXRsaW5lRWxlbWVudCk7XG59XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlLmxvYWRHZW9tZXRyeSgpKTtcbiAgICB9XG59O1xuXG5GaWxsQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24obGluZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkRmlsbChsaW5lc1tpXSk7XG4gICAgfVxufTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmlsbCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgLy9jb25zb2xlLndhcm4oJ2EgZmlsbCBtdXN0IGhhdmUgYXQgbGVhc3QgdGhyZWUgdmVydGljZXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzIHdlJ3JlIGdvaW5nIHRvIHByb2R1Y2Ugc28gdGhhdCB3ZVxuICAgIC8vIGNhbiByZXNpemUgdGhlIGJ1ZmZlciBiZWZvcmVoYW5kLCBvciBkZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBsaW5lXG4gICAgLy8gd29uJ3QgZml0IGludG8gdGhlIGJ1ZmZlciBhbnltb3JlLlxuICAgIC8vIEluIG9yZGVyIHRvIGJlIGFibGUgdG8gdXNlIHRoZSB2ZXJ0ZXggYnVmZmVyIGZvciBkcmF3aW5nIHRoZSBhbnRpYWxpYXNlZFxuICAgIC8vIG91dGxpbmVzLCB3ZSBzZXBhcmF0ZSBhbGwgcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgZGVnZW5lcmF0ZSAob3V0LW9mLVxuICAgIC8vIHZpZXdwbGFuZSkgdmVydGV4LlxuXG4gICAgdmFyIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBnZW9tZXRyeSBidWZmZXIgY2FuIGhvbGQgYWxsIHRoZSByZXF1aXJlZCB2ZXJ0aWNlcy5cbiAgICB0aGlzLmVsZW1lbnRHcm91cHMubWFrZVJvb21Gb3IobGVuICsgMSk7XG4gICAgdmFyIGVsZW1lbnRHcm91cCA9IHRoaXMuZWxlbWVudEdyb3Vwcy5jdXJyZW50O1xuXG4gICAgdmFyIGZpbGxWZXJ0ZXggPSB0aGlzLmJ1ZmZlcnMuZmlsbFZlcnRleDtcbiAgICB2YXIgZmlsbEVsZW1lbnQgPSB0aGlzLmJ1ZmZlcnMuZmlsbEVsZW1lbnQ7XG4gICAgdmFyIG91dGxpbmVFbGVtZW50ID0gdGhpcy5idWZmZXJzLm91dGxpbmVFbGVtZW50O1xuXG4gICAgLy8gV2UncmUgZ2VuZXJhdGluZyB0cmlhbmdsZSBmYW5zLCBzbyB3ZSBhbHdheXMgc3RhcnQgd2l0aCB0aGUgZmlyc3QgY29vcmRpbmF0ZSBpbiB0aGlzIHBvbHlnb24uXG4gICAgdmFyIGZpcnN0SW5kZXggPSBmaWxsVmVydGV4LmluZGV4IC0gZWxlbWVudEdyb3VwLnZlcnRleFN0YXJ0SW5kZXgsXG4gICAgICAgIHByZXZJbmRleCwgY3VycmVudEluZGV4LCBjdXJyZW50VmVydGV4O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBmaWxsVmVydGV4LmluZGV4IC0gZWxlbWVudEdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgICAgIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICBmaWxsVmVydGV4LmFkZChjdXJyZW50VmVydGV4LngsIGN1cnJlbnRWZXJ0ZXgueSk7XG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGgrKztcblxuICAgICAgICAvLyBPbmx5IGFkZCB0cmlhbmdsZXMgdGhhdCBoYXZlIGRpc3RpbmN0IHZlcnRpY2VzLlxuICAgICAgICBpZiAoaSA+PSAyICYmIChjdXJyZW50VmVydGV4LnggIT09IHZlcnRpY2VzWzBdLnggfHwgY3VycmVudFZlcnRleC55ICE9PSB2ZXJ0aWNlc1swXS55KSkge1xuICAgICAgICAgICAgZmlsbEVsZW1lbnQuYWRkKGZpcnN0SW5kZXgsIHByZXZJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cC5lbGVtZW50TGVuZ3RoKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+PSAxKSB7XG4gICAgICAgICAgICBvdXRsaW5lRWxlbWVudC5hZGQocHJldkluZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLnNlY29uZEVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudF9ncm91cHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQnVja2V0O1xuXG5mdW5jdGlvbiBMaW5lQnVja2V0KGJ1ZmZlcnMsIGxheW91dFByb3BlcnRpZXMsIF8sIG92ZXJzY2FsaW5nKSB7XG4gICAgdGhpcy5idWZmZXJzID0gYnVmZmVycztcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMgPSBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmxpbmVWZXJ0ZXgsIGJ1ZmZlcnMubGluZUVsZW1lbnQpO1xuICAgIHRoaXMubGF5b3V0UHJvcGVydGllcyA9IGxheW91dFByb3BlcnRpZXM7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG92ZXJzY2FsaW5nO1xufVxuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZmVhdHVyZS5sb2FkR2VvbWV0cnkoKSk7XG4gICAgfVxufTtcblxuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgdmFyIGxheW91dFByb3BlcnRpZXMgPSB0aGlzLmxheW91dFByb3BlcnRpZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZExpbmUobGluZXNbaV0sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLWpvaW4nXSxcbiAgICAgICAgICAgIGxheW91dFByb3BlcnRpZXNbJ2xpbmUtY2FwJ10sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLW1pdGVyLWxpbWl0J10sXG4gICAgICAgICAgICBsYXlvdXRQcm9wZXJ0aWVzWydsaW5lLXJvdW5kLWxpbWl0J10pO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgam9pbiwgY2FwLCBtaXRlckxpbWl0LCByb3VuZExpbWl0KSB7XG5cbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIC8vIElmIHRoZSBsaW5lIGhhcyBkdXBsaWNhdGUgdmVydGljZXMgYXQgdGhlIGVuZCwgYWRqdXN0IGxlbmd0aCB0byByZW1vdmUgdGhlbS5cbiAgICB3aGlsZSAobGVuID4gMiAmJiB2ZXJ0aWNlc1tsZW4gLSAxXS5lcXVhbHModmVydGljZXNbbGVuIC0gMl0pKSB7XG4gICAgICAgIGxlbi0tO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIC8vY29uc29sZS53YXJuKCdhIGxpbmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB2ZXJ0aWNlcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGpvaW4gPT09ICdiZXZlbCcpIG1pdGVyTGltaXQgPSAxLjA1O1xuXG4gICAgdmFyIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF0sXG4gICAgICAgIGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc1tsZW4gLSAxXSxcbiAgICAgICAgY2xvc2VkID0gZmlyc3RWZXJ0ZXguZXF1YWxzKGxhc3RWZXJ0ZXgpO1xuXG4gICAgdmFyIGxpbmVWZXJ0ZXggPSB0aGlzLmJ1ZmZlcnMubGluZVZlcnRleDtcbiAgICB2YXIgbGluZUVsZW1lbnQgPSB0aGlzLmJ1ZmZlcnMubGluZUVsZW1lbnQ7XG5cbiAgICAvLyB3ZSBjb3VsZCBiZSBtb3JlIHByZWNpc2UsIGJ1dCBpdCB3b3VsZCBvbmx5IHNhdmUgYSBuZWdsaWdpYmxlIGFtb3VudCBvZiBzcGFjZVxuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5tYWtlUm9vbUZvcihsZW4gKiA0KTtcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gdGhpcy5lbGVtZW50R3JvdXBzLmN1cnJlbnQ7XG4gICAgdmFyIHZlcnRleFN0YXJ0SW5kZXggPSBlbGVtZW50R3JvdXAudmVydGV4U3RhcnRJbmRleDtcblxuICAgIGlmIChsZW4gPT09IDIgJiYgY2xvc2VkKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignYSBsaW5lIG1heSBub3QgaGF2ZSBjb2luY2lkZW50IHBvaW50cycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJlZ2luQ2FwID0gY2FwLFxuICAgICAgICBlbmRDYXAgPSBjbG9zZWQgPyAnYnV0dCcgOiBjYXAsXG4gICAgICAgIGZsaXAgPSAxLFxuICAgICAgICBkaXN0YW5jZSA9IDAsXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXgsIHByZXZWZXJ0ZXgsIG5leHRWZXJ0ZXgsIHByZXZOb3JtYWwsIG5leHROb3JtYWw7XG5cbiAgICAvLyB0aGUgbGFzdCB0aHJlZSB2ZXJ0aWNlcyBhZGRlZFxuICAgIHZhciBlMSwgZTIsIGUzO1xuXG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbbGVuIC0gMl07XG4gICAgICAgIG5leHROb3JtYWwgPSBmaXJzdFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICBuZXh0VmVydGV4ID0gY2xvc2VkICYmIGkgPT09IGxlbiAtIDEgP1xuICAgICAgICAgICAgdmVydGljZXNbMV0gOiAvLyBpZiB0aGUgbGluZSBpcyBjbG9zZWQsIHdlIHRyZWF0IHRoZSBsYXN0IHZlcnRleCBsaWtlIHRoZSBmaXJzdFxuICAgICAgICAgICAgdmVydGljZXNbaSArIDFdOyAvLyBqdXN0IHRoZSBuZXh0IHZlcnRleFxuXG4gICAgICAgIC8vIGlmIHR3byBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBleGlzdCwgc2tpcCB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgaWYgKG5leHRWZXJ0ZXggJiYgdmVydGljZXNbaV0uZXF1YWxzKG5leHRWZXJ0ZXgpKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobmV4dE5vcm1hbCkgcHJldk5vcm1hbCA9IG5leHROb3JtYWw7XG4gICAgICAgIGlmIChjdXJyZW50VmVydGV4KSBwcmV2VmVydGV4ID0gY3VycmVudFZlcnRleDtcblxuICAgICAgICBjdXJyZW50VmVydGV4ID0gdmVydGljZXNbaV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgYWxvbmcgdGhlIGxpbmUgdGhlIGN1cnJlbnRWZXJ0ZXggaXNcbiAgICAgICAgaWYgKHByZXZWZXJ0ZXgpIGRpc3RhbmNlICs9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KSAqIHRoaXMub3ZlcnNjYWxpbmc7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBub3JtYWwgdG93YXJkcyB0aGUgbmV4dCB2ZXJ0ZXggaW4gdGhpcyBsaW5lLiBJbiBjYXNlXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5leHQgdmVydGV4LCBwcmV0ZW5kIHRoYXQgdGhlIGxpbmUgaXMgY29udGludWluZyBzdHJhaWdodCxcbiAgICAgICAgLy8gbWVhbmluZyB0aGF0IHdlIGFyZSBqdXN0IHVzaW5nIHRoZSBwcmV2aW91cyBub3JtYWwuXG4gICAgICAgIG5leHROb3JtYWwgPSBuZXh0VmVydGV4ID8gbmV4dFZlcnRleC5zdWIoY3VycmVudFZlcnRleCkuX3VuaXQoKS5fcGVycCgpIDogcHJldk5vcm1hbDtcblxuICAgICAgICAvLyBJZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGEgcHJldmlvdXMgbm9ybWFsLCB0aGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgYVxuICAgICAgICAvLyBub24tY2xvc2VkIGxpbmUsIHNvIHdlJ3JlIGRvaW5nIGEgc3RyYWlnaHQgXCJqb2luXCIuXG4gICAgICAgIHByZXZOb3JtYWwgPSBwcmV2Tm9ybWFsIHx8IG5leHROb3JtYWw7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBub3JtYWwgb2YgdGhlIGpvaW4gZXh0cnVzaW9uLiBJdCBpcyB0aGUgYW5nbGUgYmlzZWN0b3JcbiAgICAgICAgLy8gb2YgdGhlIHNlZ21lbnRzIGJldHdlZW4gdGhlIHByZXZpb3VzIGxpbmUgYW5kIHRoZSBuZXh0IGxpbmUuXG4gICAgICAgIHZhciBqb2luTm9ybWFsID0gcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkuX3VuaXQoKTtcblxuICAgICAgICAvKiAgam9pbk5vcm1hbCAgICAgcHJldk5vcm1hbFxuICAgICAgICAgKiAgICAgICAgICAgICDihpYgICAgICDihpFcbiAgICAgICAgICogICAgICAgICAgICAgICAgLl9fX19fX19fLiBwcmV2VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogbmV4dE5vcm1hbCAg4oaQICB8ICBjdXJyZW50VmVydGV4XG4gICAgICAgICAqICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogICAgIG5leHRWZXJ0ZXggIVxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgbWl0ZXIgKHRoZSByYXRpbyBvZiB0aGUgbWl0ZXIgdG8gdGhlIHdpZHRoKS5cbiAgICAgICAgLy8gRmluZCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSBuZXh0IGFuZCBqb2luIG5vcm1hbHNcbiAgICAgICAgLy8gdXNpbmcgZG90IHByb2R1Y3QuIFRoZSBpbnZlcnNlIG9mIHRoYXQgaXMgdGhlIG1pdGVyIGxlbmd0aC5cbiAgICAgICAgdmFyIGNvc0hhbGZBbmdsZSA9IGpvaW5Ob3JtYWwueCAqIG5leHROb3JtYWwueCArIGpvaW5Ob3JtYWwueSAqIG5leHROb3JtYWwueTtcbiAgICAgICAgdmFyIG1pdGVyTGVuZ3RoID0gMSAvIGNvc0hhbGZBbmdsZTtcblxuICAgICAgICAvLyBXaGV0aGVyIGFueSB2ZXJ0aWNlcyBoYXZlIGJlZW5cbiAgICAgICAgdmFyIHN0YXJ0T2ZMaW5lID0gZTEgPT09IHVuZGVmaW5lZCB8fCBlMiA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFRoZSBqb2luIGlmIGEgbWlkZGxlIHZlcnRleCwgb3RoZXJ3aXNlIHRoZSBjYXAuXG4gICAgICAgIHZhciBtaWRkbGVWZXJ0ZXggPSBwcmV2VmVydGV4ICYmIG5leHRWZXJ0ZXg7XG4gICAgICAgIHZhciBjdXJyZW50Sm9pbiA9IG1pZGRsZVZlcnRleCA/IGpvaW4gOiBuZXh0VmVydGV4ID8gYmVnaW5DYXAgOiBlbmRDYXA7XG5cbiAgICAgICAgaWYgKG1pZGRsZVZlcnRleCAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJyAmJiBtaXRlckxlbmd0aCA8IHJvdW5kTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ21pdGVyJyAmJiBtaXRlckxlbmd0aCA+IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2JldmVsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXh0cnVkZSBsZW5ndGggaXMgNjMgLyAyNTYgPSA0IHRpbWVzIHRoZSB3aWR0aCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gc28gaWYgbWl0ZXJMZW5ndGggPj0gNCB3ZSBuZWVkIHRvIGRyYXcgYSBkaWZmZXJlbnQgdHlwZSBvZiBiZXZlbCB3aGVyZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA+IDQpIGN1cnJlbnRKb2luID0gJ2ZsaXBiZXZlbCc7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBtaXRlckxlbmd0aCBpcyByZWFsbHkgc21hbGwgYW5kIHRoZSBsaW5lIGJldmVsIHdvdWxkbid0IGJlIHZpc2libGUsXG4gICAgICAgICAgICAvLyBqdXN0IGRyYXcgYSBtaXRlciBqb2luIHRvIHNhdmUgYSB0cmlhbmdsZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA8IG1pdGVyTGltaXQpIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1pdGVyZWQgam9pbnNcbiAgICAgICAgaWYgKGN1cnJlbnRKb2luID09PSAnbWl0ZXInKSB7XG4gICAgICAgICAgICAvLyBzY2FsZSB0aGUgdW5pdCB2ZWN0b3IgYnkgdGhlIG1pdGVyIGxlbmd0aFxuICAgICAgICAgICAgam9pbk5vcm1hbC5fbXVsdChtaXRlckxlbmd0aCk7XG4gICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnZmxpcGJldmVsJykge1xuICAgICAgICAgICAgLy8gbWl0ZXIgaXMgdG9vIGJpZywgZmxpcCB0aGUgZGlyZWN0aW9uIHRvIG1ha2UgYSBiZXZlbGVkIGpvaW5cblxuICAgICAgICAgICAgaWYgKG1pdGVyTGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxtb3N0IHBhcmFsbGVsIGxpbmVzXG4gICAgICAgICAgICAgICAgZmxpcCA9IC1mbGlwO1xuICAgICAgICAgICAgICAgIGpvaW5Ob3JtYWwgPSBuZXh0Tm9ybWFsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBiZXZlbExlbmd0aCA9IG1pdGVyTGVuZ3RoICogcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkubWFnKCkgLyBwcmV2Tm9ybWFsLnN1YihuZXh0Tm9ybWFsKS5tYWcoKTtcbiAgICAgICAgICAgICAgICBqb2luTm9ybWFsLl9wZXJwKCkuX211bHQoZmxpcCAqIGJldmVsTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmbGlwID0gLWZsaXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcblxuICAgICAgICAvLyBBbGwgb3RoZXIgdHlwZXMgb2Ygam9pbnNcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG9mZnNldEEsIG9mZnNldEI7XG4gICAgICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdiZXZlbCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gcHJldk5vcm1hbC54ICogbmV4dE5vcm1hbC55IC0gcHJldk5vcm1hbC55ICogbmV4dE5vcm1hbC54O1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAtTWF0aC5zcXJ0KG1pdGVyTGVuZ3RoICogbWl0ZXJMZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxpcCAqIGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEIgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ3NxdWFyZScpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0QiA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldEEgPSBvZmZzZXRCID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgYnV0dCBvciBhIHNxdWFyZSBjYXAgb3IgYmV2ZWxcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KHByZXZOb3JtYWwsIG9mZnNldEEsIG9mZnNldEIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHJvdW5kIGNhcCBvciBsaW5lam9pbiBhdCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSAmJiBjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgocHJldk5vcm1hbCwgMSwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlZ21lbnQgaW5jbHVkZSBjYXAgYXJlIGRvbmUsIHVuc2V0IHZlcnRpY2VzIHRvIGRpc2Nvbm5lY3Qgc2VnbWVudHMuXG4gICAgICAgICAgICAvLyBPciBsZWF2ZSB0aGVtIHRvIGNyZWF0ZSBhIGJldmVsLlxuICAgICAgICAgICAgaWYgKHN0YXJ0T2ZMaW5lIHx8IGN1cnJlbnRKb2luICE9PSAnYmV2ZWwnKSB7XG4gICAgICAgICAgICAgICAgZTEgPSBlMiA9IC0xO1xuICAgICAgICAgICAgICAgIGZsaXAgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgcm91bmQgY2FwIGJlZm9yZSBmaXJzdCBzZWdtZW50XG4gICAgICAgICAgICBpZiAoc3RhcnRPZkxpbmUgJiYgYmVnaW5DYXAgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICBhZGRDdXJyZW50VmVydGV4KG5leHROb3JtYWwsIC0xLCAtMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudCB3aXRoIGEgYnV0dCBvciBzcXVhcmUgY2FwIG9yIGJldmVsXG4gICAgICAgICAgICBpZiAobmV4dFZlcnRleCkge1xuICAgICAgICAgICAgICAgIGFkZEN1cnJlbnRWZXJ0ZXgobmV4dE5vcm1hbCwgLW9mZnNldEEsIC1vZmZzZXRCLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLypcbiAgICAgKiBBZGRzIHR3byB2ZXJ0aWNlcyB0byB0aGUgYnVmZmVyIHRoYXQgYXJlXG4gICAgICogbm9ybWFsIGFuZCAtbm9ybWFsIGZyb20gdGhlIGN1cnJlbnRWZXJ0ZXguXG4gICAgICpcbiAgICAgKiBlbmRCb3ggbW92ZXMgdGhlIGV4dHJ1ZGUgb25lIHVuaXQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZVxuICAgICAqIHRvIGNyZWF0ZSBzcXVhcmUgb3Igcm91bmQgY2FwLlxuICAgICAqXG4gICAgICogZW5kTGVmdCBhbmQgZW5kUmlnaHQgc2hpZnRzIHRoZSBleHRydWRlIGFsb25nIHRoZSBsaW5lXG4gICAgICogZW5kTGVmdCA9PT0gMSBtb3ZlcyB0aGUgZXh0cnVkZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gICAgICogZW5kTGVmdCA9PT0gLTEgbW92ZXMgdGhlIGV4dHJ1ZGUgaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkQ3VycmVudFZlcnRleChub3JtYWwsIGVuZExlZnQsIGVuZFJpZ2h0LCByb3VuZCkge1xuXG4gICAgICAgIHZhciB0eCA9IHJvdW5kID8gMSA6IDA7XG4gICAgICAgIHZhciBleHRydWRlO1xuXG4gICAgICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdChmbGlwKTtcbiAgICAgICAgaWYgKGVuZExlZnQpIGV4dHJ1ZGUuX3N1Yihub3JtYWwucGVycCgpLl9tdWx0KGVuZExlZnQpKTtcbiAgICAgICAgZTMgPSBsaW5lVmVydGV4LmFkZChjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMCwgZGlzdGFuY2UpIC0gdmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGUxID49IDAgJiYgZTIgPj0gMCkge1xuICAgICAgICAgICAgbGluZUVsZW1lbnQuYWRkKGUxLCBlMiwgZTMpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlMSA9IGUyO1xuICAgICAgICBlMiA9IGUzO1xuXG4gICAgICAgIGV4dHJ1ZGUgPSBub3JtYWwubXVsdCgtZmxpcCk7XG4gICAgICAgIGlmIChlbmRSaWdodCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kUmlnaHQpKTtcbiAgICAgICAgZTMgPSBsaW5lVmVydGV4LmFkZChjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMSwgZGlzdGFuY2UpIC0gdmVydGV4U3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGUxID49IDAgJiYgZTIgPj0gMCkge1xuICAgICAgICAgICAgbGluZUVsZW1lbnQuYWRkKGUxLCBlMiwgZTMpO1xuICAgICAgICAgICAgZWxlbWVudEdyb3VwLmVsZW1lbnRMZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlMSA9IGUyO1xuICAgICAgICBlMiA9IGUzO1xuXG4gICAgICAgIGVsZW1lbnRHcm91cC52ZXJ0ZXhMZW5ndGggKz0gMjtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudEdyb3VwcyA9IHJlcXVpcmUoJy4vZWxlbWVudF9ncm91cHMnKTtcbnZhciBBbmNob3IgPSByZXF1aXJlKCcuLi9zeW1ib2wvYW5jaG9yJyk7XG52YXIgZ2V0QW5jaG9ycyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nZXRfYW5jaG9ycycpO1xudmFyIHJlc29sdmVUb2tlbnMgPSByZXF1aXJlKCcuLi91dGlsL3Rva2VuJyk7XG52YXIgUXVhZHMgPSByZXF1aXJlKCcuLi9zeW1ib2wvcXVhZHMnKTtcbnZhciBTaGFwaW5nID0gcmVxdWlyZSgnLi4vc3ltYm9sL3NoYXBpbmcnKTtcbnZhciByZXNvbHZlVGV4dCA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yZXNvbHZlX3RleHQnKTtcbnZhciByZXNvbHZlSWNvbnMgPSByZXF1aXJlKCcuLi9zeW1ib2wvcmVzb2x2ZV9pY29ucycpO1xudmFyIG1lcmdlTGluZXMgPSByZXF1aXJlKCcuLi9zeW1ib2wvbWVyZ2VsaW5lcycpO1xudmFyIHNoYXBlVGV4dCA9IFNoYXBpbmcuc2hhcGVUZXh0O1xudmFyIHNoYXBlSWNvbiA9IFNoYXBpbmcuc2hhcGVJY29uO1xudmFyIGdldEdseXBoUXVhZHMgPSBRdWFkcy5nZXRHbHlwaFF1YWRzO1xudmFyIGdldEljb25RdWFkcyA9IFF1YWRzLmdldEljb25RdWFkcztcbnZhciBjbGlwTGluZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jbGlwX2xpbmUnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbnZhciBDb2xsaXNpb25GZWF0dXJlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl9mZWF0dXJlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sQnVja2V0O1xuXG5mdW5jdGlvbiBTeW1ib2xCdWNrZXQoYnVmZmVycywgbGF5b3V0UHJvcGVydGllcywgY29sbGlzaW9uLCBvdmVyc2NhbGluZywgY29sbGlzaW9uRGVidWcpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xuICAgIHRoaXMubGF5b3V0UHJvcGVydGllcyA9IGxheW91dFByb3BlcnRpZXM7XG4gICAgdGhpcy5jb2xsaXNpb24gPSBjb2xsaXNpb247XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG92ZXJzY2FsaW5nO1xuICAgIHRoaXMuY29sbGlzaW9uRGVidWcgPSBjb2xsaXNpb25EZWJ1ZztcblxuICAgIHRoaXMuc3ltYm9sSW5zdGFuY2VzID0gW107XG5cbn1cblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dFByb3BlcnRpZXM7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gdGhpcy50ZXh0RmVhdHVyZXM7XG5cbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMC41O1xuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWduID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICAgICAgdmVydGljYWxBbGlnbiA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIganVzdGlmeSA9IGxheW91dFsndGV4dC1qdXN0aWZ5J10gPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgbGF5b3V0Wyd0ZXh0LWp1c3RpZnknXSA9PT0gJ2xlZnQnID8gMCA6XG4gICAgICAgIDAuNTtcblxuICAgIHZhciBvbmVFbSA9IDI0O1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGF5b3V0Wyd0ZXh0LWxpbmUtaGVpZ2h0J10gKiBvbmVFbTtcbiAgICB2YXIgbWF4V2lkdGggPSBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSAhPT0gJ2xpbmUnID8gbGF5b3V0Wyd0ZXh0LW1heC13aWR0aCddICogb25lRW0gOiAwO1xuICAgIHZhciBzcGFjaW5nID0gbGF5b3V0Wyd0ZXh0LWxldHRlci1zcGFjaW5nJ10gKiBvbmVFbTtcbiAgICB2YXIgdGV4dE9mZnNldCA9IFtsYXlvdXRbJ3RleHQtb2Zmc2V0J11bMF0gKiBvbmVFbSwgbGF5b3V0Wyd0ZXh0LW9mZnNldCddWzFdICogb25lRW1dO1xuICAgIHZhciBmb250c3RhY2sgPSBsYXlvdXRbJ3RleHQtZm9udCddO1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBnID0gMDsgZyA8IGZlYXR1cmVzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIGdlb21ldHJpZXMucHVzaChmZWF0dXJlc1tnXS5sb2FkR2VvbWV0cnkoKSk7XG4gICAgfVxuXG4gICAgaWYgKGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgbGluZXMgd2l0aCB0aGUgc2FtZSB0ZXh0IHRvIGltcHJvdmUgbGFiZWxsaW5nLlxuICAgICAgICAvLyBJdCdzIGJldHRlciB0byBwbGFjZSBsYWJlbHMgb24gb25lIGxvbmcgbGluZSB0aGFuIG9uIG1hbnkgc2hvcnQgc2VnbWVudHMuXG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUxpbmVzKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpO1xuXG4gICAgICAgIGdlb21ldHJpZXMgPSBtZXJnZWQuZ2VvbWV0cmllcztcbiAgICAgICAgZmVhdHVyZXMgPSBtZXJnZWQuZmVhdHVyZXM7XG4gICAgICAgIHRleHRGZWF0dXJlcyA9IG1lcmdlZC50ZXh0RmVhdHVyZXM7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlZFRleHQsIHNoYXBlZEljb247XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmICghZ2VvbWV0cmllc1trXSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHRleHRGZWF0dXJlc1trXSkge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IHNoYXBlVGV4dCh0ZXh0RmVhdHVyZXNba10sIHRoaXMuc3RhY2tzW2ZvbnRzdGFja10sIG1heFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRleHRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5b3V0WydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgICAgIHZhciBpY29uTmFtZSA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNba10ucHJvcGVydGllcywgbGF5b3V0WydpY29uLWltYWdlJ10pO1xuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pY29uc1tpY29uTmFtZV07XG4gICAgICAgICAgICBzaGFwZWRJY29uID0gc2hhcGVJY29uKGltYWdlLCBsYXlvdXQpO1xuXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZGZJY29ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2RmSWNvbnMgPSBpbWFnZS5zZGY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNkZkljb25zICE9PSBpbWFnZS5zZGYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdTdHlsZSBzaGVldCB3YXJuaW5nOiBDYW5ub3QgbWl4IFNERiBhbmQgbm9uLVNERiBpY29ucyBpbiBvbmUgYnVja2V0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGVkSWNvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGVkVGV4dCB8fCBzaGFwZWRJY29uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoZ2VvbWV0cmllc1trXSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBsYWNlRmVhdHVyZXModGhpcy5idWZmZXJzLCB0aGlzLmNvbGxpc2lvbkRlYnVnKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uKSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0UHJvcGVydGllcztcbiAgICB2YXIgY29sbGlzaW9uID0gdGhpcy5jb2xsaXNpb247XG5cbiAgICB2YXIgZ2x5cGhTaXplID0gMjQ7XG5cbiAgICB2YXIgZm9udFNjYWxlID0gbGF5b3V0Wyd0ZXh0LW1heC1zaXplJ10gLyBnbHlwaFNpemUsXG4gICAgICAgIHRleHRCb3hTY2FsZSA9IGNvbGxpc2lvbi50aWxlUGl4ZWxSYXRpbyAqIGZvbnRTY2FsZSxcbiAgICAgICAgaWNvbkJveFNjYWxlID0gY29sbGlzaW9uLnRpbGVQaXhlbFJhdGlvICogbGF5b3V0WydpY29uLW1heC1zaXplJ10sXG4gICAgICAgIHN5bWJvbE1pbkRpc3RhbmNlID0gY29sbGlzaW9uLnRpbGVQaXhlbFJhdGlvICogbGF5b3V0WydzeW1ib2wtbWluLWRpc3RhbmNlJ10sXG4gICAgICAgIGF2b2lkRWRnZXMgPSBsYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddLFxuICAgICAgICB0ZXh0UGFkZGluZyA9IGxheW91dFsndGV4dC1wYWRkaW5nJ10gKiBjb2xsaXNpb24udGlsZVBpeGVsUmF0aW8sXG4gICAgICAgIGljb25QYWRkaW5nID0gbGF5b3V0WydpY29uLXBhZGRpbmcnXSAqIGNvbGxpc2lvbi50aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgdGV4dE1heEFuZ2xlID0gbGF5b3V0Wyd0ZXh0LW1heC1hbmdsZSddIC8gMTgwICogTWF0aC5QSSxcbiAgICAgICAgdGV4dEFsb25nTGluZSA9IGxheW91dFsndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJyxcbiAgICAgICAgaWNvbkFsb25nTGluZSA9IGxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcblxuICAgIGlmIChsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgIGxpbmVzID0gY2xpcExpbmUobGluZXMsIDAsIDAsIDQwOTYsIDQwOTYpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGFuY2hvciBwb2ludHMgYXJvdW5kIHdoaWNoIHlvdSB3YW50IHRvIHBsYWNlIGxhYmVsc1xuICAgICAgICB2YXIgYW5jaG9ycyA9IGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScgP1xuICAgICAgICAgICAgZ2V0QW5jaG9ycyhsaW5lLCBzeW1ib2xNaW5EaXN0YW5jZSwgdGV4dE1heEFuZ2xlLCBzaGFwZWRUZXh0LCBnbHlwaFNpemUsIHRleHRCb3hTY2FsZSwgdGhpcy5vdmVyc2NhbGluZykgOlxuICAgICAgICAgICAgWyBuZXcgQW5jaG9yKGxpbmVbMF0ueCwgbGluZVswXS55LCAwKSBdO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHBvdGVudGlhbCBsYWJlbCwgY3JlYXRlIHRoZSBwbGFjZW1lbnQgZmVhdHVyZXMgdXNlZCB0byBjaGVjayBmb3IgY29sbGlzaW9ucywgYW5kIHRoZSBxdWFkcyB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGFuY2hvcnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2pdO1xuXG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gIShhbmNob3IueCA8IDAgfHwgYW5jaG9yLnggPiA0MDk2IHx8IGFuY2hvci55IDwgMCB8fCBhbmNob3IueSA+IDQwOTYpO1xuXG4gICAgICAgICAgICBpZiAoYXZvaWRFZGdlcyAmJiAhaW5zaWRlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdGhpcy5zeW1ib2xJbnN0YW5jZXMucHVzaChuZXcgU3ltYm9sSW5zdGFuY2UoYW5jaG9yLCBsaW5lLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBsYXlvdXQsIGluc2lkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRCb3hTY2FsZSwgdGV4dFBhZGRpbmcsIHRleHRBbG9uZ0xpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY29uQm94U2NhbGUsIGljb25QYWRkaW5nLCBpY29uQWxvbmdMaW5lKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLnBsYWNlRmVhdHVyZXMgPSBmdW5jdGlvbihidWZmZXJzLCBjb2xsaXNpb25EZWJ1Zykge1xuXG4gICAgLy8gQ2FsY3VsYXRlIHdoaWNoIGxhYmVscyBjYW4gYmUgc2hvd24gYW5kIHdoZW4gdGhleSBjYW4gYmUgc2hvd24gYW5kXG4gICAgLy8gY3JlYXRlIHRoZSBidWZlcnMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuXG4gICAgdGhpcy5idWZmZXJzID0gYnVmZmVycztcblxuICAgIHZhciBlbGVtZW50R3JvdXBzID0gdGhpcy5lbGVtZW50R3JvdXBzID0ge1xuICAgICAgICB0ZXh0OiBuZXcgRWxlbWVudEdyb3VwcyhidWZmZXJzLmdseXBoVmVydGV4LCBidWZmZXJzLmdseXBoRWxlbWVudCksXG4gICAgICAgIGljb246IG5ldyBFbGVtZW50R3JvdXBzKGJ1ZmZlcnMuaWNvblZlcnRleCwgYnVmZmVycy5pY29uRWxlbWVudCksXG4gICAgICAgIHNkZkljb25zOiB0aGlzLnNkZkljb25zXG4gICAgfTtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dFByb3BlcnRpZXM7XG4gICAgdmFyIGNvbGxpc2lvbiA9IHRoaXMuY29sbGlzaW9uO1xuICAgIHZhciBtYXhTY2FsZSA9IHRoaXMuY29sbGlzaW9uLm1heFNjYWxlO1xuXG4gICAgdmFyIHRleHRBbG9uZ0xpbmUgPSBsYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZSc7XG4gICAgdmFyIGljb25BbG9uZ0xpbmUgPSBsYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPT09ICdtYXAnICYmIGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZSc7XG5cbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgIHZhciBzeW1ib2xJbnN0YW5jZSA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzW3BdO1xuICAgICAgICB2YXIgaGFzVGV4dCA9IHN5bWJvbEluc3RhbmNlLmhhc1RleHQ7XG4gICAgICAgIHZhciBoYXNJY29uID0gc3ltYm9sSW5zdGFuY2UuaGFzSWNvbjtcblxuICAgICAgICB2YXIgaWNvbldpdGhvdXRUZXh0ID0gbGF5b3V0Wyd0ZXh0LW9wdGlvbmFsJ10gfHwgIWhhc1RleHQsXG4gICAgICAgICAgICB0ZXh0V2l0aG91dEljb24gPSBsYXlvdXRbJ2ljb24tb3B0aW9uYWwnXSB8fCAhaGFzSWNvbjtcblxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVzIGF0IHdoaWNoIHRoZSB0ZXh0IGFuZCBpY29uIGNhbiBiZSBwbGFjZWQgd2l0aG91dCBjb2xsaXNpb24uXG5cbiAgICAgICAgdmFyIGdseXBoU2NhbGUgPSBoYXNUZXh0ICYmICFsYXlvdXRbJ3RleHQtYWxsb3ctb3ZlcmxhcCddID9cbiAgICAgICAgICAgIGNvbGxpc2lvbi5wbGFjZUZlYXR1cmUoc3ltYm9sSW5zdGFuY2UudGV4dENvbGxpc2lvbkZlYXR1cmUpIDogY29sbGlzaW9uLm1pblNjYWxlO1xuXG4gICAgICAgIHZhciBpY29uU2NhbGUgPSBoYXNJY29uICYmICFsYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddID9cbiAgICAgICAgICAgIGNvbGxpc2lvbi5wbGFjZUZlYXR1cmUoc3ltYm9sSW5zdGFuY2UuaWNvbkNvbGxpc2lvbkZlYXR1cmUpIDogY29sbGlzaW9uLm1pblNjYWxlO1xuXG5cbiAgICAgICAgLy8gQ29tYmluZSB0aGUgc2NhbGVzIGZvciBpY29ucyBhbmQgdGV4dC5cblxuICAgICAgICBpZiAoIWljb25XaXRob3V0VGV4dCAmJiAhdGV4dFdpdGhvdXRJY29uKSB7XG4gICAgICAgICAgICBpY29uU2NhbGUgPSBnbHlwaFNjYWxlID0gTWF0aC5tYXgoaWNvblNjYWxlLCBnbHlwaFNjYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGV4dFdpdGhvdXRJY29uICYmIGdseXBoU2NhbGUpIHtcbiAgICAgICAgICAgIGdseXBoU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpY29uV2l0aG91dFRleHQgJiYgaWNvblNjYWxlKSB7XG4gICAgICAgICAgICBpY29uU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBJbnNlcnQgZmluYWwgcGxhY2VtZW50IGludG8gY29sbGlzaW9uIHRyZWUgYW5kIGFkZCBnbHlwaHMvaWNvbnMgdG8gYnVmZmVyc1xuXG4gICAgICAgIGlmIChoYXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10pIHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uaW5zZXJ0RmVhdHVyZShzeW1ib2xJbnN0YW5jZS50ZXh0Q29sbGlzaW9uRmVhdHVyZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2x5cGhTY2FsZSA8PSBtYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9scyhidWZmZXJzLmdseXBoVmVydGV4LCBidWZmZXJzLmdseXBoRWxlbWVudCwgZWxlbWVudEdyb3Vwcy50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2UuZ2x5cGhRdWFkcywgZ2x5cGhTY2FsZSwgbGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddLCB0ZXh0QWxvbmdMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJY29uKSB7XG4gICAgICAgICAgICBpZiAoIWxheW91dFsnaWNvbi1pZ25vcmUtcGxhY2VtZW50J10pIHtcbiAgICAgICAgICAgICAgICBjb2xsaXNpb24uaW5zZXJ0RmVhdHVyZShzeW1ib2xJbnN0YW5jZS5pY29uQ29sbGlzaW9uRmVhdHVyZSwgaWNvblNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpY29uU2NhbGUgPD0gbWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFN5bWJvbHMoYnVmZmVycy5pY29uVmVydGV4LCBidWZmZXJzLmljb25FbGVtZW50LCBlbGVtZW50R3JvdXBzLmljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xJbnN0YW5jZS5pY29uUXVhZHMsIGljb25TY2FsZSwgbGF5b3V0WydpY29uLWtlZXAtdXByaWdodCddLCBpY29uQWxvbmdMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGNvbGxpc2lvbkRlYnVnKSB0aGlzLmFkZFRvRGVidWdCdWZmZXJzKCk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFN5bWJvbHMgPSBmdW5jdGlvbih2ZXJ0ZXgsIGVsZW1lbnQsIGVsZW1lbnRHcm91cHMsIHF1YWRzLCBzY2FsZSwga2VlcFVwcmlnaHQsIGFsb25nTGluZSkge1xuXG4gICAgZWxlbWVudEdyb3Vwcy5tYWtlUm9vbUZvcig0ICogcXVhZHMubGVuZ3RoKTtcbiAgICB2YXIgZWxlbWVudEdyb3VwID0gZWxlbWVudEdyb3Vwcy5jdXJyZW50O1xuXG4gICAgdmFyIHpvb20gPSB0aGlzLmNvbGxpc2lvbi56b29tO1xuICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjIgKyB6b29tO1xuICAgIHZhciBwbGFjZW1lbnRBbmdsZSA9IHRoaXMuY29sbGlzaW9uLmFuZ2xlICsgTWF0aC5QSTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcXVhZHMubGVuZ3RoOyBrKyspIHtcblxuICAgICAgICB2YXIgc3ltYm9sID0gcXVhZHNba10sXG4gICAgICAgICAgICBhbmdsZSA9IHN5bWJvbC5hbmdsZTtcblxuICAgICAgICAvLyBkcm9wIHVwc2lkZSBkb3duIHZlcnNpb25zIG9mIGdseXBoc1xuICAgICAgICB2YXIgYSA9IChhbmdsZSArIHBsYWNlbWVudEFuZ2xlKSAlIChNYXRoLlBJICogMik7XG4gICAgICAgIGlmIChrZWVwVXByaWdodCAmJiBhbG9uZ0xpbmUgJiYgKGEgPD0gTWF0aC5QSSAvIDIgfHwgYSA+IE1hdGguUEkgKiAzIC8gMikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB0bCA9IHN5bWJvbC50bCxcbiAgICAgICAgICAgIHRyID0gc3ltYm9sLnRyLFxuICAgICAgICAgICAgYmwgPSBzeW1ib2wuYmwsXG4gICAgICAgICAgICBiciA9IHN5bWJvbC5icixcbiAgICAgICAgICAgIHRleCA9IHN5bWJvbC50ZXgsXG4gICAgICAgICAgICBhbmNob3IgPSBzeW1ib2wuYW5jaG9yLFxuXG4gICAgICAgICAgICBtaW5ab29tID0gTWF0aC5tYXgoem9vbSArIE1hdGgubG9nKHN5bWJvbC5taW5TY2FsZSkgLyBNYXRoLkxOMiwgcGxhY2VtZW50Wm9vbSksXG4gICAgICAgICAgICBtYXhab29tID0gTWF0aC5taW4oem9vbSArIE1hdGgubG9nKHN5bWJvbC5tYXhTY2FsZSkgLyBNYXRoLkxOMiwgMjUpO1xuXG4gICAgICAgIGlmIChtYXhab29tIDw9IG1pblpvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIExvd2VyIG1pbiB6b29tIHNvIHRoYXQgd2hpbGUgZmFkaW5nIG91dCB0aGUgbGFiZWwgaXQgY2FuIGJlIHNob3duIG91dHNpZGUgb2YgY29sbGlzaW9uLWZyZWUgem9vbSBsZXZlbHNcbiAgICAgICAgaWYgKG1pblpvb20gPT09IHBsYWNlbWVudFpvb20pIG1pblpvb20gPSAwO1xuXG4gICAgICAgIHZhciB0cmlhbmdsZUluZGV4ID0gdmVydGV4LmluZGV4IC0gZWxlbWVudEdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG5cbiAgICAgICAgdmVydGV4LmFkZChhbmNob3IueCwgYW5jaG9yLnksIHRsLngsIHRsLnksIHRleC54LCB0ZXgueSwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIHZlcnRleC5hZGQoYW5jaG9yLngsIGFuY2hvci55LCB0ci54LCB0ci55LCB0ZXgueCArIHRleC53LCB0ZXgueSwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIHZlcnRleC5hZGQoYW5jaG9yLngsIGFuY2hvci55LCBibC54LCBibC55LCB0ZXgueCwgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgIHZlcnRleC5hZGQoYW5jaG9yLngsIGFuY2hvci55LCBici54LCBici55LCB0ZXgueCArIHRleC53LCB0ZXgueSArIHRleC5oLCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgZWxlbWVudEdyb3VwLnZlcnRleExlbmd0aCArPSA0O1xuXG4gICAgICAgIGVsZW1lbnQuYWRkKHRyaWFuZ2xlSW5kZXgsIHRyaWFuZ2xlSW5kZXggKyAxLCB0cmlhbmdsZUluZGV4ICsgMik7XG4gICAgICAgIGVsZW1lbnQuYWRkKHRyaWFuZ2xlSW5kZXggKyAxLCB0cmlhbmdsZUluZGV4ICsgMiwgdHJpYW5nbGVJbmRleCArIDMpO1xuICAgICAgICBlbGVtZW50R3JvdXAuZWxlbWVudExlbmd0aCArPSAyO1xuICAgIH1cblxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5nZXREZXBlbmRlbmNpZXMgPSBmdW5jdGlvbih0aWxlLCBhY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlyc3Rkb25lID0gZmFsc2U7XG4gICAgdGhpcy5nZXRUZXh0RGVwZW5kZW5jaWVzKHRpbGUsIGFjdG9yLCBkb25lKTtcbiAgICB0aGlzLmdldEljb25EZXBlbmRlbmNpZXModGlsZSwgYWN0b3IsIGRvbmUpO1xuICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgfHwgZmlyc3Rkb25lKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgZmlyc3Rkb25lID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmdldEljb25EZXBlbmRlbmNpZXMgPSBmdW5jdGlvbih0aWxlLCBhY3RvciwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5sYXlvdXRQcm9wZXJ0aWVzWydpY29uLWltYWdlJ10pIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICAgICAgdmFyIGljb25zID0gcmVzb2x2ZUljb25zKGZlYXR1cmVzLCB0aGlzLmxheW91dFByb3BlcnRpZXMpO1xuXG4gICAgICAgIGlmIChpY29ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFjdG9yLnNlbmQoJ2dldCBpY29ucycsIHsgaWNvbnM6IGljb25zIH0sIHNldEljb25zLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SWNvbnMoZXJyLCBuZXdpY29ucykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgdGhpcy5pY29ucyA9IG5ld2ljb25zO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuZ2V0VGV4dERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHRpbGUsIGFjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgdmFyIGZvbnRzdGFjayA9IHRoaXMubGF5b3V0UHJvcGVydGllc1sndGV4dC1mb250J107XG5cbiAgICB2YXIgc3RhY2tzID0gdGhpcy5zdGFja3MgPSB0aWxlLnN0YWNrcztcbiAgICBpZiAoc3RhY2tzW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFja3NbZm9udHN0YWNrXSA9IHt9O1xuICAgIH1cbiAgICB2YXIgc3RhY2sgPSBzdGFja3NbZm9udHN0YWNrXTtcblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRleHQoZmVhdHVyZXMsIHRoaXMubGF5b3V0UHJvcGVydGllcywgc3RhY2spO1xuICAgIHRoaXMudGV4dEZlYXR1cmVzID0gZGF0YS50ZXh0RmVhdHVyZXM7XG5cbiAgICBhY3Rvci5zZW5kKCdnZXQgZ2x5cGhzJywge1xuICAgICAgICB1aWQ6IHRpbGUudWlkLFxuICAgICAgICBmb250c3RhY2s6IGZvbnRzdGFjayxcbiAgICAgICAgY29kZXBvaW50czogZGF0YS5jb2RlcG9pbnRzXG4gICAgfSwgZnVuY3Rpb24oZXJyLCBuZXdzdGFjaykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgICAgICBmb3IgKHZhciBjb2RlcG9pbnQgaW4gbmV3c3RhY2spIHtcbiAgICAgICAgICAgIHN0YWNrW2NvZGVwb2ludF0gPSBuZXdzdGFja1tjb2RlcG9pbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkVG9EZWJ1Z0J1ZmZlcnMgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5jb2xsaXNpb25Cb3ggPSBuZXcgRWxlbWVudEdyb3Vwcyh0aGlzLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4KTtcbiAgICB0aGlzLmVsZW1lbnRHcm91cHMuY29sbGlzaW9uQm94Lm1ha2VSb29tRm9yKDApO1xuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuICAgIHZhciBhbmdsZSA9IC10aGlzLmNvbGxpc2lvbi5hbmdsZTtcbiAgICB2YXIgeVN0cmV0Y2ggPSB0aGlzLmNvbGxpc2lvbi55U3RyZXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5zeW1ib2xJbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNbal1baSA9PT0gMCA/ICd0ZXh0Q29sbGlzaW9uRmVhdHVyZScgOiAnaWNvbkNvbGxpc2lvbkZlYXR1cmUnXTtcbiAgICAgICAgICAgIGlmICghZmVhdHVyZSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgYm94ZXMgPSBmZWF0dXJlLmJveGVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJveGVzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJveCA9IGJveGVzW2JdO1xuICAgICAgICAgICAgICAgIHZhciBhbmNob3IgPSBib3guYW5jaG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRsID0gbmV3IFBvaW50KGJveC54MSwgYm94LnkxICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MSAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmwgPSBuZXcgUG9pbnQoYm94LngxLCBib3gueTIgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJyID0gbmV3IFBvaW50KGJveC54MiwgYm94LnkyICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heFpvb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNSwgdGhpcy5jb2xsaXNpb24uem9vbSArIE1hdGgubG9nKGJveC5tYXhTY2FsZSkgLyBNYXRoLkxOMikpO1xuICAgICAgICAgICAgICAgIHZhciBwbGFjZW1lbnRab29tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjUsIHRoaXMuY29sbGlzaW9uLnpvb20gKyBNYXRoLmxvZyhib3gucGxhY2VtZW50U2NhbGUpIC8gTWF0aC5MTjIpKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLCB0bCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChhbmNob3IsIHRyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuYWRkKGFuY2hvciwgdHIsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLCBiciwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChhbmNob3IsIGJyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICBidWZmZXIuYWRkKGFuY2hvciwgYmwsIG1heFpvb20sIHBsYWNlbWVudFpvb20pO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoYW5jaG9yLCBibCwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFkZChhbmNob3IsIHRsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEdyb3Vwcy5jb2xsaXNpb25Cb3guY3VycmVudC52ZXJ0ZXhMZW5ndGggKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFN5bWJvbEluc3RhbmNlKGFuY2hvciwgbGluZSwgc2hhcGVkVGV4dCwgc2hhcGVkSWNvbiwgbGF5b3V0LCBpbnNpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSkge1xuXG4gICAgdGhpcy5oYXNUZXh0ID0gISFzaGFwZWRUZXh0O1xuICAgIHRoaXMuaGFzSWNvbiA9ICEhc2hhcGVkSWNvbjtcblxuICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgdGhpcy5nbHlwaFF1YWRzID0gaW5zaWRlID8gZ2V0R2x5cGhRdWFkcyhhbmNob3IsIHNoYXBlZFRleHQsIHRleHRCb3hTY2FsZSwgbGluZSwgbGF5b3V0LCB0ZXh0QWxvbmdMaW5lKSA6IFtdO1xuICAgICAgICB0aGlzLnRleHRDb2xsaXNpb25GZWF0dXJlID0gbmV3IENvbGxpc2lvbkZlYXR1cmUobGluZSwgYW5jaG9yLCBzaGFwZWRUZXh0LCB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNJY29uKSB7XG4gICAgICAgIHRoaXMuaWNvblF1YWRzID0gaW5zaWRlID8gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgaWNvbkJveFNjYWxlLCBsaW5lLCBsYXlvdXQsIGljb25BbG9uZ0xpbmUpIDogW107XG4gICAgICAgIHRoaXMuaWNvbkNvbGxpc2lvbkZlYXR1cmUgPSBuZXcgQ29sbGlzaW9uRmVhdHVyZShsaW5lLCBhbmNob3IsIHNoYXBlZEljb24sIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlO1xuXG4vKipcbiAqIEEgY29vcmRpbmF0ZSBpcyBhIGNvbHVtbiwgcm93LCB6b29tIGNvbWJpbmF0aW9uLCBvZnRlbiB1c2VkXG4gKiBhcyB0aGUgZGF0YSBjb21wb25lbnQgb2YgYSB0aWxlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5cbiAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSB6b29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb29yZGluYXRlKGNvbHVtbiwgcm93LCB6b29tKSB7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5yb3cgPSByb3c7XG4gICAgdGhpcy56b29tID0gem9vbTtcbn1cblxuQ29vcmRpbmF0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIGNvb3JkaW5hdGUgdGhhdCBjYW4gYmUgbXV0YXRlZCB3aXRob3V0XG4gICAgICogY2hhbmdpbmcgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSBjbG9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcy5jb2x1bW4sIHRoaXMucm93LCB0aGlzLnpvb20pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIHRoaXMgY29vcmRpbmF0ZSB0byBhIGdpdmVuIHpvb20gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gem9vbVxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSB6b29tZWQgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgem9vbVRvOiBmdW5jdGlvbih6b29tKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3pvb21Ubyh6b29tKTsgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHRoZSBjb2x1bW4gYW5kIHJvdyB2YWx1ZXMgb2YgdGhpcyBjb29yZGluYXRlIGZyb20gdGhvc2VcbiAgICAgKiBvZiBhbm90aGVyIGNvb3JkaW5hdGUuIFRoZSBvdGhlciBjb29yZGluYXQgd2lsbCBiZSB6b29tZWQgdG8gdGhlXG4gICAgICogc2FtZSBsZXZlbCBhcyBgdGhpc2AgYmVmb3JlIHRoZSBzdWJ0cmFjdGlvbiBvY2N1cnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gYyBvdGhlciBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9IHJlc3VsdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3ViOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihjKTsgfSxcblxuICAgIF96b29tVG86IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSAtIHRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY29sdW1uICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnJvdyAqPSBzY2FsZTtcbiAgICAgICAgdGhpcy56b29tID0gem9vbTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgYyA9IGMuem9vbVRvKHRoaXMuem9vbSk7XG4gICAgICAgIHRoaXMuY29sdW1uIC09IGMuY29sdW1uO1xuICAgICAgICB0aGlzLnJvdyAtPSBjLnJvdztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMYXRMbmc7XG5cbnZhciB3cmFwID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykud3JhcDtcblxuLyoqXG4gKiBDcmVhdGUgYSBsYXRpdHVkZSwgbG9uZ2l0dWRlIG9iamVjdCBmcm9tIGEgZ2l2ZW4gbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBwYWlyIGluIGRlZ3JlZXMuXG4gKlxuICogQGNsYXNzIExhdExuZ1xuICogQGNsYXNzZGVzYyBBIHJlcHJlc2VudGF0aW9uIG9mIGEgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBwb2ludCwgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgbGF0aXR1ZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbmcgbG9uZ2l0dWRlXG4gKiBAZXhhbXBsZVxuICogdmFyIGxhdGxuZyA9IG5ldyBtYXBib3hnbC5MYXRMbmcoMzcuNzYsIC0xMjIuNDQpO1xuICovXG5mdW5jdGlvbiBMYXRMbmcobGF0LCBsbmcpIHtcbiAgICBpZiAoaXNOYU4obGF0KSB8fCBpc05hTihsbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xuICAgIH1cbiAgICB0aGlzLmxhdCA9ICtsYXQ7XG4gICAgdGhpcy5sbmcgPSArbG5nO1xufVxuXG4vKipcbiAqIFJldHVybiBhIG5ldyBgTGF0TG5nYCBvYmplY3Qgd2hvc2UgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgdG8gdGhlIHJhbmdlICgtMTgwLCAxODApLlxuICpcbiAqIEByZXR1cm5zIHtMYXRMbmd9IHdyYXBwZWQgTGF0TG5nIG9iamVjdFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IG1hcGJveGdsLkxhdExuZygwLCAyMDApO1xuICogdmFyIHdyYXBwZWQgPSBwb2ludC53cmFwKCk7XG4gKiB3cmFwcGVkLmxuZzsgLy8gPSAtMTYwXG4gKi9cbkxhdExuZy5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IExhdExuZyh0aGlzLmxhdCwgd3JhcCh0aGlzLmxuZywgLTE4MCwgMTgwKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYW4gYXJyYXkgdG8gYSBgTGF0TG5nYCBvYmplY3QsIG9yIHJldHVybiBhbiBleGlzdGluZyBgTGF0TG5nYCBvYmplY3RcbiAqIHVuY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj58TGF0TG5nfSBpbnB1dCBgaW5wdXRgIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtMYXRMbmd9IExhdExuZyBvYmplY3Qgb3Igb3JpZ2luYWwgaW5wdXRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBtYXBib3hnbC5MYXRMbmcuY29udmVydChbMTAsIDEwXSk7XG4gKiB2YXIgbGwyID0gbmV3IG1hcGJveGdsLkxhdExuZygxMCwgMTApO1xuICogbGwgLy8gPSBsbDJcbiAqL1xuTGF0TG5nLmNvbnZlcnQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBMYXRMbmcpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmcoaW5wdXRbMF0sIGlucHV0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMYXRMbmdCb3VuZHM7XG5cbnZhciBMYXRMbmcgPSByZXF1aXJlKCcuL2xhdF9sbmcnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IGZyb20gdGhlIGdpdmVuIHBhaXIgb2YgcG9pbnRzLiBJZiBwYXJhbWV0ZXJlcyBhcmUgb21pdHRlZCwgYSBgbnVsbGAgYm91bmRpbmcgYm94IGlzIGNyZWF0ZWQuXG4gKlxuICogQGNsYXNzIExhdExuZ0JvdW5kc1xuICogQGNsYXNzZGVzYyBBIHJlcHJlc2VudGF0aW9uIG9mIHJlY3Rhbmd1bGFyIGJveCBvbiB0aGUgZWFydGgsIGRlZmluZWQgYnkgaXRzIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IHBvaW50cyBpbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxuICogQHBhcmFtIHtMYXRMbmd9IHN3IHNvdXRod2VzdFxuICogQHBhcmFtIHtMYXRMbmd9IG5lIG5vcnRoZWFzdFxuICogQGV4YW1wbGVcbiAqIHZhciBzdyA9IG5ldyBtYXBib3hnbC5MYXRMbmcoMCwgMCk7XG4gKiB2YXIgbmUgPSBuZXcgbWFwYm94Z2wuTGF0TG5nKDEwLCAtMTApO1xuICogdmFyIGJvdW5kcyA9IG5ldyBtYXBib3hnbC5MYXRMbmdCb3VuZHMoc3csIG5lKTtcbiAqXG4gKi9cbmZ1bmN0aW9uIExhdExuZ0JvdW5kcyhzdywgbmUpIHtcbiAgICBpZiAoIXN3KSByZXR1cm47XG5cbiAgICB2YXIgbGF0bG5ncyA9IG5lID8gW3N3LCBuZV0gOiBzdztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kKGxhdGxuZ3NbaV0pO1xuICAgIH1cbn1cblxuTGF0TG5nQm91bmRzLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCB0aGUgYm91bmRzIHRvIGluY2x1ZGUgYSBnaXZlbiBMYXRMbmcgb3IgTGF0TG5nQm91bmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYXRMbmd8TGF0TG5nQm91bmRzfSBvYmogb2JqZWN0IHRvIGV4dGVuZCB0b1xuICAgICAqIEByZXR1cm5zIHtMYXRMbmdCb3VuZHN9IGB0aGlzYFxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBzdyA9IHRoaXMuX3N3LFxuICAgICAgICAgICAgbmUgPSB0aGlzLl9uZSxcbiAgICAgICAgICAgIHN3MiwgbmUyO1xuXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBMYXRMbmcpIHtcbiAgICAgICAgICAgIHN3MiA9IG9iajtcbiAgICAgICAgICAgIG5lMiA9IG9iajtcblxuICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExhdExuZ0JvdW5kcykge1xuICAgICAgICAgICAgc3cyID0gb2JqLl9zdztcbiAgICAgICAgICAgIG5lMiA9IG9iai5fbmU7XG5cbiAgICAgICAgICAgIGlmICghc3cyIHx8ICFuZTIpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqID8gdGhpcy5leHRlbmQoTGF0TG5nLmNvbnZlcnQob2JqKSB8fCBMYXRMbmdCb3VuZHMuY29udmVydChvYmopKSA6IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3ICYmICFuZSkge1xuICAgICAgICAgICAgdGhpcy5fc3cgPSBuZXcgTGF0TG5nKHN3Mi5sYXQsIHN3Mi5sbmcpO1xuICAgICAgICAgICAgdGhpcy5fbmUgPSBuZXcgTGF0TG5nKG5lMi5sYXQsIG5lMi5sbmcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdy5sYXQgPSBNYXRoLm1pbihzdzIubGF0LCBzdy5sYXQpO1xuICAgICAgICAgICAgc3cubG5nID0gTWF0aC5taW4oc3cyLmxuZywgc3cubG5nKTtcbiAgICAgICAgICAgIG5lLmxhdCA9IE1hdGgubWF4KG5lMi5sYXQsIG5lLmxhdCk7XG4gICAgICAgICAgICBuZS5sbmcgPSBNYXRoLm1heChuZTIubG5nLCBuZS5sbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcG9pbnQgZXF1aWRpc3RhbnQgZnJvbSB0aGlzIGJveCdzIGNvcm5lcnNcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nfSBjZW50ZXJwb2ludFxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nKCh0aGlzLl9zdy5sYXQgKyB0aGlzLl9uZS5sYXQpIC8gMiwgKHRoaXMuX3N3LmxuZyArIHRoaXMuX25lLmxuZykgLyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRod2VzdCBjb3JuZXJcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nfSBzb3V0aHdlc3RcbiAgICAgKi9cbiAgICBnZXRTb3V0aFdlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3c7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbm9ydGhlYXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9IG5vcnRoZWFzdFxuICAgICAqL1xuICAgIGdldE5vcnRoRWFzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZTsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aHdlc3QgY29ybmVyXG4gICAgICogQHJldHVybnMge0xhdExuZ30gbm9ydGh3ZXN0XG4gICAgICovXG4gICAgZ2V0Tm9ydGhXZXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMYXRMbmcodGhpcy5nZXROb3J0aCgpLCB0aGlzLmdldFdlc3QoKSk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc291dGhlYXN0IGNvcm5lclxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9IHNvdXRoZWFzdFxuICAgICAqL1xuICAgIGdldFNvdXRoRWFzdDogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgTGF0TG5nKHRoaXMuZ2V0U291dGgoKSwgdGhpcy5nZXRFYXN0KCkpOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHdlc3QgZWRnZSBsb25naXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB3ZXN0XG4gICAgICovXG4gICAgZ2V0V2VzdDogIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc3cubG5nOyB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNvdXRoIGVkZ2UgbGF0aXR1ZGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzb3V0aFxuICAgICAqL1xuICAgIGdldFNvdXRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3N3LmxhdDsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBlYXN0IGVkZ2UgbG9uZ2l0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gZWFzdFxuICAgICAqL1xuICAgIGdldEVhc3Q6ICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lLmxuZzsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBub3J0aCBlZGdlIGxhdGl0dWRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ydGhcbiAgICAgKi9cbiAgICBnZXROb3J0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uZS5sYXQ7IH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgTGF0TG5nQm91bmRzIGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG5MYXRMbmdCb3VuZHMuY29udmVydCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMYXRMbmdCb3VuZHMpIHJldHVybiBhO1xuICAgIHJldHVybiBuZXcgTGF0TG5nQm91bmRzKGEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExhdExuZyA9IHJlcXVpcmUoJy4vbGF0X2xuZycpLFxuICAgIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKSxcbiAgICBDb29yZGluYXRlID0gcmVxdWlyZSgnLi9jb29yZGluYXRlJyksXG4gICAgd3JhcCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpLndyYXAsXG4gICAgaW50ZXJwID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpLFxuICAgIHZlYzQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS52ZWM0LFxuICAgIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLypcbiAqIEEgc2luZ2xlIHRyYW5zZm9ybSwgZ2VuZXJhbGx5IHVzZWQgZm9yIGEgc2luZ2xlIHRpbGUgdG8gYmUgc2NhbGVkLCByb3RhdGVkLCBhbmQgem9vbWVkLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5ab29tXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4Wm9vbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtKG1pblpvb20sIG1heFpvb20pIHtcbiAgICB0aGlzLnRpbGVTaXplID0gNTEyOyAvLyBjb25zdGFudFxuXG4gICAgdGhpcy5fbWluWm9vbSA9IG1pblpvb20gfHwgMDtcbiAgICB0aGlzLl9tYXhab29tID0gbWF4Wm9vbSB8fCAyMjtcblxuICAgIHRoaXMubGF0UmFuZ2UgPSBbLTg1LjA1MTEzLCA4NS4wNTExM107XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy56b29tID0gMDtcbiAgICB0aGlzLmNlbnRlciA9IG5ldyBMYXRMbmcoMCwgMCk7XG4gICAgdGhpcy5hbmdsZSA9IDA7XG4gICAgdGhpcy5fYWx0aXR1ZGUgPSAxLjU7XG4gICAgdGhpcy5fcGl0Y2ggPSAwO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgIGdldCBtaW5ab29tKCkgeyByZXR1cm4gdGhpcy5fbWluWm9vbTsgfSxcbiAgICBzZXQgbWluWm9vbSh6b29tKSB7XG4gICAgICAgIHRoaXMuX21pblpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnpvb20gPSBNYXRoLm1heCh0aGlzLnpvb20sIHpvb20pO1xuICAgIH0sXG5cbiAgICBnZXQgbWF4Wm9vbSgpIHsgcmV0dXJuIHRoaXMuX21heFpvb207IH0sXG4gICAgc2V0IG1heFpvb20oem9vbSkge1xuICAgICAgICB0aGlzLl9tYXhab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5taW4odGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IHdvcmxkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVNpemUgKiB0aGlzLnNjYWxlO1xuICAgIH0sXG5cbiAgICBnZXQgY2VudGVyUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUuX2RpdigyKTtcbiAgICB9LFxuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBnZXQgYmVhcmluZygpIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLmFuZ2xlIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LFxuICAgIHNldCBiZWFyaW5nKGJlYXJpbmcpIHtcbiAgICAgICAgdGhpcy5hbmdsZSA9IC13cmFwKGJlYXJpbmcsIC0xODAsIDE4MCkgKiBNYXRoLlBJIC8gMTgwO1xuICAgIH0sXG5cbiAgICBnZXQgcGl0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXRjaCAvIE1hdGguUEkgKiAxODA7XG4gICAgfSxcbiAgICBzZXQgcGl0Y2gocGl0Y2gpIHtcbiAgICAgICAgdGhpcy5fcGl0Y2ggPSBNYXRoLm1pbig2MCwgcGl0Y2gpIC8gMTgwICogTWF0aC5QSTtcbiAgICB9LFxuXG4gICAgZ2V0IGFsdGl0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWx0aXR1ZGU7XG4gICAgfSxcbiAgICBzZXQgYWx0aXR1ZGUoYWx0aXR1ZGUpIHtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG4gICAgfSxcblxuICAgIGdldCB6b29tKCkgeyByZXR1cm4gdGhpcy5fem9vbTsgfSxcbiAgICBzZXQgem9vbSh6b29tKSB7XG4gICAgICAgIHpvb20gPSBNYXRoLm1pbihNYXRoLm1heCh6b29tLCB0aGlzLm1pblpvb20pLCB0aGlzLm1heFpvb20pO1xuICAgICAgICB0aGlzLl96b29tID0gem9vbTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuem9vbVNjYWxlKHpvb20pO1xuICAgICAgICB0aGlzLnRpbGVab29tID0gTWF0aC5mbG9vcih6b29tKTtcbiAgICAgICAgdGhpcy56b29tRnJhY3Rpb24gPSB6b29tIC0gdGhpcy50aWxlWm9vbTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XG4gICAgfSxcblxuICAgIHpvb21TY2FsZTogZnVuY3Rpb24oem9vbSkgeyByZXR1cm4gTWF0aC5wb3coMiwgem9vbSk7IH0sXG4gICAgc2NhbGVab29tOiBmdW5jdGlvbihzY2FsZSkgeyByZXR1cm4gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5MTjI7IH0sXG5cbiAgICBwcm9qZWN0OiBmdW5jdGlvbihsYXRsbmcsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxhdGxuZy5sbmcsIHdvcmxkU2l6ZSksXG4gICAgICAgICAgICB0aGlzLmxhdFkobGF0bG5nLmxhdCwgd29ybGRTaXplKSk7XG4gICAgfSxcblxuICAgIHVucHJvamVjdDogZnVuY3Rpb24ocG9pbnQsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4gbmV3IExhdExuZyhcbiAgICAgICAgICAgIHRoaXMueUxhdChwb2ludC55LCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy54TG5nKHBvaW50LngsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMubG5nWCh0aGlzLmNlbnRlci5sbmcpOyB9LFxuICAgIGdldCB5KCkgeyByZXR1cm4gdGhpcy5sYXRZKHRoaXMuY2VudGVyLmxhdCk7IH0sXG5cbiAgICBnZXQgcG9pbnQoKSB7IHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpOyB9LFxuXG4gICAgLyoqXG4gICAgICogbGF0L2xvbiA8LT4gYWJzb2x1dGUgcGl4ZWwgY29vcmRzIGNvbnZlcnNpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3b3JsZFNpemU9dGhpcy53b3JsZFNpemVdXG4gICAgICogQHJldHVybnMge051bWJlcn0gcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG5nWDogZnVuY3Rpb24obG9uLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuICgxODAgKyBsb24pICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBsYXRpdHVkZSB0byBhYnNvbHV0ZSB5IGNvb3JkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFt3b3JsZFNpemU9dGhpcy53b3JsZFNpemVdXG4gICAgICogQHJldHVybnMge051bWJlcn0gcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbGF0WTogZnVuY3Rpb24obGF0LCB3b3JsZFNpemUpIHtcbiAgICAgICAgdmFyIHkgPSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSk7XG4gICAgICAgIHJldHVybiAoMTgwIC0geSkgKiAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKSAvIDM2MDtcbiAgICB9LFxuXG4gICAgeExuZzogZnVuY3Rpb24oeCwgd29ybGRTaXplKSB7XG4gICAgICAgIHJldHVybiB4ICogMzYwIC8gKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLSAxODA7XG4gICAgfSxcbiAgICB5TGF0OiBmdW5jdGlvbih5LCB3b3JsZFNpemUpIHtcbiAgICAgICAgdmFyIHkyID0gMTgwIC0geSAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpO1xuICAgICAgICByZXR1cm4gMzYwIC8gTWF0aC5QSSAqIE1hdGguYXRhbihNYXRoLmV4cCh5MiAqIE1hdGguUEkgLyAxODApKSAtIDkwO1xuICAgIH0sXG5cbiAgICBwYW5CeTogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuY2VudGVyUG9pbnQuX2FkZChvZmZzZXQpO1xuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMucG9pbnRMb2NhdGlvbihwb2ludCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICBzZXRMb2NhdGlvbkF0UG9pbnQ6IGZ1bmN0aW9uKGxhdGxuZywgcG9pbnQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsYXRsbmcpO1xuICAgICAgICB2YXIgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUocG9pbnQpO1xuICAgICAgICB2YXIgY29vcmRDZW50ZXIgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh0aGlzLmNlbnRlclBvaW50KTtcblxuICAgICAgICB2YXIgdHJhbnNsYXRlID0gY29vcmRBdFBvaW50Ll9zdWIoYyk7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcblxuICAgICAgICB0aGlzLl9jb25zdHJhaW4oKTtcbiAgICB9LFxuXG4gICAgc2V0Wm9vbUFyb3VuZDogZnVuY3Rpb24oem9vbSwgY2VudGVyKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5sb2NhdGlvblBvaW50KGNlbnRlcik7XG4gICAgICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuc2V0TG9jYXRpb25BdFBvaW50KGNlbnRlciwgcCk7XG4gICAgfSxcblxuICAgIHNldEJlYXJpbmdBcm91bmQ6IGZ1bmN0aW9uKGJlYXJpbmcsIGNlbnRlcikge1xuICAgICAgICB2YXIgcCA9IHRoaXMubG9jYXRpb25Qb2ludChjZW50ZXIpO1xuICAgICAgICB0aGlzLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgICAgICB0aGlzLnNldExvY2F0aW9uQXRQb2ludChjZW50ZXIsIHApO1xuICAgIH0sXG5cbiAgICBsb2NhdGlvblBvaW50OiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZVBvaW50KHRoaXMubG9jYXRpb25Db29yZGluYXRlKGxhdGxuZykpO1xuICAgIH0sXG5cbiAgICBwb2ludExvY2F0aW9uOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVMb2NhdGlvbih0aGlzLnBvaW50Q29vcmRpbmF0ZShwKSk7XG4gICAgfSxcblxuICAgIGxvY2F0aW9uQ29vcmRpbmF0ZTogZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgIHZhciBrID0gdGhpcy56b29tU2NhbGUodGhpcy50aWxlWm9vbSkgLyB0aGlzLndvcmxkU2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxhdGxuZy5sbmcpICogayxcbiAgICAgICAgICAgIHRoaXMubGF0WShsYXRsbmcubGF0KSAqIGssXG4gICAgICAgICAgICB0aGlzLnRpbGVab29tKTtcbiAgICB9LFxuXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTGF0TG5nKFxuICAgICAgICAgICAgdGhpcy55TGF0KGNvb3JkLnJvdywgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueExuZyhjb29yZC5jb2x1bW4sIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHAsIHRhcmdldFopIHtcblxuICAgICAgICBpZiAodGFyZ2V0WiA9PT0gdW5kZWZpbmVkKSB0YXJnZXRaID0gMDtcblxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5jb29yZGluYXRlUG9pbnRNYXRyaXgodGhpcy50aWxlWm9vbSk7XG4gICAgICAgIHZhciBpbnZlcnRlZCA9IG1hdDQuaW52ZXJ0KG5ldyBGbG9hdDY0QXJyYXkoMTYpLCBtYXRyaXgpO1xuXG4gICAgICAgIGlmICghaW52ZXJ0ZWQpIHRocm93IFwiZmFpbGVkIHRvIGludmVydCBtYXRyaXhcIjtcblxuICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gICAgICAgIC8vIHVucHJvamVjdCB0d28gcG9pbnRzIHRvIGdldCBhIGxpbmUgYW5kIHRoZW4gZmluZCB0aGUgcG9pbnQgb24gdGhhdFxuICAgICAgICAvLyBsaW5lIHdpdGggej0wXG5cbiAgICAgICAgdmFyIGNvb3JkMCA9IHZlYzQudHJhbnNmb3JtTWF0NChbXSwgW3AueCwgcC55LCAwLCAxXSwgaW52ZXJ0ZWQpO1xuICAgICAgICB2YXIgY29vcmQxID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLCBbcC54LCBwLnksIDEsIDFdLCBpbnZlcnRlZCk7XG5cbiAgICAgICAgdmFyIHcwID0gY29vcmQwWzNdO1xuICAgICAgICB2YXIgdzEgPSBjb29yZDFbM107XG4gICAgICAgIHZhciB4MCA9IGNvb3JkMFswXSAvIHcwO1xuICAgICAgICB2YXIgeDEgPSBjb29yZDFbMF0gLyB3MTtcbiAgICAgICAgdmFyIHkwID0gY29vcmQwWzFdIC8gdzA7XG4gICAgICAgIHZhciB5MSA9IGNvb3JkMVsxXSAvIHcxO1xuICAgICAgICB2YXIgejAgPSBjb29yZDBbMl0gLyB3MDtcbiAgICAgICAgdmFyIHoxID0gY29vcmQxWzJdIC8gdzE7XG5cblxuICAgICAgICB2YXIgdCA9IHowID09PSB6MSA/IDAgOiAodGFyZ2V0WiAtIHowKSAvICh6MSAtIHowKTtcblxuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoXG4gICAgICAgICAgICBpbnRlcnAoeDAsIHgxLCB0KSxcbiAgICAgICAgICAgIGludGVycCh5MCwgeTEsIHQpLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIGNvb3JkaW5hdGVQb2ludDogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY29vcmRpbmF0ZVBvaW50TWF0cml4KGNvb3JkLnpvb20pO1xuICAgICAgICB2YXIgcCA9IHZlYzQudHJhbnNmb3JtTWF0NChbXSwgW2Nvb3JkLmNvbHVtbiwgY29vcmQucm93LCAwLCAxXSwgbWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwWzBdIC8gcFszXSwgcFsxXSAvIHBbM10pO1xuICAgIH0sXG5cbiAgICBjb29yZGluYXRlUG9pbnRNYXRyaXg6IGZ1bmN0aW9uKHopIHtcbiAgICAgICAgdmFyIHByb2ogPSB0aGlzLmdldFByb2pNYXRyaXgoKTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy53b3JsZFNpemUgLyB0aGlzLnpvb21TY2FsZSh6KTtcbiAgICAgICAgbWF0NC5zY2FsZShwcm9qLCBwcm9qLCBbc2NhbGUsIHNjYWxlLCAxXSk7XG4gICAgICAgIG1hdDQubXVsdGlwbHkocHJvaiwgdGhpcy5nZXRQaXhlbE1hdHJpeCgpLCBwcm9qKTtcbiAgICAgICAgcmV0dXJuIHByb2o7XG4gICAgfSxcblxuICAgIC8vIGNvbnZlcnRzIGdsIGNvb3JkaW5hdGVzIC0xLi4xIHRvIHBpeGVscyAwLi53aWR0aFxuICAgIGdldFBpeGVsTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG0gPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIF9jb25zdHJhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2VudGVyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIG1pblksIG1heFksIG1pblgsIG1heFgsIHN5LCBzeCwgeDIsIHkyLFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZTtcblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgbWluWSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzFdKTtcbiAgICAgICAgICAgIG1heFkgPSB0aGlzLmxhdFkodGhpcy5sYXRSYW5nZVswXSk7XG4gICAgICAgICAgICBzeSA9IG1heFkgLSBtaW5ZIDwgc2l6ZS55ID8gc2l6ZS55IC8gKG1heFkgLSBtaW5ZKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgbWluWCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzBdKTtcbiAgICAgICAgICAgIG1heFggPSB0aGlzLmxuZ1godGhpcy5sbmdSYW5nZVsxXSk7XG4gICAgICAgICAgICBzeCA9IG1heFggLSBtaW5YIDwgc2l6ZS54ID8gc2l6ZS54IC8gKG1heFggLSBtaW5YKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBob3cgbXVjaCB0aGUgbWFwIHNob3VsZCBzY2FsZSB0byBmaXQgdGhlIHNjcmVlbiBpbnRvIGdpdmVuIGxhdGl0dWRlL2xvbmdpdHVkZSByYW5nZXNcbiAgICAgICAgdmFyIHMgPSBNYXRoLm1heChzeCB8fCAwLCBzeSB8fCAwKTtcblxuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnVucHJvamVjdChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgc3ggPyAobWF4WCArIG1pblgpIC8gMiA6IHRoaXMueCxcbiAgICAgICAgICAgICAgICBzeSA/IChtYXhZICsgbWluWSkgLyAyIDogdGhpcy55KSk7XG4gICAgICAgICAgICB0aGlzLnpvb20gKz0gdGhpcy5zY2FsZVpvb20ocyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnksXG4gICAgICAgICAgICAgICAgaDIgPSBzaXplLnkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeSAtIGgyIDwgbWluWSkgeTIgPSBtaW5ZICsgaDI7XG4gICAgICAgICAgICBpZiAoeSArIGgyID4gbWF4WSkgeTIgPSBtYXhZIC0gaDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICAgICAgdzIgPSBzaXplLnggLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAtIHcyIDwgbWluWCkgeDIgPSBtaW5YICsgdzI7XG4gICAgICAgICAgICBpZiAoeCArIHcyID4gbWF4WCkgeDIgPSBtYXhYIC0gdzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW4gdGhlIG1hcCBpZiB0aGUgc2NyZWVuIGdvZXMgb2ZmIHRoZSByYW5nZVxuICAgICAgICBpZiAoeDIgIT09IHVuZGVmaW5lZCB8fCB5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICB4MiAhPT0gdW5kZWZpbmVkID8geDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgeTIgIT09IHVuZGVmaW5lZCA/IHkyIDogdGhpcy55KSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UHJvak1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgICAgIG1hdDQucGVyc3BlY3RpdmUobSwgMiAqIE1hdGguYXRhbigodGhpcy5oZWlnaHQgLyAyKSAvIHRoaXMuYWx0aXR1ZGUpLCB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQsIDAuMSwgdGhpcy5hbHRpdHVkZSArIDEpO1xuXG4gICAgICAgIG1hdDQudHJhbnNsYXRlKG0sIG0sIFswLCAwLCAtdGhpcy5hbHRpdHVkZV0pO1xuXG4gICAgICAgIC8vIEFmdGVyIHRoZSByb3RhdGVYLCB6IHZhbHVlcyBhcmUgaW4gcGl4ZWwgdW5pdHMuIENvbnZlcnQgdGhlbSB0b1xuICAgICAgICAvLyBhbHRpdHVkZSB1bml0ZXMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAgICAgbWF0NC5yb3RhdGVYKG0sIG0sIHRoaXMuX3BpdGNoKTtcbiAgICAgICAgbWF0NC5yb3RhdGVaKG0sIG0sIHRoaXMuYW5nbGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbLXRoaXMueCwgLXRoaXMueSwgMF0pO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBGb250IGRhdGEgRnJvbSBIZXJzaGV5IFNpbXBsZXggRm9udFxuLy8gaHR0cDovL3BhdWxib3Vya2UubmV0L2RhdGFmb3JtYXRzL2hlcnNoZXkvXG52YXIgc2ltcGxleEZvbnQgPSB7XG4gICAgXCIgXCI6IFsxNiwgW11dLFxuICAgIFwiIVwiOiBbMTAsIFs1LCAyMSwgNSwgNywgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCJcXFwiXCI6IFsxNiwgWzQsIDIxLCA0LCAxNCwgLTEsIC0xLCAxMiwgMjEsIDEyLCAxNF1dLFxuICAgIFwiI1wiOiBbMjEsIFsxMSwgMjUsIDQsIC03LCAtMSwgLTEsIDE3LCAyNSwgMTAsIC03LCAtMSwgLTEsIDQsIDEyLCAxOCwgMTIsIC0xLCAtMSwgMywgNiwgMTcsIDZdXSxcbiAgICBcIiRcIjogWzIwLCBbOCwgMjUsIDgsIC00LCAtMSwgLTEsIDEyLCAyNSwgMTIsIC00LCAtMSwgLTEsIDE3LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxLCA1LCAyMCwgMywgMTgsIDMsIDE2LCA0LCAxNCwgNSwgMTMsIDcsIDEyLCAxMywgMTAsIDE1LCA5LCAxNiwgOCwgMTcsIDYsIDE3LCAzLCAxNSwgMSwgMTIsIDAsIDgsIDAsIDUsIDEsIDMsIDNdXSxcbiAgICBcIiVcIjogWzI0LCBbMjEsIDIxLCAzLCAwLCAtMSwgLTEsIDgsIDIxLCAxMCwgMTksIDEwLCAxNywgOSwgMTUsIDcsIDE0LCA1LCAxNCwgMywgMTYsIDMsIDE4LCA0LCAyMCwgNiwgMjEsIDgsIDIxLCAxMCwgMjAsIDEzLCAxOSwgMTYsIDE5LCAxOSwgMjAsIDIxLCAyMSwgLTEsIC0xLCAxNywgNywgMTUsIDYsIDE0LCA0LCAxNCwgMiwgMTYsIDAsIDE4LCAwLCAyMCwgMSwgMjEsIDMsIDIxLCA1LCAxOSwgNywgMTcsIDddXSxcbiAgICBcIiZcIjogWzI2LCBbMjMsIDEyLCAyMywgMTMsIDIyLCAxNCwgMjEsIDE0LCAyMCwgMTMsIDE5LCAxMSwgMTcsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDcsIDAsIDUsIDEsIDQsIDIsIDMsIDQsIDMsIDYsIDQsIDgsIDUsIDksIDEyLCAxMywgMTMsIDE0LCAxNCwgMTYsIDE0LCAxOCwgMTMsIDIwLCAxMSwgMjEsIDksIDIwLCA4LCAxOCwgOCwgMTYsIDksIDEzLCAxMSwgMTAsIDE2LCAzLCAxOCwgMSwgMjAsIDAsIDIyLCAwLCAyMywgMSwgMjMsIDJdXSxcbiAgICBcIidcIjogWzEwLCBbNSwgMTksIDQsIDIwLCA1LCAyMSwgNiwgMjAsIDYsIDE4LCA1LCAxNiwgNCwgMTVdXSxcbiAgICBcIihcIjogWzE0LCBbMTEsIDI1LCA5LCAyMywgNywgMjAsIDUsIDE2LCA0LCAxMSwgNCwgNywgNSwgMiwgNywgLTIsIDksIC01LCAxMSwgLTddXSxcbiAgICBcIilcIjogWzE0LCBbMywgMjUsIDUsIDIzLCA3LCAyMCwgOSwgMTYsIDEwLCAxMSwgMTAsIDcsIDksIDIsIDcsIC0yLCA1LCAtNSwgMywgLTddXSxcbiAgICBcIipcIjogWzE2LCBbOCwgMjEsIDgsIDksIC0xLCAtMSwgMywgMTgsIDEzLCAxMiwgLTEsIC0xLCAxMywgMTgsIDMsIDEyXV0sXG4gICAgXCIrXCI6IFsyNiwgWzEzLCAxOCwgMTMsIDAsIC0xLCAtMSwgNCwgOSwgMjIsIDldXSxcbiAgICBcIixcIjogWzEwLCBbNiwgMSwgNSwgMCwgNCwgMSwgNSwgMiwgNiwgMSwgNiwgLTEsIDUsIC0zLCA0LCAtNF1dLFxuICAgIFwiLVwiOiBbMjYsIFs0LCA5LCAyMiwgOV1dLFxuICAgIFwiLlwiOiBbMTAsIFs1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCIvXCI6IFsyMiwgWzIwLCAyNSwgMiwgLTddXSxcbiAgICBcIjBcIjogWzIwLCBbOSwgMjEsIDYsIDIwLCA0LCAxNywgMywgMTIsIDMsIDksIDQsIDQsIDYsIDEsIDksIDAsIDExLCAwLCAxNCwgMSwgMTYsIDQsIDE3LCA5LCAxNywgMTIsIDE2LCAxNywgMTQsIDIwLCAxMSwgMjEsIDksIDIxXV0sXG4gICAgXCIxXCI6IFsyMCwgWzYsIDE3LCA4LCAxOCwgMTEsIDIxLCAxMSwgMF1dLFxuICAgIFwiMlwiOiBbMjAsIFs0LCAxNiwgNCwgMTcsIDUsIDE5LCA2LCAyMCwgOCwgMjEsIDEyLCAyMSwgMTQsIDIwLCAxNSwgMTksIDE2LCAxNywgMTYsIDE1LCAxNSwgMTMsIDEzLCAxMCwgMywgMCwgMTcsIDBdXSxcbiAgICBcIjNcIjogWzIwLCBbNSwgMjEsIDE2LCAyMSwgMTAsIDEzLCAxMywgMTMsIDE1LCAxMiwgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcbiAgICBcIjRcIjogWzIwLCBbMTMsIDIxLCAzLCA3LCAxOCwgNywgLTEsIC0xLCAxMywgMjEsIDEzLCAwXV0sXG4gICAgXCI1XCI6IFsyMCwgWzE1LCAyMSwgNSwgMjEsIDQsIDEyLCA1LCAxMywgOCwgMTQsIDExLCAxNCwgMTQsIDEzLCAxNiwgMTEsIDE3LCA4LCAxNywgNiwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNF1dLFxuICAgIFwiNlwiOiBbMjAsIFsxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCAxMCwgMjEsIDcsIDIwLCA1LCAxNywgNCwgMTIsIDQsIDcsIDUsIDMsIDcsIDEsIDEwLCAwLCAxMSwgMCwgMTQsIDEsIDE2LCAzLCAxNywgNiwgMTcsIDcsIDE2LCAxMCwgMTQsIDEyLCAxMSwgMTMsIDEwLCAxMywgNywgMTIsIDUsIDEwLCA0LCA3XV0sXG4gICAgXCI3XCI6IFsyMCwgWzE3LCAyMSwgNywgMCwgLTEsIC0xLCAzLCAyMSwgMTcsIDIxXV0sXG4gICAgXCI4XCI6IFsyMCwgWzgsIDIxLCA1LCAyMCwgNCwgMTgsIDQsIDE2LCA1LCAxNCwgNywgMTMsIDExLCAxMiwgMTQsIDExLCAxNiwgOSwgMTcsIDcsIDE3LCA0LCAxNiwgMiwgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA3LCA0LCA5LCA2LCAxMSwgOSwgMTIsIDEzLCAxMywgMTUsIDE0LCAxNiwgMTYsIDE2LCAxOCwgMTUsIDIwLCAxMiwgMjEsIDgsIDIxXV0sXG4gICAgXCI5XCI6IFsyMCwgWzE2LCAxNCwgMTUsIDExLCAxMywgOSwgMTAsIDgsIDksIDgsIDYsIDksIDQsIDExLCAzLCAxNCwgMywgMTUsIDQsIDE4LCA2LCAyMCwgOSwgMjEsIDEwLCAyMSwgMTMsIDIwLCAxNSwgMTgsIDE2LCAxNCwgMTYsIDksIDE1LCA0LCAxMywgMSwgMTAsIDAsIDgsIDAsIDUsIDEsIDQsIDNdXSxcbiAgICBcIjpcIjogWzEwLCBbNSwgMTQsIDQsIDEzLCA1LCAxMiwgNiwgMTMsIDUsIDE0LCAtMSwgLTEsIDUsIDIsIDQsIDEsIDUsIDAsIDYsIDEsIDUsIDJdXSxcbiAgICBcIjtcIjogWzEwLCBbNSwgMTQsIDQsIDEzLCA1LCAxMiwgNiwgMTMsIDUsIDE0LCAtMSwgLTEsIDYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcbiAgICBcIjxcIjogWzI0LCBbMjAsIDE4LCA0LCA5LCAyMCwgMF1dLFxuICAgIFwiPVwiOiBbMjYsIFs0LCAxMiwgMjIsIDEyLCAtMSwgLTEsIDQsIDYsIDIyLCA2XV0sXG4gICAgXCI+XCI6IFsyNCwgWzQsIDE4LCAyMCwgOSwgNCwgMF1dLFxuICAgIFwiP1wiOiBbMTgsIFszLCAxNiwgMywgMTcsIDQsIDE5LCA1LCAyMCwgNywgMjEsIDExLCAyMSwgMTMsIDIwLCAxNCwgMTksIDE1LCAxNywgMTUsIDE1LCAxNCwgMTMsIDEzLCAxMiwgOSwgMTAsIDksIDcsIC0xLCAtMSwgOSwgMiwgOCwgMSwgOSwgMCwgMTAsIDEsIDksIDJdXSxcbiAgICBcIkBcIjogWzI3LCBbMTgsIDEzLCAxNywgMTUsIDE1LCAxNiwgMTIsIDE2LCAxMCwgMTUsIDksIDE0LCA4LCAxMSwgOCwgOCwgOSwgNiwgMTEsIDUsIDE0LCA1LCAxNiwgNiwgMTcsIDgsIC0xLCAtMSwgMTIsIDE2LCAxMCwgMTQsIDksIDExLCA5LCA4LCAxMCwgNiwgMTEsIDUsIC0xLCAtMSwgMTgsIDE2LCAxNywgOCwgMTcsIDYsIDE5LCA1LCAyMSwgNSwgMjMsIDcsIDI0LCAxMCwgMjQsIDEyLCAyMywgMTUsIDIyLCAxNywgMjAsIDE5LCAxOCwgMjAsIDE1LCAyMSwgMTIsIDIxLCA5LCAyMCwgNywgMTksIDUsIDE3LCA0LCAxNSwgMywgMTIsIDMsIDksIDQsIDYsIDUsIDQsIDcsIDIsIDksIDEsIDEyLCAwLCAxNSwgMCwgMTgsIDEsIDIwLCAyLCAyMSwgMywgLTEsIC0xLCAxOSwgMTYsIDE4LCA4LCAxOCwgNiwgMTksIDVdXSxcbiAgICBcIkFcIjogWzE4LCBbOSwgMjEsIDEsIDAsIC0xLCAtMSwgOSwgMjEsIDE3LCAwLCAtMSwgLTEsIDQsIDcsIDE0LCA3XV0sXG4gICAgXCJCXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNSwgMTcsIDEzLCAxNiwgMTIsIDEzLCAxMSwgLTEsIC0xLCA0LCAxMSwgMTMsIDExLCAxNiwgMTAsIDE3LCA5LCAxOCwgNywgMTgsIDQsIDE3LCAyLCAxNiwgMSwgMTMsIDAsIDQsIDBdXSxcbiAgICBcIkNcIjogWzIxLCBbMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1XV0sXG4gICAgXCJEXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMSwgMjEsIDE0LCAyMCwgMTYsIDE4LCAxNywgMTYsIDE4LCAxMywgMTgsIDgsIDE3LCA1LCAxNiwgMywgMTQsIDEsIDExLCAwLCA0LCAwXV0sXG4gICAgXCJFXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxNywgMjEsIC0xLCAtMSwgNCwgMTEsIDEyLCAxMSwgLTEsIC0xLCA0LCAwLCAxNywgMF1dLFxuICAgIFwiRlwiOiBbMTgsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTcsIDIxLCAtMSwgLTEsIDQsIDExLCAxMiwgMTFdXSxcbiAgICBcIkdcIjogWzIxLCBbMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1LCAxOCwgOCwgLTEsIC0xLCAxMywgOCwgMTgsIDhdXSxcbiAgICBcIkhcIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTgsIDIxLCAxOCwgMCwgLTEsIC0xLCA0LCAxMSwgMTgsIDExXV0sXG4gICAgXCJJXCI6IFs4LCBbNCwgMjEsIDQsIDBdXSxcbiAgICBcIkpcIjogWzE2LCBbMTIsIDIxLCAxMiwgNSwgMTEsIDIsIDEwLCAxLCA4LCAwLCA2LCAwLCA0LCAxLCAzLCAyLCAyLCA1LCAyLCA3XV0sXG4gICAgXCJLXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgNCwgNywgLTEsIC0xLCA5LCAxMiwgMTgsIDBdXSxcbiAgICBcIkxcIjogWzE3LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMCwgMTYsIDBdXSxcbiAgICBcIk1cIjogWzI0LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMTIsIDAsIC0xLCAtMSwgMjAsIDIxLCAyMCwgMF1dLFxuICAgIFwiTlwiOiBbMjIsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTgsIDAsIC0xLCAtMSwgMTgsIDIxLCAxOCwgMF1dLFxuICAgIFwiT1wiOiBbMjIsIFs5LCAyMSwgNywgMjAsIDUsIDE4LCA0LCAxNiwgMywgMTMsIDMsIDgsIDQsIDUsIDUsIDMsIDcsIDEsIDksIDAsIDEzLCAwLCAxNSwgMSwgMTcsIDMsIDE4LCA1LCAxOSwgOCwgMTksIDEzLCAxOCwgMTYsIDE3LCAxOCwgMTUsIDIwLCAxMywgMjEsIDksIDIxXV0sXG4gICAgXCJQXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNCwgMTcsIDEyLCAxNiwgMTEsIDEzLCAxMCwgNCwgMTBdXSxcbiAgICBcIlFcIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMSwgLTEsIC0xLCAxMiwgNCwgMTgsIC0yXV0sXG4gICAgXCJSXCI6IFsyMSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMywgMjEsIDE2LCAyMCwgMTcsIDE5LCAxOCwgMTcsIDE4LCAxNSwgMTcsIDEzLCAxNiwgMTIsIDEzLCAxMSwgNCwgMTEsIC0xLCAtMSwgMTEsIDExLCAxOCwgMF1dLFxuICAgIFwiU1wiOiBbMjAsIFsxNywgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMSwgNSwgMjAsIDMsIDE4LCAzLCAxNiwgNCwgMTQsIDUsIDEzLCA3LCAxMiwgMTMsIDEwLCAxNSwgOSwgMTYsIDgsIDE3LCA2LCAxNywgMywgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCAzLCAzXV0sXG4gICAgXCJUXCI6IFsxNiwgWzgsIDIxLCA4LCAwLCAtMSwgLTEsIDEsIDIxLCAxNSwgMjFdXSxcbiAgICBcIlVcIjogWzIyLCBbNCwgMjEsIDQsIDYsIDUsIDMsIDcsIDEsIDEwLCAwLCAxMiwgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNiwgMTgsIDIxXV0sXG4gICAgXCJWXCI6IFsxOCwgWzEsIDIxLCA5LCAwLCAtMSwgLTEsIDE3LCAyMSwgOSwgMF1dLFxuICAgIFwiV1wiOiBbMjQsIFsyLCAyMSwgNywgMCwgLTEsIC0xLCAxMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCAxNywgMCwgLTEsIC0xLCAyMiwgMjEsIDE3LCAwXV0sXG4gICAgXCJYXCI6IFsyMCwgWzMsIDIxLCAxNywgMCwgLTEsIC0xLCAxNywgMjEsIDMsIDBdXSxcbiAgICBcIllcIjogWzE4LCBbMSwgMjEsIDksIDExLCA5LCAwLCAtMSwgLTEsIDE3LCAyMSwgOSwgMTFdXSxcbiAgICBcIlpcIjogWzIwLCBbMTcsIDIxLCAzLCAwLCAtMSwgLTEsIDMsIDIxLCAxNywgMjEsIC0xLCAtMSwgMywgMCwgMTcsIDBdXSxcbiAgICBcIltcIjogWzE0LCBbNCwgMjUsIDQsIC03LCAtMSwgLTEsIDUsIDI1LCA1LCAtNywgLTEsIC0xLCA0LCAyNSwgMTEsIDI1LCAtMSwgLTEsIDQsIC03LCAxMSwgLTddXSxcbiAgICBcIlxcXFxcIjogWzE0LCBbMCwgMjEsIDE0LCAtM11dLFxuICAgIFwiXVwiOiBbMTQsIFs5LCAyNSwgOSwgLTcsIC0xLCAtMSwgMTAsIDI1LCAxMCwgLTcsIC0xLCAtMSwgMywgMjUsIDEwLCAyNSwgLTEsIC0xLCAzLCAtNywgMTAsIC03XV0sXG4gICAgXCJeXCI6IFsxNiwgWzYsIDE1LCA4LCAxOCwgMTAsIDE1LCAtMSwgLTEsIDMsIDEyLCA4LCAxNywgMTMsIDEyLCAtMSwgLTEsIDgsIDE3LCA4LCAwXV0sXG4gICAgXCJfXCI6IFsxNiwgWzAsIC0yLCAxNiwgLTJdXSxcbiAgICBcImBcIjogWzEwLCBbNiwgMjEsIDUsIDIwLCA0LCAxOCwgNCwgMTYsIDUsIDE1LCA2LCAxNiwgNSwgMTddXSxcbiAgICBcImFcIjogWzE5LCBbMTUsIDE0LCAxNSwgMCwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJiXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDExLCA2LCAxMywgOCwgMTQsIDExLCAxNCwgMTMsIDEzLCAxNSwgMTEsIDE2LCA4LCAxNiwgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgOCwgMCwgNiwgMSwgNCwgM11dLFxuICAgIFwiY1wiOiBbMTgsIFsxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJkXCI6IFsxOSwgWzE1LCAyMSwgMTUsIDAsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZVwiOiBbMTgsIFszLCA4LCAxNSwgOCwgMTUsIDEwLCAxNCwgMTIsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJmXCI6IFsxMiwgWzEwLCAyMSwgOCwgMjEsIDYsIDIwLCA1LCAxNywgNSwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcbiAgICBcImdcIjogWzE5LCBbMTUsIDE0LCAxNSwgLTIsIDE0LCAtNSwgMTMsIC02LCAxMSwgLTcsIDgsIC03LCA2LCAtNiwgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJoXCI6IFsxOSwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXG4gICAgXCJpXCI6IFs4LCBbMywgMjEsIDQsIDIwLCA1LCAyMSwgNCwgMjIsIDMsIDIxLCAtMSwgLTEsIDQsIDE0LCA0LCAwXV0sXG4gICAgXCJqXCI6IFsxMCwgWzUsIDIxLCA2LCAyMCwgNywgMjEsIDYsIDIyLCA1LCAyMSwgLTEsIC0xLCA2LCAxNCwgNiwgLTMsIDUsIC02LCAzLCAtNywgMSwgLTddXSxcbiAgICBcImtcIjogWzE3LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgMTQsIDE0LCA0LCA0LCAtMSwgLTEsIDgsIDgsIDE1LCAwXV0sXG4gICAgXCJsXCI6IFs4LCBbNCwgMjEsIDQsIDBdXSxcbiAgICBcIm1cIjogWzMwLCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDAsIC0xLCAtMSwgMTUsIDEwLCAxOCwgMTMsIDIwLCAxNCwgMjMsIDE0LCAyNSwgMTMsIDI2LCAxMCwgMjYsIDBdXSxcbiAgICBcIm5cIjogWzE5LCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgMTAsIDcsIDEzLCA5LCAxNCwgMTIsIDE0LCAxNCwgMTMsIDE1LCAxMCwgMTUsIDBdXSxcbiAgICBcIm9cIjogWzE5LCBbOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgMywgMTYsIDYsIDE2LCA4LCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNF1dLFxuICAgIFwicFwiOiBbMTksIFs0LCAxNCwgNCwgLTcsIC0xLCAtMSwgNCwgMTEsIDYsIDEzLCA4LCAxNCwgMTEsIDE0LCAxMywgMTMsIDE1LCAxMSwgMTYsIDgsIDE2LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA4LCAwLCA2LCAxLCA0LCAzXV0sXG4gICAgXCJxXCI6IFsxOSwgWzE1LCAxNCwgMTUsIC03LCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcInJcIjogWzEzLCBbNCwgMTQsIDQsIDAsIC0xLCAtMSwgNCwgOCwgNSwgMTEsIDcsIDEzLCA5LCAxNCwgMTIsIDE0XV0sXG4gICAgXCJzXCI6IFsxNywgWzE0LCAxMSwgMTMsIDEzLCAxMCwgMTQsIDcsIDE0LCA0LCAxMywgMywgMTEsIDQsIDksIDYsIDgsIDExLCA3LCAxMywgNiwgMTQsIDQsIDE0LCAzLCAxMywgMSwgMTAsIDAsIDcsIDAsIDQsIDEsIDMsIDNdXSxcbiAgICBcInRcIjogWzEyLCBbNSwgMjEsIDUsIDQsIDYsIDEsIDgsIDAsIDEwLCAwLCAtMSwgLTEsIDIsIDE0LCA5LCAxNF1dLFxuICAgIFwidVwiOiBbMTksIFs0LCAxNCwgNCwgNCwgNSwgMSwgNywgMCwgMTAsIDAsIDEyLCAxLCAxNSwgNCwgLTEsIC0xLCAxNSwgMTQsIDE1LCAwXV0sXG4gICAgXCJ2XCI6IFsxNiwgWzIsIDE0LCA4LCAwLCAtMSwgLTEsIDE0LCAxNCwgOCwgMF1dLFxuICAgIFwid1wiOiBbMjIsIFszLCAxNCwgNywgMCwgLTEsIC0xLCAxMSwgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCAxNSwgMCwgLTEsIC0xLCAxOSwgMTQsIDE1LCAwXV0sXG4gICAgXCJ4XCI6IFsxNywgWzMsIDE0LCAxNCwgMCwgLTEsIC0xLCAxNCwgMTQsIDMsIDBdXSxcbiAgICBcInlcIjogWzE2LCBbMiwgMTQsIDgsIDAsIC0xLCAtMSwgMTQsIDE0LCA4LCAwLCA2LCAtNCwgNCwgLTYsIDIsIC03LCAxLCAtN11dLFxuICAgIFwielwiOiBbMTcsIFsxNCwgMTQsIDMsIDAsIC0xLCAtMSwgMywgMTQsIDE0LCAxNCwgLTEsIC0xLCAzLCAwLCAxNCwgMF1dLFxuICAgIFwie1wiOiBbMTQsIFs5LCAyNSwgNywgMjQsIDYsIDIzLCA1LCAyMSwgNSwgMTksIDYsIDE3LCA3LCAxNiwgOCwgMTQsIDgsIDEyLCA2LCAxMCwgLTEsIC0xLCA3LCAyNCwgNiwgMjIsIDYsIDIwLCA3LCAxOCwgOCwgMTcsIDksIDE1LCA5LCAxMywgOCwgMTEsIDQsIDksIDgsIDcsIDksIDUsIDksIDMsIDgsIDEsIDcsIDAsIDYsIC0yLCA2LCAtNCwgNywgLTYsIC0xLCAtMSwgNiwgOCwgOCwgNiwgOCwgNCwgNywgMiwgNiwgMSwgNSwgLTEsIDUsIC0zLCA2LCAtNSwgNywgLTYsIDksIC03XV0sXG4gICAgXCJ8XCI6IFs4LCBbNCwgMjUsIDQsIC03XV0sXG4gICAgXCJ9XCI6IFsxNCwgWzUsIDI1LCA3LCAyNCwgOCwgMjMsIDksIDIxLCA5LCAxOSwgOCwgMTcsIDcsIDE2LCA2LCAxNCwgNiwgMTIsIDgsIDEwLCAtMSwgLTEsIDcsIDI0LCA4LCAyMiwgOCwgMjAsIDcsIDE4LCA2LCAxNywgNSwgMTUsIDUsIDEzLCA2LCAxMSwgMTAsIDksIDYsIDcsIDUsIDUsIDUsIDMsIDYsIDEsIDcsIDAsIDgsIC0yLCA4LCAtNCwgNywgLTYsIC0xLCAtMSwgOCwgOCwgNiwgNiwgNiwgNCwgNywgMiwgOCwgMSwgOSwgLTEsIDksIC0zLCA4LCAtNSwgNywgLTYsIDUsIC03XV0sXG4gICAgXCJ+XCI6IFsyNCwgWzMsIDYsIDMsIDgsIDQsIDExLCA2LCAxMiwgOCwgMTIsIDEwLCAxMSwgMTQsIDgsIDE2LCA3LCAxOCwgNywgMjAsIDgsIDIxLCAxMCwgLTEsIC0xLCAzLCA4LCA0LCAxMCwgNiwgMTEsIDgsIDExLCAxMCwgMTAsIDE0LCA3LCAxNiwgNiwgMTgsIDYsIDIwLCA3LCAyMSwgMTAsIDIxLCAxMl1dXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleHRWZXJ0aWNlcyh0ZXh0LCBsZWZ0LCBiYXNlbGluZSwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDE7XG5cbiAgICB2YXIgc3Ryb2tlcyA9IFtdLFxuICAgICAgICBpLCBsZW4sIGosIGxlbjIsIGdseXBoLCB4LCB5LCBwcmV2O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBnbHlwaCA9IHNpbXBsZXhGb250W3RleHRbaV1dO1xuICAgICAgICBpZiAoIWdseXBoKSBjb250aW51ZTtcbiAgICAgICAgcHJldiA9IG51bGw7XG5cbiAgICAgICAgZm9yIChqID0gMCwgbGVuMiA9IGdseXBoWzFdLmxlbmd0aDsgaiA8IGxlbjI7IGogKz0gMikge1xuICAgICAgICAgICAgaWYgKGdseXBoWzFdW2pdID09PSAtMSAmJiBnbHlwaFsxXVtqICsgMV0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG51bGw7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IGxlZnQgKyBnbHlwaFsxXVtqXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHkgPSBiYXNlbGluZSAtIGdseXBoWzFdW2ogKyAxXSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZXMucHVzaChwcmV2LngsIHByZXYueSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSB7eDogeCwgeTogeX07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGVmdCArPSBnbHlwaFswXSAqIHNjYWxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJva2VzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBtYXBib3hnbCBpcyBhIEEgV2ViR0wgSmF2YVNjcmlwdCBpbnRlcmFjdGl2ZSBtYXBzIGxpYnJhcnkgdGhhdCBjYW4gcmVuZGVyXG4gKiBbTWFwYm94IHZlY3RvciB0aWxlc10oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9ibG9nL3ZlY3Rvci10aWxlcy8pLlxuICpcbiAqIEBtb2R1bGUgbWFwYm94Z2xcbiAqIEBzdW1tYXJ5IFdlYkdMIEphdmFTY3JpcHQgbWFwIGxpYnJhcnlcbiAqL1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmV3IChyZXF1aXJlKCcuL3NvdXJjZS93b3JrZXInKSkoc2VsZik7IC8qZXNsaW50IG5vLW5ldzogMCovXG59IGVsc2Uge1xuICAgIC8vIGpzaGludCAtVzA3OVxuICAgIHZhciBtYXBib3hnbCA9IG1vZHVsZS5leHBvcnRzID0gd2luZG93Lm1hcGJveGdsID0ge307XG5cbiAgICBtYXBib3hnbC5NYXAgPSByZXF1aXJlKCcuL3VpL21hcCcpO1xuICAgIG1hcGJveGdsLk5hdmlnYXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvbmF2aWdhdGlvbicpO1xuICAgIG1hcGJveGdsLkF0dHJpYnV0aW9uID0gcmVxdWlyZSgnLi91aS9jb250cm9sL2F0dHJpYnV0aW9uJyk7XG4gICAgbWFwYm94Z2wuUG9wdXAgPSByZXF1aXJlKCcuL3VpL3BvcHVwJyk7XG5cbiAgICBtYXBib3hnbC5HZW9KU09OU291cmNlID0gcmVxdWlyZSgnLi9zb3VyY2UvZ2VvanNvbl9zb3VyY2UnKTtcbiAgICBtYXBib3hnbC5WaWRlb1NvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlL3ZpZGVvX3NvdXJjZScpO1xuXG4gICAgbWFwYm94Z2wuU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlL3N0eWxlJyk7XG5cbiAgICBtYXBib3hnbC5MYXRMbmcgPSByZXF1aXJlKCcuL2dlby9sYXRfbG5nJyk7XG4gICAgbWFwYm94Z2wuTGF0TG5nQm91bmRzID0gcmVxdWlyZSgnLi9nZW8vbGF0X2xuZ19ib3VuZHMnKTtcbiAgICBtYXBib3hnbC5Qb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbiAgICBtYXBib3hnbC5FdmVudGVkID0gcmVxdWlyZSgnLi91dGlsL2V2ZW50ZWQnKTtcbiAgICBtYXBib3hnbC51dGlsID0gcmVxdWlyZSgnLi91dGlsL3V0aWwnKTtcblxuICAgIG1hcGJveGdsLnN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vdXRpbC9icm93c2VyJykuc3VwcG9ydGVkO1xuXG4gICAgdmFyIGFqYXggPSByZXF1aXJlKCcuL3V0aWwvYWpheCcpO1xuICAgIG1hcGJveGdsLnV0aWwuZ2V0SlNPTiA9IGFqYXguZ2V0SlNPTjtcbiAgICBtYXBib3hnbC51dGlsLmdldEFycmF5QnVmZmVyID0gYWpheC5nZXRBcnJheUJ1ZmZlcjtcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL3V0aWwvY29uZmlnJyk7XG4gICAgbWFwYm94Z2wuY29uZmlnID0gY29uZmlnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcGJveGdsLCAnYWNjZXNzVG9rZW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBjb25maWcuQUNDRVNTX1RPS0VOOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRva2VuKSB7IGNvbmZpZy5BQ0NFU1NfVE9LRU4gPSB0b2tlbjsgfVxuICAgIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0MyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDM7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0JhY2tncm91bmQ7XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBjb2xvciA9IGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLWNvbG9yJ107XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2JhY2tncm91bmQtaW1hZ2UnXTtcbiAgICB2YXIgb3BhY2l0eSA9IGxheWVyLnBhaW50WydiYWNrZ3JvdW5kLW9wYWNpdHknXTtcbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgdmFyIGltYWdlUG9zQSA9IGltYWdlID8gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKSA6IG51bGw7XG4gICAgdmFyIGltYWdlUG9zQiA9IGltYWdlID8gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSkgOiBudWxsO1xuXG4gICAgaWYgKGltYWdlUG9zQSAmJiBpbWFnZVBvc0IpIHtcbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5wYXR0ZXJuU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWkoc2hhZGVyLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYSwgaW1hZ2VQb3NBLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2EsIGltYWdlUG9zQS5icik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl90bF9iLCBpbWFnZVBvc0IudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fYnJfYiwgaW1hZ2VQb3NCLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHksIG9wYWNpdHkpO1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBwYWludGVyLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHNpemVBID0gaW1hZ2VQb3NBLnNpemU7XG4gICAgICAgIHZhciBzaXplQiA9IGltYWdlUG9zQi5zaXplO1xuICAgICAgICB2YXIgY2VudGVyID0gdHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZSh0cmFuc2Zvcm0uY2VudGVyKTtcbiAgICAgICAgdmFyIHNjYWxlID0gMSAvIE1hdGgucG93KDIsIHRyYW5zZm9ybS56b29tRnJhY3Rpb24pO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIHZhciBtYXRyaXhBID0gbWF0My5jcmVhdGUoKTtcbiAgICAgICAgbWF0My5zY2FsZShtYXRyaXhBLCBtYXRyaXhBLCBbXG4gICAgICAgICAgICAxIC8gKHNpemVBWzBdICogaW1hZ2UuZnJvbVNjYWxlKSxcbiAgICAgICAgICAgIDEgLyAoc2l6ZUFbMV0gKiBpbWFnZS5mcm9tU2NhbGUpXG4gICAgICAgIF0pO1xuICAgICAgICBtYXQzLnRyYW5zbGF0ZShtYXRyaXhBLCBtYXRyaXhBLCBbXG4gICAgICAgICAgICAoY2VudGVyLmNvbHVtbiAqIHRyYW5zZm9ybS50aWxlU2l6ZSkgJSAoc2l6ZUFbMF0gKiBpbWFnZS5mcm9tU2NhbGUpLFxuICAgICAgICAgICAgKGNlbnRlci5yb3cgICAgKiB0cmFuc2Zvcm0udGlsZVNpemUpICUgKHNpemVBWzFdICogaW1hZ2UuZnJvbVNjYWxlKVxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My5yb3RhdGUobWF0cml4QSwgbWF0cml4QSwgLXRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4QSwgbWF0cml4QSwgW1xuICAgICAgICAgICAgc2NhbGUgKiB0cmFuc2Zvcm0ud2lkdGggIC8gMixcbiAgICAgICAgICAgLXNjYWxlICogdHJhbnNmb3JtLmhlaWdodCAvIDJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIG1hdHJpeEIgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeEIsIG1hdHJpeEIsIFtcbiAgICAgICAgICAgIDEgLyAoc2l6ZUJbMF0gKiBpbWFnZS50b1NjYWxlKSxcbiAgICAgICAgICAgIDEgLyAoc2l6ZUJbMV0gKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My50cmFuc2xhdGUobWF0cml4QiwgbWF0cml4QiwgW1xuICAgICAgICAgICAgKGNlbnRlci5jb2x1bW4gKiB0cmFuc2Zvcm0udGlsZVNpemUpICUgKHNpemVCWzBdICogaW1hZ2UudG9TY2FsZSksXG4gICAgICAgICAgICAoY2VudGVyLnJvdyAgICAqIHRyYW5zZm9ybS50aWxlU2l6ZSkgJSAoc2l6ZUJbMV0gKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICBdKTtcbiAgICAgICAgbWF0My5yb3RhdGUobWF0cml4QiwgbWF0cml4QiwgLXRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIG1hdDMuc2NhbGUobWF0cml4QiwgbWF0cml4QiwgW1xuICAgICAgICAgICAgc2NhbGUgKiB0cmFuc2Zvcm0ud2lkdGggIC8gMixcbiAgICAgICAgICAgLXNjYWxlICogdHJhbnNmb3JtLmhlaWdodCAvIDJcbiAgICAgICAgXSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4X2EsIGZhbHNlLCBtYXRyaXhBKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihzaGFkZXIudV9wYXR0ZXJubWF0cml4X2IsIGZhbHNlLCBtYXRyaXhCKTtcblxuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBmaWxsaW5nIHJlY3RhbmdsZS5cbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5maWxsU2hhZGVyO1xuICAgICAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1Db3VudCk7XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1BsYWNlbWVudERlYnVnO1xuXG5mdW5jdGlvbiBkcmF3UGxhY2VtZW50RGVidWcocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSkge1xuXG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXS5jb2xsaXNpb25Cb3g7XG4gICAgaWYgKCFlbGVtZW50R3JvdXBzKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBidWZmZXIgPSB0aWxlLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuICAgIHZhciBzaGFkZXIgPSBwYWludGVyLmNvbGxpc2lvbkJveFNoYWRlcjtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcbiAgICBidWZmZXIuYmluZChnbCwgc2hhZGVyKTtcbiAgICBnbC5saW5lV2lkdGgoMyk7XG5cbiAgICB2YXIgc3RyaWRlID0gMTI7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXIuYV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2V4dHJ1ZGUsIDIsIGdsLlNIT1JULCBmYWxzZSwgc3RyaWRlLCA0KTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2RhdGEsIDIsIGdsLlVOU0lHTkVEX0JZVEUsIGZhbHNlLCBzdHJpZGUsIDgpO1xuXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NjYWxlLCBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gdGlsZS56b29tKSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3pvb20sIHBhaW50ZXIudHJhbnNmb3JtLnpvb20gKiAxMCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21heHpvb20sICh0aWxlLnpvb20gKyAxKSAqIDEwKTtcblxuICAgIHZhciBiZWdpbiA9IGVsZW1lbnRHcm91cHMuZ3JvdXBzWzBdLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgdmFyIGxlbiA9IGVsZW1lbnRHcm91cHMuZ3JvdXBzWzBdLnZlcnRleExlbmd0aDtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCBiZWdpbiwgbGVuKTtcblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRleHRWZXJ0aWNlcyA9IHJlcXVpcmUoJy4uL2xpYi9kZWJ1Z3RleHQnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi4vc291cmNlL3RpbGVfY29vcmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3RGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdEZWJ1ZyhwYWludGVyLCB0aWxlKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRCh0aWxlLmlkKTtcblxuICAgIC8vIEJsZW5kIHRvIHRoZSBmcm9udCwgbm90IHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIuZGVidWdTaGFkZXIsIHRpbGUucG9zTWF0cml4KTtcblxuICAgIC8vIGRyYXcgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBhaW50ZXIuZGVidWdCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5kZWJ1Z1NoYWRlci5hX3BvcywgcGFpbnRlci5kZWJ1Z0J1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC51bmlmb3JtNGYocGFpbnRlci5kZWJ1Z1NoYWRlci51X2NvbG9yLCAxLCAwLCAwLCAxKTtcbiAgICBnbC5saW5lV2lkdGgoNCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX1NUUklQLCAwLCBwYWludGVyLmRlYnVnQnVmZmVyLml0ZW1Db3VudCk7XG5cbiAgICAvLyBkcmF3IHRpbGUgY29vcmRpbmF0ZVxuICAgIHZhciBjb29yZCA9IHBvcy56ICsgJy8nICsgcG9zLnggKyAnLycgKyBwb3MueTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRleHRWZXJ0aWNlcyhjb29yZCwgNTAsIDIwMCwgNSk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcGFpbnRlci5kZWJ1Z1RleHRCdWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgSW50MTZBcnJheSh2ZXJ0aWNlcyksIGdsLlNUUkVBTV9EUkFXKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZGVidWdTaGFkZXIuYV9wb3MsIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplLCBnbC5TSE9SVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmxpbmVXaWR0aCg4ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICBnbC51bmlmb3JtNGYocGFpbnRlci5kZWJ1Z1NoYWRlci51X2NvbG9yLCAxLCAxLCAxLCAxKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCAwLCB2ZXJ0aWNlcy5sZW5ndGggLyBwYWludGVyLmRlYnVnVGV4dEJ1ZmZlci5pdGVtU2l6ZSk7XG4gICAgZ2wubGluZVdpZHRoKDIgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIGdsLnVuaWZvcm00ZihwYWludGVyLmRlYnVnU2hhZGVyLnVfY29sb3IsIDAsIDAsIDAsIDEpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAvIHBhaW50ZXIuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplKTtcblxuICAgIC8vIFJldmVydCBibGVuZGluZyBtb2RlIHRvIGJsZW5kIHRvIHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG1hdDMgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdGaWxsO1xuXG5mdW5jdGlvbiBkcmF3RmlsbChwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG4gICAgLy8gTm8gZGF0YVxuICAgIGlmICghdGlsZS5idWZmZXJzKSByZXR1cm47XG4gICAgdmFyIGVsZW1lbnRHcm91cHMgPSB0aWxlLmVsZW1lbnRHcm91cHNbbGF5ZXIucmVmIHx8IGxheWVyLmlkXTtcbiAgICBpZiAoIWVsZW1lbnRHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgdmFyIHRyYW5zbGF0ZWRQb3NNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHRpbGUsIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZSddLCBsYXllci5wYWludFsnZmlsbC10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgdmFyIGNvbG9yID0gbGF5ZXIucGFpbnRbJ2ZpbGwtY29sb3InXTtcblxuICAgIHZhciB2ZXJ0ZXgsIGVsZW1lbnRzLCBncm91cCwgY291bnQ7XG5cbiAgICAvLyBEcmF3IHRoZSBzdGVuY2lsIG1hc2suXG5cbiAgICAvLyBXZSdyZSBvbmx5IGRyYXdpbmcgdG8gdGhlIGZpcnN0IHNldmVuIGJpdHMgKD09IHN1cHBvcnQgYSBtYXhpbXVtIG9mXG4gICAgLy8gMTI3IG92ZXJsYXBwaW5nIHBvbHlnb25zIGluIG9uZSBwbGFjZSBiZWZvcmUgd2UgZ2V0IHJlbmRlcmluZyBlcnJvcnMpLlxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4M0YpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG5cbiAgICAvLyBEcmF3IGZyb250IGZhY2luZyB0cmlhbmdsZXMuIFdoZXJldmVyIHRoZSAweDgwIGJpdCBpcyAxLCB3ZSBhcmVcbiAgICAvLyBpbmNyZWFzaW5nIHRoZSBsb3dlciA3IGJpdHMgYnkgb25lIGlmIHRoZSB0cmlhbmdsZSBpcyBhIGZyb250LWZhY2luZ1xuICAgIC8vIHRyaWFuZ2xlLiBUaGlzIG1lYW5zIHRoYXQgYWxsIHZpc2libGUgcG9seWdvbnMgc2hvdWxkIGJlIGluIENDV1xuICAgIC8vIG9yaWVudGF0aW9uLCB3aGlsZSBhbGwgaG9sZXMgKHNlZSBiZWxvdykgYXJlIGluIENXIG9yaWVudGF0aW9uLlxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLk5PVEVRVUFMLCAweDgwLCAweDgwKTtcblxuICAgIC8vIFdoZW4gd2UgZG8gYSBub256ZXJvIGZpbGwsIHdlIGNvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgYSBwaXhlbCBpc1xuICAgIC8vIGNvdmVyZWQgYnkgYSBjb3VudGVyY2xvY2t3aXNlIHBvbHlnb24sIGFuZCBzdWJ0cmFjdCB0aGUgbnVtYmVyIG9mXG4gICAgLy8gdGltZXMgaXQgaXMgXCJ1bmNvdmVyZWRcIiBieSBhIGNsb2Nrd2lzZSBwb2x5Z29uLlxuICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKGdsLkZST05ULCBnbC5JTkNSX1dSQVAsIGdsLktFRVAsIGdsLktFRVApO1xuICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKGdsLkJBQ0ssIGdsLkRFQ1JfV1JBUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG5cbiAgICAvLyBXaGVuIGRyYXdpbmcgYSBzaGFwZSwgd2UgZmlyc3QgZHJhdyBhbGwgc2hhcGVzIHRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgIC8vIGFuZCBpbmNyZW1lbnRpbmcgYWxsIGFyZWFzIHdoZXJlIHBvbHlnb25zIGFyZVxuICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAvLyBEcmF3IHRoZSBhY3R1YWwgdHJpYW5nbGUgZmFuIGludG8gdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmZpbGxTaGFkZXIsIHRyYW5zbGF0ZWRQb3NNYXRyaXgpO1xuXG4gICAgLy8gRHJhdyBhbGwgYnVmZmVyc1xuICAgIHZlcnRleCA9IHRpbGUuYnVmZmVycy5maWxsVmVydGV4O1xuICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICBlbGVtZW50cyA9IHRpbGUuYnVmZmVycy5maWxsRWxlbWVudDtcbiAgICBlbGVtZW50cy5iaW5kKGdsKTtcblxuICAgIHZhciBvZmZzZXQsIGVsZW1lbnRPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZWxlbWVudEdyb3Vwcy5ncm91cHNbaV07XG4gICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocGFpbnRlci5maWxsU2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDQsIG9mZnNldCArIDApO1xuXG4gICAgICAgIGNvdW50ID0gZ3JvdXAuZWxlbWVudExlbmd0aCAqIDM7XG4gICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIHN0ZW5jaWwgbWFzayBpbiB0aGUgc3RlbmNpbCBidWZmZXIsIHdlIGNhbiBzdGFydFxuICAgIC8vIHdyaXRpbmcgdG8gdGhlIGNvbG9yIGJ1ZmZlci5cbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAvLyBGcm9tIG5vdyBvbiwgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgdGhlIHN0ZW5jaWwgYnVmZmVyIGFueW1vcmUuXG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLktFRVApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MCk7XG5cbiAgICB2YXIgc3Ryb2tlQ29sb3IgPSBsYXllci5wYWludFsnZmlsbC1vdXRsaW5lLWNvbG9yJ107XG5cbiAgICAvLyBCZWNhdXNlIHdlJ3JlIGRyYXdpbmcgdG9wLXRvLWJvdHRvbSwgYW5kIHdlIHVwZGF0ZSB0aGUgc3RlbmNpbCBtYXNrXG4gICAgLy8gYmVsb3csIHdlIGhhdmUgdG8gZHJhdyB0aGUgb3V0bGluZSBmaXJzdCAoISlcbiAgICBpZiAobGF5ZXIucGFpbnRbJ2ZpbGwtYW50aWFsaWFzJ10gPT09IHRydWUgJiYgIShsYXllci5wYWludFsnZmlsbC1pbWFnZSddICYmICFzdHJva2VDb2xvcikpIHtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHBhaW50ZXIub3V0bGluZVNoYWRlciwgdHJhbnNsYXRlZFBvc01hdHJpeCk7XG4gICAgICAgIGdsLmxpbmVXaWR0aCgyICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICBpZiAoc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRlZmluZWQgYSBkaWZmZXJlbnQgY29sb3IgZm9yIHRoZSBmaWxsIG91dGxpbmUsIHdlIGFyZVxuICAgICAgICAgICAgLy8gZ29pbmcgdG8gaWdub3JlIHRoZSBiaXRzIGluIDB4M0YgYW5kIGp1c3QgY2FyZSBhYm91dCB0aGUgZ2xvYmFsXG4gICAgICAgICAgICAvLyBjbGlwcGluZyBtYXNrLlxuICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDB4ODAsIDB4ODApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBvbmx5IHdhbnQgdG8gZHJhdyB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcbiAgICAgICAgICAgIC8vICpvdXRzaWRlKiB0aGUgY3VycmVudCBzaGFwZS4gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgZmlsbFxuICAgICAgICAgICAgLy8gb3Igc3Ryb2tlIGNvbG9yIGlzIHRyYW5zbHVjZW50LiBJZiB3ZSB3b3VsZG4ndCBjbGlwIHRvIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXG4gICAgICAgICAgICAvLyB0aGUgKG5vbi1hbnRpYWxpYXNlZCkgZmlsbC5cbiAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweEJGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVuaWZvcm0yZihwYWludGVyLm91dGxpbmVTaGFkZXIudV93b3JsZCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwYWludGVyLm91dGxpbmVTaGFkZXIudV9jb2xvciwgc3Ryb2tlQ29sb3IgPyBzdHJva2VDb2xvciA6IGNvbG9yKTtcblxuICAgICAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgICAgIHZlcnRleCA9IHRpbGUuYnVmZmVycy5maWxsVmVydGV4O1xuICAgICAgICBlbGVtZW50cyA9IHRpbGUuYnVmZmVycy5vdXRsaW5lRWxlbWVudDtcbiAgICAgICAgZWxlbWVudHMuYmluZChnbCk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1trXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIub3V0bGluZVNoYWRlci5hX3BvcywgMiwgZ2wuU0hPUlQsIGZhbHNlLCA0LCBvZmZzZXQgKyAwKTtcblxuICAgICAgICAgICAgY291bnQgPSBncm91cC5zZWNvbmRFbGVtZW50TGVuZ3RoICogMjtcbiAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5zZWNvbmRFbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLkxJTkVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2ZpbGwtaW1hZ2UnXTtcbiAgICB2YXIgb3BhY2l0eSA9IGxheWVyLnBhaW50WydmaWxsLW9wYWNpdHknXSB8fCAxO1xuICAgIHZhciBzaGFkZXI7XG5cbiAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgLy8gRHJhdyB0ZXh0dXJlIGZpbGxcbiAgICAgICAgdmFyIGltYWdlUG9zQSA9IHBhaW50ZXIuc3ByaXRlQXRsYXMuZ2V0UG9zaXRpb24oaW1hZ2UuZnJvbSwgdHJ1ZSk7XG4gICAgICAgIHZhciBpbWFnZVBvc0IgPSBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLnRvLCB0cnVlKTtcbiAgICAgICAgaWYgKCFpbWFnZVBvc0EgfHwgIWltYWdlUG9zQikgcmV0dXJuO1xuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIucGF0dGVyblNoYWRlcjtcbiAgICAgICAgZ2wuc3dpdGNoU2hhZGVyKHNoYWRlciwgcG9zTWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHNoYWRlci51X2ltYWdlLCAwKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2EsIGltYWdlUG9zQS50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9hLCBpbWFnZVBvc0EuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYiwgaW1hZ2VQb3NCLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2IsIGltYWdlUG9zQi5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9vcGFjaXR5LCBvcGFjaXR5KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21peCwgaW1hZ2UudCk7XG5cbiAgICAgICAgdmFyIGZhY3RvciA9ICg0MDk2IC8gdGlsZS50aWxlU2l6ZSkgLyBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIHRpbGUuem9vbSk7XG5cbiAgICAgICAgdmFyIG1hdHJpeEEgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeEEsIG1hdHJpeEEsIFtcbiAgICAgICAgICAgIDEgLyAoaW1hZ2VQb3NBLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS5mcm9tU2NhbGUpLFxuICAgICAgICAgICAgMSAvIChpbWFnZVBvc0Euc2l6ZVsxXSAqIGZhY3RvciAqIGltYWdlLmZyb21TY2FsZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmFyIG1hdHJpeEIgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLnNjYWxlKG1hdHJpeEIsIG1hdHJpeEIsIFtcbiAgICAgICAgICAgIDEgLyAoaW1hZ2VQb3NCLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS50b1NjYWxlKSxcbiAgICAgICAgICAgIDEgLyAoaW1hZ2VQb3NCLnNpemVbMV0gKiBmYWN0b3IgKiBpbWFnZS50b1NjYWxlKVxuICAgICAgICBdKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51X3BhdHRlcm5tYXRyaXhfYSwgZmFsc2UsIG1hdHJpeEEpO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHNoYWRlci51X3BhdHRlcm5tYXRyaXhfYiwgZmFsc2UsIG1hdHJpeEIpO1xuXG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGZpbGxpbmcgcmVjdGFuZ2xlLlxuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmZpbGxTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGNvbG9yKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGRyYXcgcmVnaW9ucyB0aGF0IHdlIG1hcmtlZFxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLk5PVEVRVUFMLCAweDAsIDB4M0YpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgcGFpbnRlci50aWxlRXh0ZW50QnVmZmVyLml0ZW1Db3VudCk7XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0MiA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZHJhd0xpbmUocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSkge1xuICAgIC8vIE5vIGRhdGFcbiAgICBpZiAoIXRpbGUuYnVmZmVycykgcmV0dXJuO1xuICAgIHZhciBlbGVtZW50R3JvdXBzID0gdGlsZS5lbGVtZW50R3JvdXBzW2xheWVyLnJlZiB8fCBsYXllci5pZF07XG4gICAgaWYgKCFlbGVtZW50R3JvdXBzKSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgLy8gZG9uJ3QgZHJhdyB6ZXJvLXdpZHRoIGxpbmVzXG4gICAgaWYgKGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ10gPD0gMCkgcmV0dXJuO1xuXG4gICAgLy8gdGhlIGRpc3RhbmNlIG92ZXIgd2hpY2ggdGhlIGxpbmUgZWRnZSBmYWRlcyBvdXQuXG4gICAgLy8gUmV0aW5hIGRldmljZXMgbmVlZCBhIHNtYWxsZXIgZGlzdGFuY2UgdG8gYXZvaWQgYWxpYXNpbmcuXG4gICAgdmFyIGFudGlhbGlhc2luZyA9IDEgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgYmx1ciA9IGxheWVyLnBhaW50WydsaW5lLWJsdXInXSArIGFudGlhbGlhc2luZztcbiAgICB2YXIgZWRnZVdpZHRoID0gbGF5ZXIucGFpbnRbJ2xpbmUtd2lkdGgnXSAvIDI7XG4gICAgdmFyIGluc2V0ID0gLTE7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgIGlmIChsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSA+IDApIHtcbiAgICAgICAgaW5zZXQgPSBsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSAvIDIgKyBhbnRpYWxpYXNpbmcgKiAwLjU7XG4gICAgICAgIGVkZ2VXaWR0aCA9IGxheWVyLnBhaW50WydsaW5lLXdpZHRoJ107XG5cbiAgICAgICAgLy8gc2hpZnQgb3V0ZXIgbGluZXMgaGFsZiBhIHBpeGVsIHRvd2FyZHMgdGhlIG1pZGRsZSB0byBlbGltaW5hdGUgdGhlIGNyYWNrXG4gICAgICAgIG9mZnNldCA9IGluc2V0IC0gYW50aWFsaWFzaW5nIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgb3V0c2V0ID0gb2Zmc2V0ICsgZWRnZVdpZHRoICsgYW50aWFsaWFzaW5nIC8gMiArIHNoaWZ0O1xuXG4gICAgdmFyIGNvbG9yID0gbGF5ZXIucGFpbnRbJ2xpbmUtY29sb3InXTtcbiAgICB2YXIgcmF0aW8gPSBwYWludGVyLnRyYW5zZm9ybS5zY2FsZSAvICgxIDw8IHRpbGUuem9vbSkgLyAoNDA5NiAvIHRpbGUudGlsZVNpemUpO1xuICAgIHZhciB2dHhNYXRyaXggPSBwYWludGVyLnRyYW5zbGF0ZU1hdHJpeChwb3NNYXRyaXgsIHRpbGUsIGxheWVyLnBhaW50WydsaW5lLXRyYW5zbGF0ZSddLCBsYXllci5wYWludFsnbGluZS10cmFuc2xhdGUtYW5jaG9yJ10pO1xuXG4gICAgdmFyIHRyID0gcGFpbnRlci50cmFuc2Zvcm07XG5cblxuICAgIHZhciBhbnRpYWxpYXNpbmdNYXRyaXggPSBtYXQyLmNyZWF0ZSgpO1xuICAgIG1hdDIuc2NhbGUoYW50aWFsaWFzaW5nTWF0cml4LCBhbnRpYWxpYXNpbmdNYXRyaXgsIFsxLCBNYXRoLmNvcyh0ci5fcGl0Y2gpXSk7XG4gICAgbWF0Mi5yb3RhdGUoYW50aWFsaWFzaW5nTWF0cml4LCBhbnRpYWxpYXNpbmdNYXRyaXgsIHBhaW50ZXIudHJhbnNmb3JtLmFuZ2xlKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCBsb25nZXIgdGhlIHJlYWwgd29ybGQgZGlzdGFuY2UgaXMgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuXG4gICAgLy8gdGhhbiBhdCB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gICAgdmFyIHRvcGVkZ2VsZW5ndGggPSBNYXRoLnNxcnQodHIuaGVpZ2h0ICogdHIuaGVpZ2h0IC8gNCAgKiAoMSArIHRyLmFsdGl0dWRlICogdHIuYWx0aXR1ZGUpKTtcbiAgICB2YXIgeCA9IHRyLmhlaWdodCAvIDIgKiBNYXRoLnRhbih0ci5fcGl0Y2gpO1xuICAgIHZhciBleHRyYSA9ICh0b3BlZGdlbGVuZ3RoICsgeCkgLyB0b3BlZGdlbGVuZ3RoIC0gMTtcblxuICAgIHZhciBzaGFkZXI7XG5cblxuICAgIHZhciBkYXNoYXJyYXkgPSBsYXllci5wYWludFsnbGluZS1kYXNoYXJyYXknXTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnbGluZS1pbWFnZSddO1xuXG4gICAgaWYgKGRhc2hhcnJheSkge1xuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIubGluZXNkZnBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHZ0eE1hdHJpeCwgdGlsZS5leE1hdHJpeCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgY29sb3IpO1xuXG4gICAgICAgIHZhciBwb3NBID0gcGFpbnRlci5saW5lQXRsYXMuZ2V0RGFzaChkYXNoYXJyYXkuZnJvbSwgbGF5ZXIubGF5b3V0WydsaW5lLWNhcCddID09PSAncm91bmQnKTtcbiAgICAgICAgdmFyIHBvc0IgPSBwYWludGVyLmxpbmVBdGxhcy5nZXREYXNoKGRhc2hhcnJheS50bywgbGF5ZXIubGF5b3V0WydsaW5lLWNhcCddID09PSAncm91bmQnKTtcbiAgICAgICAgcGFpbnRlci5saW5lQXRsYXMuYmluZChnbCk7XG5cbiAgICAgICAgdmFyIHBhdHRlcm5yYXRpbyA9IE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2cocGFpbnRlci50cmFuc2Zvcm0uc2NhbGUpIC8gTWF0aC5MTjIpIC0gdGlsZS56b29tKSAvIDg7XG4gICAgICAgIHZhciBzY2FsZUEgPSBbcGF0dGVybnJhdGlvIC8gcG9zQS53aWR0aCAvIGRhc2hhcnJheS5mcm9tU2NhbGUsIC1wb3NBLmhlaWdodCAvIDJdO1xuICAgICAgICB2YXIgZ2FtbWFBID0gcGFpbnRlci5saW5lQXRsYXMud2lkdGggLyAoZGFzaGFycmF5LmZyb21TY2FsZSAqIHBvc0Eud2lkdGggKiAyNTYgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pIC8gMjtcbiAgICAgICAgdmFyIHNjYWxlQiA9IFtwYXR0ZXJucmF0aW8gLyBwb3NCLndpZHRoIC8gZGFzaGFycmF5LnRvU2NhbGUsIC1wb3NCLmhlaWdodCAvIDJdO1xuICAgICAgICB2YXIgZ2FtbWFCID0gcGFpbnRlci5saW5lQXRsYXMud2lkdGggLyAoZGFzaGFycmF5LnRvU2NhbGUgKiBwb3NCLndpZHRoICogMjU2ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSAvIDI7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuc2NhbGVfYSwgc2NhbGVBKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3RleF95X2EsIHBvc0EueSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybnNjYWxlX2IsIHNjYWxlQik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV90ZXhfeV9iLCBwb3NCLnkpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zZGZnYW1tYSwgTWF0aC5tYXgoZ2FtbWFBLCBnYW1tYUIpKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21peCwgZGFzaGFycmF5LnQpO1xuXG4gICAgfSBlbHNlIGlmIChpbWFnZSkge1xuICAgICAgICB2YXIgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICAgICAgdmFyIGltYWdlUG9zQiA9IHBhaW50ZXIuc3ByaXRlQXRsYXMuZ2V0UG9zaXRpb24oaW1hZ2UudG8sIHRydWUpO1xuICAgICAgICBpZiAoIWltYWdlUG9zQSB8fCAhaW1hZ2VQb3NCKSByZXR1cm47XG4gICAgICAgIHZhciBmYWN0b3IgPSA0MDk2IC8gdGlsZS50aWxlU2l6ZSAvIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gdGlsZS56b29tKTtcblxuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xuXG4gICAgICAgIHNoYWRlciA9IHBhaW50ZXIubGluZXBhdHRlcm5TaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHZ0eE1hdHJpeCwgdGlsZS5leE1hdHJpeCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcblxuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fc2l6ZV9hLCBbaW1hZ2VQb3NBLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS5mcm9tU2NhbGUsIGltYWdlUG9zQi5zaXplWzFdIF0pO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fc2l6ZV9iLCBbaW1hZ2VQb3NCLnNpemVbMF0gKiBmYWN0b3IgKiBpbWFnZS50b1NjYWxlLCBpbWFnZVBvc0Iuc2l6ZVsxXSBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX3RsX2EsIGltYWdlUG9zQS50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYoc2hhZGVyLnVfcGF0dGVybl9icl9hLCBpbWFnZVBvc0EuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3BhdHRlcm5fdGxfYiwgaW1hZ2VQb3NCLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9wYXR0ZXJuX2JyX2IsIGltYWdlUG9zQi5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9mYWRlLCBpbWFnZS50KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHksIGxheWVyLnBhaW50WydsaW5lLW9wYWNpdHknXSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFkZXIgPSBwYWludGVyLmxpbmVTaGFkZXI7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHZ0eE1hdHJpeCwgdGlsZS5leE1hdHJpeCk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV9saW5ld2lkdGgsIFsgb3V0c2V0LCBpbnNldCBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3JhdGlvLCByYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoc2hhZGVyLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcblxuICAgICAgICBnbC51bmlmb3JtNGZ2KHNoYWRlci51X2NvbG9yLCBjb2xvcik7XG4gICAgfVxuXG4gICAgdmFyIHZlcnRleCA9IHRpbGUuYnVmZmVycy5saW5lVmVydGV4O1xuICAgIHZlcnRleC5iaW5kKGdsKTtcbiAgICB2YXIgZWxlbWVudCA9IHRpbGUuYnVmZmVycy5saW5lRWxlbWVudDtcbiAgICBlbGVtZW50LmJpbmQoZ2wpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1tpXTtcbiAgICAgICAgdmFyIHZ0eE9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIHZ0eE9mZnNldCArIDApO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX2RhdGEsIDQsIGdsLkJZVEUsIGZhbHNlLCA4LCB2dHhPZmZzZXQgKyA0KTtcblxuICAgICAgICB2YXIgY291bnQgPSBncm91cC5lbGVtZW50TGVuZ3RoICogMztcbiAgICAgICAgdmFyIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnQuaXRlbVNpemU7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi4vc291cmNlL3RpbGVfY29vcmQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1Jhc3RlcjtcblxuZnVuY3Rpb24gZHJhd1Jhc3RlcihwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIHZhciBzaGFkZXIgPSBwYWludGVyLnJhc3RlclNoYWRlcjtcbiAgICBnbC5zd2l0Y2hTaGFkZXIoc2hhZGVyLCBwb3NNYXRyaXgpO1xuXG4gICAgLy8gY29sb3IgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9icmlnaHRuZXNzX2xvdywgbGF5ZXIucGFpbnRbJ3Jhc3Rlci1icmlnaHRuZXNzLW1pbiddKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnJpZ2h0bmVzc19oaWdoLCBsYXllci5wYWludFsncmFzdGVyLWJyaWdodG5lc3MtbWF4J10pO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllci5wYWludFsncmFzdGVyLXNhdHVyYXRpb24nXSkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9jb250cmFzdF9mYWN0b3IsIGNvbnRyYXN0RmFjdG9yKGxheWVyLnBhaW50WydyYXN0ZXItY29udHJhc3QnXSkpO1xuICAgIGdsLnVuaWZvcm0zZnYoc2hhZGVyLnVfc3Bpbl93ZWlnaHRzLCBzcGluV2VpZ2h0cyhsYXllci5wYWludFsncmFzdGVyLWh1ZS1yb3RhdGUnXSkpO1xuXG4gICAgdmFyIHBhcmVudFRpbGUgPSB0aWxlLnNvdXJjZSAmJiB0aWxlLnNvdXJjZS5fcHlyYW1pZC5maW5kTG9hZGVkUGFyZW50KHRpbGUuaWQsIDAsIHt9KSxcbiAgICAgICAgb3BhY2l0aWVzID0gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUsIGxheWVyLCBwYWludGVyLnRyYW5zZm9ybSk7XG5cbiAgICB2YXIgcGFyZW50U2NhbGVCeSwgcGFyZW50VEw7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuXG4gICAgaWYgKHBhcmVudFRpbGUpIHtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHBhcmVudFRpbGUudGV4dHVyZSk7XG5cbiAgICAgICAgdmFyIHRpbGVQb3MgPSBUaWxlQ29vcmQuZnJvbUlEKHRpbGUuaWQpO1xuICAgICAgICB2YXIgcGFyZW50UG9zID0gcGFyZW50VGlsZSAmJiBUaWxlQ29vcmQuZnJvbUlEKHBhcmVudFRpbGUuaWQpO1xuICAgICAgICBwYXJlbnRTY2FsZUJ5ID0gTWF0aC5wb3coMiwgcGFyZW50UG9zLnogLSB0aWxlUG9zLnopO1xuICAgICAgICBwYXJlbnRUTCA9IFt0aWxlUG9zLnggKiBwYXJlbnRTY2FsZUJ5ICUgMSwgdGlsZVBvcy55ICogcGFyZW50U2NhbGVCeSAlIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wYWNpdGllc1sxXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3Jvc3MtZmFkZSBwYXJhbWV0ZXJzXG4gICAgZ2wudW5pZm9ybTJmdihzaGFkZXIudV90bF9wYXJlbnQsIHBhcmVudFRMIHx8IFswLCAwXSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X3NjYWxlX3BhcmVudCwgcGFyZW50U2NhbGVCeSB8fCAxKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfYnVmZmVyX3NjYWxlLCAxKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eTAsIG9wYWNpdGllc1swXSk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X29wYWNpdHkxLCBvcGFjaXRpZXNbMV0pO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTAsIDApO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9pbWFnZTEsIDEpO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRpbGUuYm91bmRzQnVmZmVyIHx8IHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG5cbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlci5hX3BvcywgICAgICAgICAyLCBnbC5TSE9SVCwgZmFsc2UsIDgsIDApO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyLmFfdGV4dHVyZV9wb3MsIDIsIGdsLlNIT1JULCBmYWxzZSwgOCwgNCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbn1cblxuZnVuY3Rpb24gc3BpbldlaWdodHMoYW5nbGUpIHtcbiAgICBhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgICgyICogYyArIDEpIC8gMyxcbiAgICAgICAgKC1NYXRoLnNxcnQoMykgKiBzIC0gYyArIDEpIC8gMyxcbiAgICAgICAgKE1hdGguc3FydCgzKSAqIHMgLSBjICsgMSkgLyAzXG4gICAgXTtcbn1cblxuZnVuY3Rpb24gY29udHJhc3RGYWN0b3IoY29udHJhc3QpIHtcbiAgICByZXR1cm4gY29udHJhc3QgPiAwID9cbiAgICAgICAgMSAvICgxIC0gY29udHJhc3QpIDpcbiAgICAgICAgMSArIGNvbnRyYXN0O1xufVxuXG5mdW5jdGlvbiBzYXR1cmF0aW9uRmFjdG9yKHNhdHVyYXRpb24pIHtcbiAgICByZXR1cm4gc2F0dXJhdGlvbiA+IDAgP1xuICAgICAgICAxIC0gMSAvICgxLjAwMSAtIHNhdHVyYXRpb24pIDpcbiAgICAgICAgLXNhdHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGdldE9wYWNpdGllcyh0aWxlLCBwYXJlbnRUaWxlLCBsYXllciwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKCF0aWxlLnNvdXJjZSkgcmV0dXJuIFsxLCAwXTtcblxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIHZhciBmYWRlRHVyYXRpb24gPSBsYXllci5wYWludFsncmFzdGVyLWZhZGUtZHVyYXRpb24nXTtcbiAgICB2YXIgc2luY2VUaWxlID0gKG5vdyAtIHRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbjtcbiAgICB2YXIgc2luY2VQYXJlbnQgPSBwYXJlbnRUaWxlID8gKG5vdyAtIHBhcmVudFRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbiA6IC0xO1xuXG4gICAgdmFyIHRpbGVQb3MgPSBUaWxlQ29vcmQuZnJvbUlEKHRpbGUuaWQpO1xuICAgIHZhciBwYXJlbnRQb3MgPSBwYXJlbnRUaWxlICYmIFRpbGVDb29yZC5mcm9tSUQocGFyZW50VGlsZS5pZCk7XG5cbiAgICB2YXIgaWRlYWxaID0gdGlsZS5zb3VyY2UuX3B5cmFtaWQuY292ZXJpbmdab29tTGV2ZWwodHJhbnNmb3JtKTtcbiAgICB2YXIgcGFyZW50RnVydGhlciA9IHBhcmVudFRpbGUgPyBNYXRoLmFicyhwYXJlbnRQb3MueiAtIGlkZWFsWikgPiBNYXRoLmFicyh0aWxlUG9zLnogLSBpZGVhbFopIDogZmFsc2U7XG5cbiAgICB2YXIgb3BhY2l0eSA9IFtdO1xuICAgIGlmICghcGFyZW50VGlsZSB8fCBwYXJlbnRGdXJ0aGVyKSB7XG4gICAgICAgIC8vIGlmIG5vIHBhcmVudCBvciBwYXJlbnQgaXMgb2xkZXJcbiAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoc2luY2VUaWxlLCAwLCAxKTtcbiAgICAgICAgb3BhY2l0eVsxXSA9IDEgLSBvcGFjaXR5WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyB5b3VuZ2VyLCB6b29taW5nIG91dFxuICAgICAgICBvcGFjaXR5WzBdID0gdXRpbC5jbGFtcCgxIC0gc2luY2VQYXJlbnQsIDAsIDEpO1xuICAgICAgICBvcGFjaXR5WzFdID0gMSAtIG9wYWNpdHlbMF07XG4gICAgfVxuXG4gICAgdmFyIG9wID0gbGF5ZXIucGFpbnRbJ3Jhc3Rlci1vcGFjaXR5J107XG4gICAgb3BhY2l0eVswXSAqPSBvcDtcbiAgICBvcGFjaXR5WzFdICo9IG9wO1xuXG4gICAgcmV0dXJuIG9wYWNpdHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG5cbnZhciBkcmF3Q29sbGlzaW9uRGVidWcgPSByZXF1aXJlKCcuL2RyYXdfY29sbGlzaW9uX2RlYnVnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1N5bWJvbHM7XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2xzKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUpIHtcbiAgICAvLyBObyBkYXRhXG4gICAgaWYgKCF0aWxlLmJ1ZmZlcnMpIHJldHVybjtcbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRpbGUuZWxlbWVudEdyb3Vwc1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgIGlmICghZWxlbWVudEdyb3VwcykgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgaWYgKGVsZW1lbnRHcm91cHMudGV4dC5ncm91cHMubGVuZ3RoKSB7XG4gICAgICAgIGRyYXdTeW1ib2wocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSwgZWxlbWVudEdyb3Vwcy50ZXh0LCAndGV4dCcsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudEdyb3Vwcy5pY29uLmdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgZHJhd1N5bWJvbChwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlLCBlbGVtZW50R3JvdXBzLmljb24sICdpY29uJywgZWxlbWVudEdyb3Vwcy5zZGZJY29ucyk7XG4gICAgfVxuXG4gICAgZHJhd0NvbGxpc2lvbkRlYnVnKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUpO1xuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xufVxuXG52YXIgZGVmYXVsdFNpemVzID0ge1xuICAgIGljb246IDEsXG4gICAgdGV4dDogMjRcbn07XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2wocGFpbnRlciwgbGF5ZXIsIHBvc01hdHJpeCwgdGlsZSwgZWxlbWVudEdyb3VwcywgcHJlZml4LCBzZGYpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgcG9zTWF0cml4ID0gcGFpbnRlci50cmFuc2xhdGVNYXRyaXgocG9zTWF0cml4LCB0aWxlLCBsYXllci5wYWludFtwcmVmaXggKyAnLXRyYW5zbGF0ZSddLCBsYXllci5wYWludFtwcmVmaXggKyAnLXRyYW5zbGF0ZS1hbmNob3InXSk7XG5cbiAgICB2YXIgdHIgPSBwYWludGVyLnRyYW5zZm9ybTtcbiAgICB2YXIgYWxpZ25lZFdpdGhNYXAgPSBsYXllci5sYXlvdXRbcHJlZml4ICsgJy1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCc7XG4gICAgdmFyIHNrZXdlZCA9IGFsaWduZWRXaXRoTWFwO1xuICAgIHZhciBleE1hdHJpeCwgcywgZ2FtbWFTY2FsZTtcblxuICAgIGlmIChza2V3ZWQpIHtcbiAgICAgICAgZXhNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBzID0gNDA5NiAvIHRpbGUudGlsZVNpemUgLyBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gdGlsZS56b29tKTtcbiAgICAgICAgZ2FtbWFTY2FsZSA9IDEgLyBNYXRoLmNvcyh0ci5fcGl0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4TWF0cml4ID0gbWF0NC5jbG9uZSh0aWxlLmV4TWF0cml4KTtcbiAgICAgICAgcyA9IHBhaW50ZXIudHJhbnNmb3JtLmFsdGl0dWRlO1xuICAgICAgICBnYW1tYVNjYWxlID0gMTtcbiAgICB9XG4gICAgbWF0NC5zY2FsZShleE1hdHJpeCwgZXhNYXRyaXgsIFtzLCBzLCAxXSk7XG5cbiAgICAvLyBJZiBsYXllci5wYWludC5zaXplID4gbGF5ZXIubGF5b3V0W3ByZWZpeCArICctbWF4LXNpemUnXSB0aGVuIGxhYmVscyBtYXkgY29sbGlkZVxuICAgIHZhciBmb250U2l6ZSA9IGxheWVyLnBhaW50W3ByZWZpeCArICctc2l6ZSddIHx8IGxheWVyLmxheW91dFtwcmVmaXggKyAnLW1heC1zaXplJ107XG4gICAgdmFyIGZvbnRTY2FsZSA9IGZvbnRTaXplIC8gZGVmYXVsdFNpemVzW3ByZWZpeF07XG4gICAgbWF0NC5zY2FsZShleE1hdHJpeCwgZXhNYXRyaXgsIFsgZm9udFNjYWxlLCBmb250U2NhbGUsIDEgXSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggbG9uZ2VyIHRoZSByZWFsIHdvcmxkIGRpc3RhbmNlIGlzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcmVlblxuICAgIC8vIHRoYW4gYXQgdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLlxuICAgIHZhciB0b3BlZGdlbGVuZ3RoID0gTWF0aC5zcXJ0KHRyLmhlaWdodCAqIHRyLmhlaWdodCAvIDQgICogKDEgKyB0ci5hbHRpdHVkZSAqIHRyLmFsdGl0dWRlKSk7XG4gICAgdmFyIHggPSB0ci5oZWlnaHQgLyAyICogTWF0aC50YW4odHIuX3BpdGNoKTtcbiAgICB2YXIgZXh0cmEgPSAodG9wZWRnZWxlbmd0aCArIHgpIC8gdG9wZWRnZWxlbmd0aCAtIDE7XG5cbiAgICB2YXIgdGV4dCA9IHByZWZpeCA9PT0gJ3RleHQnO1xuICAgIHZhciBzaGFkZXIsIHZlcnRleCwgZWxlbWVudHMsIHRleHNpemU7XG5cbiAgICBpZiAoIXRleHQgJiYgIXBhaW50ZXIuc3R5bGUuc3ByaXRlLmxvYWRlZCgpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgIGlmIChzZGYpIHtcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5zZGZTaGFkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2hhZGVyID0gcGFpbnRlci5pY29uU2hhZGVyO1xuICAgIH1cblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHBhaW50ZXIuZ2x5cGhBdGxhcy51cGRhdGVUZXh0dXJlKGdsKTtcbiAgICAgICAgdmVydGV4ID0gdGlsZS5idWZmZXJzLmdseXBoVmVydGV4O1xuICAgICAgICBlbGVtZW50cyA9IHRpbGUuYnVmZmVycy5nbHlwaEVsZW1lbnQ7XG4gICAgICAgIHRleHNpemUgPSBbcGFpbnRlci5nbHlwaEF0bGFzLndpZHRoIC8gNCwgcGFpbnRlci5nbHlwaEF0bGFzLmhlaWdodCAvIDRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgYWxpZ25lZFdpdGhNYXAgfHwgcGFpbnRlci5vcHRpb25zLnJvdGF0aW5nIHx8XG4gICAgICAgICAgICBwYWludGVyLm9wdGlvbnMuem9vbWluZyB8fCBmb250U2NhbGUgIT09IDEgfHwgc2RmIHx8IHBhaW50ZXIudHJhbnNmb3JtLnBpdGNoKTtcbiAgICAgICAgdmVydGV4ID0gdGlsZS5idWZmZXJzLmljb25WZXJ0ZXg7XG4gICAgICAgIGVsZW1lbnRzID0gdGlsZS5idWZmZXJzLmljb25FbGVtZW50O1xuICAgICAgICB0ZXhzaXplID0gW3BhaW50ZXIuc3ByaXRlQXRsYXMud2lkdGggLyA0LCBwYWludGVyLnNwcml0ZUF0bGFzLmhlaWdodCAvIDRdO1xuICAgIH1cblxuICAgIGdsLnN3aXRjaFNoYWRlcihzaGFkZXIsIHBvc01hdHJpeCwgZXhNYXRyaXgpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV90ZXh0dXJlLCAwKTtcbiAgICBnbC51bmlmb3JtMmZ2KHNoYWRlci51X3RleHNpemUsIHRleHNpemUpO1xuICAgIGdsLnVuaWZvcm0xaShzaGFkZXIudV9za2V3ZWQsIHNrZXdlZCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2V4dHJhLCBleHRyYSk7XG5cbiAgICAvLyBhZGp1c3QgbWluL21heCB6b29tcyBmb3IgdmFyaWFibGUgZm9udCBzaWVzXG4gICAgdmFyIHpvb21BZGp1c3QgPSBNYXRoLmxvZyhmb250U2l6ZSAvIGxheWVyLmxheW91dFtwcmVmaXggKyAnLW1heC1zaXplJ10pIC8gTWF0aC5MTjIgfHwgMDtcblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV96b29tLCAocGFpbnRlci50cmFuc2Zvcm0uem9vbSAtIHpvb21BZGp1c3QpICogMTApOyAvLyBjdXJyZW50IHpvb20gbGV2ZWxcblxuICAgIHZhciBmID0gcGFpbnRlci5mcmFtZUhpc3RvcnkuZ2V0RmFkZVByb3BlcnRpZXMoMzAwKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmFkZWRpc3QsIGYuZmFkZWRpc3QgKiAxMCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X21pbmZhZGV6b29tLCBNYXRoLmZsb29yKGYubWluZmFkZXpvb20gKiAxMCkpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9tYXhmYWRlem9vbSwgTWF0aC5mbG9vcihmLm1heGZhZGV6b29tICogMTApKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfZmFkZXpvb20sIChwYWludGVyLnRyYW5zZm9ybS56b29tICsgZi5idW1wKSAqIDEwKTtcblxuICAgIHZhciBncm91cCwgb2Zmc2V0LCBjb3VudCwgZWxlbWVudE9mZnNldDtcblxuICAgIGVsZW1lbnRzLmJpbmQoZ2wpO1xuXG4gICAgaWYgKHNkZikge1xuICAgICAgICB2YXIgc2RmUHggPSA4O1xuICAgICAgICB2YXIgYmx1ck9mZnNldCA9IDEuMTk7XG4gICAgICAgIHZhciBoYWxvT2Zmc2V0ID0gNjtcbiAgICAgICAgdmFyIGdhbW1hID0gMC4xMDUgKiBkZWZhdWx0U2l6ZXNbcHJlZml4XSAvIGZvbnRTaXplIC8gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9nYW1tYSwgZ2FtbWEgKiBnYW1tYVNjYWxlKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihzaGFkZXIudV9jb2xvciwgbGF5ZXIucGFpbnRbcHJlZml4ICsgJy1jb2xvciddKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHNoYWRlci51X2J1ZmZlciwgKDI1NiAtIDY0KSAvIDI1Nik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1tpXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCwgc2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1jb2xvciddKSB7XG4gICAgICAgICAgICAvLyBEcmF3IGhhbG8gdW5kZXJuZWF0aCB0aGUgdGV4dC5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9nYW1tYSwgKGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1ibHVyJ10gKiBibHVyT2Zmc2V0IC8gZm9udFNjYWxlIC8gc2RmUHggKyBnYW1tYSkgKiBnYW1tYVNjYWxlKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm00ZnYoc2hhZGVyLnVfY29sb3IsIGxheWVyLnBhaW50W3ByZWZpeCArICctaGFsby1jb2xvciddKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudV9idWZmZXIsIChoYWxvT2Zmc2V0IC0gbGF5ZXIucGFpbnRbcHJlZml4ICsgJy1oYWxvLXdpZHRoJ10gLyBmb250U2NhbGUpIC8gc2RmUHgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZW1lbnRHcm91cHMuZ3JvdXBzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1tqXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBncm91cC52ZXJ0ZXhTdGFydEluZGV4ICogdmVydGV4Lml0ZW1TaXplO1xuICAgICAgICAgICAgICAgIHZlcnRleC5iaW5kKGdsLCBzaGFkZXIsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRPZmZzZXQgPSBncm91cC5lbGVtZW50U3RhcnRJbmRleCAqIGVsZW1lbnRzLml0ZW1TaXplO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgZWxlbWVudE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVfb3BhY2l0eSwgbGF5ZXIucGFpbnRbJ2ljb24tb3BhY2l0eSddKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbGVtZW50R3JvdXBzLmdyb3Vwcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZ3JvdXAgPSBlbGVtZW50R3JvdXBzLmdyb3Vwc1trXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXggKiB2ZXJ0ZXguaXRlbVNpemU7XG4gICAgICAgICAgICB2ZXJ0ZXguYmluZChnbCwgc2hhZGVyLCBvZmZzZXQpO1xuXG4gICAgICAgICAgICBjb3VudCA9IGdyb3VwLmVsZW1lbnRMZW5ndGggKiAzO1xuICAgICAgICAgICAgZWxlbWVudE9mZnNldCA9IGdyb3VwLmVsZW1lbnRTdGFydEluZGV4ICogZWxlbWVudHMuaXRlbVNpemU7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBjb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIGVsZW1lbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG1hdDQgPSByZXF1aXJlKCdnbC1tYXRyaXgnKS5tYXQ0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdWZXJ0aWNlcztcblxuZnVuY3Rpb24gZHJhd1ZlcnRpY2VzKHBhaW50ZXIsIGxheWVyLCBwb3NNYXRyaXgsIHRpbGUpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgaWYgKCF0aWxlIHx8ICF0aWxlLmJ1ZmZlcnMpIHJldHVybjtcbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHRpbGUuZWxlbWVudEdyb3Vwc1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgIGlmICghZWxlbWVudEdyb3VwcykgcmV0dXJuO1xuXG4gICAgLy8gQmxlbmQgdG8gdGhlIGZyb250LCBub3QgdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICAvLyBEcmF3IGFsbCBidWZmZXJzXG4gICAgaWYgKGxheWVyLnR5cGUgPT09ICdmaWxsJykge1xuICAgICAgICBkcmF3UG9pbnRzKHRpbGUuYnVmZmVycy5maWxsVmVydGV4LCBlbGVtZW50R3JvdXBzLmdyb3VwcywgcG9zTWF0cml4LCA0KTtcbiAgICB9IGVsc2UgaWYgKGxheWVyLnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGRyYXdQb2ludHModGlsZS5idWZmZXJzLmljb25WZXJ0ZXgsIGVsZW1lbnRHcm91cHMuaWNvbi5ncm91cHMsIHBvc01hdHJpeCwgMTYpO1xuICAgICAgICBkcmF3UG9pbnRzKHRpbGUuYnVmZmVycy5nbHlwaFZlcnRleCwgZWxlbWVudEdyb3Vwcy50ZXh0Lmdyb3VwcywgcG9zTWF0cml4LCAxNik7XG4gICAgfSBlbHNlIGlmIChsYXllci50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgdmFyIG5ld1Bvc01hdHJpeCA9IG1hdDQuY2xvbmUocG9zTWF0cml4KTtcbiAgICAgICAgbWF0NC5zY2FsZShuZXdQb3NNYXRyaXgsIG5ld1Bvc01hdHJpeCwgWzAuNSwgMC41LCAxXSk7XG4gICAgICAgIGRyYXdQb2ludHModGlsZS5idWZmZXJzLmxpbmVWZXJ0ZXgsIGVsZW1lbnRHcm91cHMuZ3JvdXBzLCBuZXdQb3NNYXRyaXgsIDgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdQb2ludHModmVydGV4LCBncm91cHMsIG1hdHJpeCwgc3RyaWRlKSB7XG4gICAgICAgIGdsLnN3aXRjaFNoYWRlcihwYWludGVyLmRvdFNoYWRlciwgbWF0cml4KTtcblxuICAgICAgICBnbC51bmlmb3JtMWYocGFpbnRlci5kb3RTaGFkZXIudV9zaXplLCA0ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHBhaW50ZXIuZG90U2hhZGVyLnVfYmx1ciwgMC4yNSk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYocGFpbnRlci5kb3RTaGFkZXIudV9jb2xvciwgWzAuMSwgMCwgMCwgMC4xXSk7XG5cbiAgICAgICAgdmVydGV4LmJpbmQoZ2wsIHBhaW50ZXIuZG90U2hhZGVyLCAwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIHZhciBiZWdpbiA9IGdyb3VwLnZlcnRleFN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBncm91cC52ZXJ0ZXhMZW5ndGg7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBhaW50ZXIuZG90U2hhZGVyLmFfcG9zLCAyLCBnbC5TSE9SVCwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgYmVnaW4sIGNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldmVydCBibGVuZGluZyBtb2RlIHRvIGJsZW5kIHRvIHRoZSBiYWNrLlxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lSGlzdG9yeTtcblxuZnVuY3Rpb24gRnJhbWVIaXN0b3J5KCkge1xuICAgIHRoaXMuZnJhbWVIaXN0b3J5ID0gW107XG59XG5cbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUuZ2V0RmFkZVByb3BlcnRpZXMgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSBkdXJhdGlvbiA9IDMwMDtcbiAgICB2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUmVtb3ZlIGZyYW1lcyB1bnRpbCBvbmx5IG9uZSBpcyBvdXRzaWRlIHRoZSBkdXJhdGlvbiwgb3IgdW50aWwgdGhlcmUgYXJlIG9ubHkgdGhyZWVcbiAgICB3aGlsZSAodGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoID4gMyAmJiB0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lICsgZHVyYXRpb24gPCBjdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeS5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZyYW1lSGlzdG9yeVsxXS50aW1lICsgZHVyYXRpb24gPCBjdXJyZW50VGltZSkge1xuICAgICAgICB0aGlzLmZyYW1lSGlzdG9yeVswXS56ID0gdGhpcy5mcmFtZUhpc3RvcnlbMV0uejtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVMZW4gPSB0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGg7XG4gICAgaWYgKGZyYW1lTGVuIDwgMykgY29uc29sZS53YXJuKCd0aGVyZSBzaG91bGQgbmV2ZXIgYmUgbGVzcyB0aGFuIHRocmVlIGZyYW1lcyBpbiB0aGUgaGlzdG9yeScpO1xuXG4gICAgLy8gRmluZCB0aGUgcmFuZ2Ugb2Ygem9vbSBsZXZlbHMgd2Ugd2FudCB0byBmYWRlIGJldHdlZW5cbiAgICB2YXIgc3RhcnRpbmdaID0gdGhpcy5mcmFtZUhpc3RvcnlbMF0ueixcbiAgICAgICAgbGFzdEZyYW1lID0gdGhpcy5mcmFtZUhpc3RvcnlbZnJhbWVMZW4gLSAxXSxcbiAgICAgICAgZW5kaW5nWiA9IGxhc3RGcmFtZS56LFxuICAgICAgICBsb3daID0gTWF0aC5taW4oc3RhcnRpbmdaLCBlbmRpbmdaKSxcbiAgICAgICAgaGlnaFogPSBNYXRoLm1heChzdGFydGluZ1osIGVuZGluZ1opO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzcGVlZCBvZiB6b29taW5nLCBhbmQgaG93IGZhciBpdCB3b3VsZCB6b29tIGluIHRlcm1zIG9mIHpvb20gbGV2ZWxzIGluIG9uZSBkdXJhdGlvblxuICAgIHZhciB6b29tRGlmZiA9IGxhc3RGcmFtZS56IC0gdGhpcy5mcmFtZUhpc3RvcnlbMV0ueixcbiAgICAgICAgdGltZURpZmYgPSBsYXN0RnJhbWUudGltZSAtIHRoaXMuZnJhbWVIaXN0b3J5WzFdLnRpbWU7XG4gICAgdmFyIGZhZGVkaXN0ID0gem9vbURpZmYgLyAodGltZURpZmYgLyBkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNOYU4oZmFkZWRpc3QpKSBjb25zb2xlLndhcm4oJ2ZhZGVkaXN0IHNob3VsZCBuZXZlciBiZSBOYU4nKTtcblxuICAgIC8vIEF0IGVuZCBvZiBhIHpvb20gd2hlbiB0aGUgem9vbSBzdG9wcyBjaGFuZ2luZyBjb250aW51ZSBwcmV0ZW5kaW5nIHRvIHpvb20gYXQgdGhhdCBzcGVlZFxuICAgIC8vIGJ1bXAgaXMgaG93IG11Y2ggZmFydGhlciBpdCB3b3VsZCBoYXZlIGJlZW4gaWYgaXQgaGFkIGNvbnRpbnVlZCB6b29taW5nIGF0IHRoZSBzYW1lIHJhdGVcbiAgICB2YXIgYnVtcCA9IChjdXJyZW50VGltZSAtIGxhc3RGcmFtZS50aW1lKSAvIGR1cmF0aW9uICogZmFkZWRpc3Q7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmYWRlZGlzdDogZmFkZWRpc3QsXG4gICAgICAgIG1pbmZhZGV6b29tOiBsb3daLFxuICAgICAgICBtYXhmYWRlem9vbTogaGlnaFosXG4gICAgICAgIGJ1bXA6IGJ1bXBcbiAgICB9O1xufTtcblxuLy8gUmVjb3JkIGZyYW1lIGhpc3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGZhZGluZyBwYXJhbXNcbkZyYW1lSGlzdG9yeS5wcm90b3R5cGUucmVjb3JkID0gZnVuY3Rpb24oem9vbSkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBmaXJzdCBmcmFtZSBldmVyXG4gICAgaWYgKCF0aGlzLmZyYW1lSGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnkucHVzaCh7dGltZTogMCwgejogem9vbSB9LCB7dGltZTogMCwgejogem9vbSB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mcmFtZUhpc3RvcnkubGVuZ3RoID09PSAyIHx8IHRoaXMuZnJhbWVIaXN0b3J5W3RoaXMuZnJhbWVIaXN0b3J5Lmxlbmd0aCAtIDFdLnogIT09IHpvb20pIHtcbiAgICAgICAgdGhpcy5mcmFtZUhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiBjdXJyZW50VGltZSxcbiAgICAgICAgICAgIHo6IHpvb21cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNoYWRlcnMgPSByZXF1aXJlKCcuL3NoYWRlcnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBvcmlnTGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGgsXG4gICAgICAgIGxpbmVXaWR0aFJhbmdlID0gY29udGV4dC5nZXRQYXJhbWV0ZXIoY29udGV4dC5BTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UpO1xuXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICBvcmlnTGluZVdpZHRoLmNhbGwoY29udGV4dCwgdXRpbC5jbGFtcCh3aWR0aCwgbGluZVdpZHRoUmFuZ2VbMF0sIGxpbmVXaWR0aFJhbmdlWzFdKSk7XG4gICAgfTtcblxuICAgIGNvbnRleHQuZ2V0U2hhZGVyID0gZnVuY3Rpb24obmFtZSwgdHlwZSkge1xuICAgICAgICB2YXIga2luZCA9IHR5cGUgPT09IHRoaXMuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnO1xuICAgICAgICBpZiAoIXNoYWRlcnNbbmFtZV0gfHwgIXNoYWRlcnNbbmFtZV1ba2luZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHNoYWRlciBcIiArIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICB0aGlzLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlcnNbbmFtZV1ba2luZF0pO1xuICAgICAgICB0aGlzLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfTtcblxuICAgIGNvbnRleHQuaW5pdGlhbGl6ZVNoYWRlciA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSB7XG4gICAgICAgICAgICBwcm9ncmFtOiB0aGlzLmNyZWF0ZVByb2dyYW0oKSxcbiAgICAgICAgICAgIGZyYWdtZW50OiB0aGlzLmdldFNoYWRlcihuYW1lLCB0aGlzLkZSQUdNRU5UX1NIQURFUiksXG4gICAgICAgICAgICB2ZXJ0ZXg6IHRoaXMuZ2V0U2hhZGVyKG5hbWUsIHRoaXMuVkVSVEVYX1NIQURFUiksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmF0dGFjaFNoYWRlcihzaGFkZXIucHJvZ3JhbSwgc2hhZGVyLnZlcnRleCk7XG4gICAgICAgIHRoaXMuYXR0YWNoU2hhZGVyKHNoYWRlci5wcm9ncmFtLCBzaGFkZXIuZnJhZ21lbnQpO1xuICAgICAgICB0aGlzLmxpbmtQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcblxuICAgICAgICBpZiAoIXRoaXMuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXIucHJvZ3JhbSwgdGhpcy5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5nZXRQcm9ncmFtSW5mb0xvZyhzaGFkZXIucHJvZ3JhbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyW2F0dHJpYnV0ZXNbaV1dID0gdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXIucHJvZ3JhbSwgYXR0cmlidXRlc1tpXSk7XG4gICAgICAgICAgICAgICAgc2hhZGVyLmF0dHJpYnV0ZXMucHVzaChzaGFkZXJbYXR0cmlidXRlc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB1bmlmb3Jtcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHNoYWRlclt1bmlmb3Jtc1trXV0gPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXIucHJvZ3JhbSwgdW5pZm9ybXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9O1xuXG4gICAgLy8gU3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgc2hhZGVyIHByb2dyYW0uXG4gICAgY29udGV4dC5zd2l0Y2hTaGFkZXIgPSBmdW5jdGlvbihzaGFkZXIsIHBvc01hdHJpeCwgZXhNYXRyaXgpIHtcbiAgICAgICAgaWYgKCFwb3NNYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJ3Bvc01hdHJpeCBkb2VzIG5vdCBoYXZlIHJlcXVpcmVkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U2hhZGVyICE9PSBzaGFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG5cbiAgICAgICAgICAgIC8vIERpc2FibGUgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXhpc3Rpbmcgc2hhZGVyIHRoYXQgYXJlbid0IHVzZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc2hhZGVyLiBOb3RlOiBhdHRyaWJ1dGUgaW5kaWNlcyBhcmUgKm5vdCogcHJvZ3JhbSBzcGVjaWZpYyFcbiAgICAgICAgICAgIHZhciBlbmFibGVkID0gdGhpcy5jdXJyZW50U2hhZGVyID8gdGhpcy5jdXJyZW50U2hhZGVyLmF0dHJpYnV0ZXMgOiBbXTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlZCA9IHNoYWRlci5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuYWJsZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWQuaW5kZXhPZihlbmFibGVkW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoZW5hYmxlZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbmFibGUgYWxsIGF0dHJpYnV0ZXMgZm9yIHRoZSBuZXcgc2hhZGVyLlxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXF1aXJlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGVkLmluZGV4T2YocmVxdWlyZWRbal0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHJlcXVpcmVkW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWF0cmljZXMgaWYgbmVjZXNzYXJ5LiBOb3RlOiBUaGlzIHJlbGllcyBvbiBvYmplY3QgaWRlbnRpdHkhXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgY2hhbmdpbmcgdGhlIG1hdHJpeCB2YWx1ZXMgd2l0aG91dCB0aGUgYWN0dWFsIG1hdHJpeCBvYmplY3RcbiAgICAgICAgLy8gd2lsbCBGQUlMIHRvIHVwZGF0ZSB0aGUgbWF0cml4IHByb3Blcmx5LlxuICAgICAgICBpZiAoc2hhZGVyLnBvc01hdHJpeCAhPT0gcG9zTWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1NYXRyaXg0ZnYoc2hhZGVyLnVfbWF0cml4LCBmYWxzZSwgcG9zTWF0cml4KTtcbiAgICAgICAgICAgIHNoYWRlci5wb3NNYXRyaXggPSBwb3NNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4TWF0cml4ICYmIHNoYWRlci5leE1hdHJpeCAhPT0gZXhNYXRyaXggJiYgc2hhZGVyLnVfZXhtYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybU1hdHJpeDRmdihzaGFkZXIudV9leG1hdHJpeCwgZmFsc2UsIGV4TWF0cml4KTtcbiAgICAgICAgICAgIHNoYWRlci5leE1hdHJpeCA9IGV4TWF0cml4O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBjb250ZXh0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQXRsYXM7XG5cbmZ1bmN0aW9uIExpbmVBdGxhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubmV4dFJvdyA9IDA7XG5cbiAgICB0aGlzLmJ5dGVzID0gNDtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiB0aGlzLmJ5dGVzKTtcblxuICAgIHRoaXMucG9zaXRpb25zID0ge307XG59XG5cbkxpbmVBdGxhcy5wcm90b3R5cGUuc2V0U3ByaXRlID0gZnVuY3Rpb24oc3ByaXRlKSB7XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmdldERhc2ggPSBmdW5jdGlvbihkYXNoYXJyYXksIHJvdW5kKSB7XG4gICAgdmFyIGtleSA9IGRhc2hhcnJheS5qb2luKFwiLFwiKSArIHJvdW5kO1xuXG4gICAgaWYgKCF0aGlzLnBvc2l0aW9uc1trZXldKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zW2tleV0gPSB0aGlzLmFkZERhc2goZGFzaGFycmF5LCByb3VuZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1trZXldO1xufTtcblxuTGluZUF0bGFzLnByb3RvdHlwZS5hZGREYXNoID0gZnVuY3Rpb24oZGFzaGFycmF5LCByb3VuZCkge1xuXG4gICAgdmFyIG4gPSByb3VuZCA/IDcgOiAwO1xuICAgIHZhciBoZWlnaHQgPSAyICogbiArIDE7XG4gICAgdmFyIG9mZnNldCA9IDEyODtcblxuICAgIGlmICh0aGlzLm5leHRSb3cgKyBoZWlnaHQgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0xpbmVBdGxhcyBvdXQgb2Ygc3BhY2UnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXNoYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoICs9IGRhc2hhcnJheVtpXTtcbiAgICB9XG5cbiAgICB2YXIgc3RyZXRjaCA9IHRoaXMud2lkdGggLyBsZW5ndGg7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHN0cmV0Y2ggLyAyO1xuXG4gICAgLy8gSWYgZGFzaGFycmF5IGhhcyBhbiBvZGQgbGVuZ3RoLCBib3RoIHRoZSBmaXJzdCBhbmQgbGFzdCBwYXJ0c1xuICAgIC8vIGFyZSBkYXNoZXMgYW5kIHNob3VsZCBiZSBqb2luZWQgc2VhbWxlc3NseS5cbiAgICB2YXIgb2RkTGVuZ3RoID0gZGFzaGFycmF5Lmxlbmd0aCAlIDIgPT09IDE7XG5cbiAgICBmb3IgKHZhciB5ID0gLW47IHkgPD0gbjsgeSsrKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLm5leHRSb3cgKyBuICsgeTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy53aWR0aCAqIHJvdztcblxuICAgICAgICB2YXIgbGVmdCA9IG9kZExlbmd0aCA/IC1kYXNoYXJyYXlbZGFzaGFycmF5Lmxlbmd0aCAtIDFdIDogMDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGFzaGFycmF5WzBdO1xuICAgICAgICB2YXIgcGFydEluZGV4ID0gMTtcblxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuXG4gICAgICAgICAgICB3aGlsZSAocmlnaHQgPCB4IC8gc3RyZXRjaCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0ICsgZGFzaGFycmF5W3BhcnRJbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAob2RkTGVuZ3RoICYmIHBhcnRJbmRleCA9PT0gZGFzaGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgKz0gZGFzaGFycmF5WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzdExlZnQgPSBNYXRoLmFicyh4IC0gbGVmdCAqIHN0cmV0Y2gpO1xuICAgICAgICAgICAgdmFyIGRpc3RSaWdodCA9IE1hdGguYWJzKHggLSByaWdodCAqIHN0cmV0Y2gpO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLm1pbihkaXN0TGVmdCwgZGlzdFJpZ2h0KTtcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAocGFydEluZGV4ICUgMikgPT09IDE7XG4gICAgICAgICAgICB2YXIgc2lnbmVkRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBjaXJjbGUgY2Fwc1xuICAgICAgICAgICAgICAgIHZhciBkaXN0TWlkZGxlID0gbiA/IHkgLyBuICogKGhhbGZXaWR0aCArIDEpIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0RWRnZSA9IGhhbGZXaWR0aCAtIE1hdGguYWJzKGRpc3RNaWRkbGUpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZWREaXN0YW5jZSA9IE1hdGguc3FydChkaXN0ICogZGlzdCArIGRpc3RFZGdlICogZGlzdEVkZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZERpc3RhbmNlID0gaGFsZldpZHRoIC0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0ICsgZGlzdE1pZGRsZSAqIGRpc3RNaWRkbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkRGlzdGFuY2UgPSAoaW5zaWRlID8gMSA6IC0xKSAqIGRpc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVszICsgKGluZGV4ICsgeCkgKiA0XSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgc2lnbmVkRGlzdGFuY2UgKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHk6ICh0aGlzLm5leHRSb3cgKyBuICsgMC41KSAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IDIgKiBuIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBsZW5ndGhcbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Um93ICs9IGhlaWdodDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiBwb3M7XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkxpbmVBdGxhcy5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gMDtcbiAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICcjZmYwJztcblxuICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuc2RmKSB7XG4gICAgICAgICAgICB2YXIgayA9IGkgKiA0O1xuICAgICAgICAgICAgZGF0YS5kYXRhW2tdID0gZGF0YS5kYXRhW2sgKyAxXSA9IGRhdGEuZGF0YVtrICsgMl0gPSAwO1xuICAgICAgICAgICAgZGF0YS5kYXRhW2sgKyAzXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsdXRpbCA9IHJlcXVpcmUoJy4vZ2xfdXRpbCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcbnZhciBGcmFtZUhpc3RvcnkgPSByZXF1aXJlKCcuL2ZyYW1lX2hpc3RvcnknKTtcblxuLypcbiAqIEluaXRpYWxpemUgYSBuZXcgcGFpbnRlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtDYW52YXN9IGdsIGFuIGV4cGVyaW1lbnRhbC13ZWJnbCBkcmF3aW5nIGNvbnRleHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBHTFBhaW50ZXI7XG5mdW5jdGlvbiBHTFBhaW50ZXIoZ2wsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2wgPSBnbHV0aWwuZXh0ZW5kKGdsKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgIHRoaXMucmV1c2FibGVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMucHJlRmJvcyA9IHt9O1xuXG4gICAgdGhpcy50aWxlRXh0ZW50ID0gNDA5NjtcbiAgICB0aGlzLmZyYW1lSGlzdG9yeSA9IG5ldyBGcmFtZUhpc3RvcnkoKTtcblxuICAgIHRoaXMuc2V0dXAoKTtcbn1cblxuLypcbiAqIFVwZGF0ZSB0aGUgR0wgdmlld3BvcnQsIHByb2plY3Rpb24gbWF0cml4LCBhbmQgdHJhbnNmb3JtcyB0byBjb21wZW5zYXRlXG4gKiBmb3IgYSBuZXcgd2lkdGggYW5kIGhlaWdodCB2YWx1ZS5cbiAqL1xuR0xQYWludGVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbn07XG5cblxuR0xQYWludGVyLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBnbC52ZXJib3NlID0gdHJ1ZTtcblxuICAgIC8vIFdlIGFyZSBibGVuZGluZyB0aGUgbmV3IHBpeGVscyAqYmVoaW5kKiB0aGUgZXhpc3RpbmcgcGl4ZWxzLiBUaGF0IHdheSB3ZSBjYW5cbiAgICAvLyBkcmF3IGZyb250LXRvLWJhY2sgYW5kIHVzZSB0aGVuIHN0ZW5jaWwgYnVmZmVyIHRvIGN1bGwgb3BhcXVlIHBpeGVscyBlYXJseS5cbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkUpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHNoYWRlcnNcbiAgICB0aGlzLmRlYnVnU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignZGVidWcnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9wb2ludHNpemUnLCAndV9jb2xvciddKTtcblxuICAgIHRoaXMuZ2F1c3NpYW5TaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdnYXVzc2lhbicsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2ltYWdlJywgJ3Vfb2Zmc2V0J10pO1xuXG4gICAgdGhpcy5yYXN0ZXJTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdyYXN0ZXInLFxuICAgICAgICBbJ2FfcG9zJywgJ2FfdGV4dHVyZV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2JyaWdodG5lc3NfbG93JywgJ3VfYnJpZ2h0bmVzc19oaWdoJywgJ3Vfc2F0dXJhdGlvbl9mYWN0b3InLCAndV9zcGluX3dlaWdodHMnLCAndV9jb250cmFzdF9mYWN0b3InLCAndV9vcGFjaXR5MCcsICd1X29wYWNpdHkxJywgJ3VfaW1hZ2UwJywgJ3VfaW1hZ2UxJywgJ3VfdGxfcGFyZW50JywgJ3Vfc2NhbGVfcGFyZW50JywgJ3VfYnVmZmVyX3NjYWxlJ10pO1xuXG4gICAgdGhpcy5saW5lU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignbGluZScsXG4gICAgICAgIFsnYV9wb3MnLCAnYV9kYXRhJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9saW5ld2lkdGgnLCAndV9jb2xvcicsICd1X3JhdGlvJywgJ3VfYmx1cicsICd1X2V4dHJhJywgJ3VfYW50aWFsaWFzaW5nbWF0cml4J10pO1xuXG4gICAgdGhpcy5saW5lcGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmVwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcycsICdhX2RhdGEnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfcmF0aW8nLCAndV9wYXR0ZXJuX3NpemVfYScsICd1X3BhdHRlcm5fc2l6ZV9iJywgJ3VfcGF0dGVybl90bF9hJywgJ3VfcGF0dGVybl9icl9hJywgJ3VfcGF0dGVybl90bF9iJywgJ3VfcGF0dGVybl9icl9iJywgJ3VfYmx1cicsICd1X2ZhZGUnLCAndV9vcGFjaXR5J10pO1xuXG4gICAgdGhpcy5saW5lc2RmcGF0dGVyblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2xpbmVzZGZwYXR0ZXJuJyxcbiAgICAgICAgWydhX3BvcycsICdhX2RhdGEnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X2V4bWF0cml4JywgJ3VfbGluZXdpZHRoJywgJ3VfY29sb3InLCAndV9yYXRpbycsICd1X2JsdXInLCAndV9wYXR0ZXJuc2NhbGVfYScsICd1X3RleF95X2EnLCAndV9wYXR0ZXJuc2NhbGVfYicsICd1X3RleF95X2InLCAndV9pbWFnZScsICd1X3NkZmdhbW1hJywgJ3VfbWl4J10pO1xuXG4gICAgdGhpcy5kb3RTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdkb3QnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9zaXplJywgJ3VfY29sb3InLCAndV9ibHVyJ10pO1xuXG4gICAgdGhpcy5zZGZTaGFkZXIgPSBnbC5pbml0aWFsaXplU2hhZGVyKCdzZGYnLFxuICAgICAgICBbJ2FfcG9zJywgJ2Ffb2Zmc2V0JywgJ2FfZGF0YTEnLCAnYV9kYXRhMiddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV90ZXh0dXJlJywgJ3VfdGV4c2l6ZScsICd1X2NvbG9yJywgJ3VfZ2FtbWEnLCAndV9idWZmZXInLCAndV96b29tJywgJ3VfZmFkZWRpc3QnLCAndV9taW5mYWRlem9vbScsICd1X21heGZhZGV6b29tJywgJ3VfZmFkZXpvb20nLCAndV9za2V3ZWQnLCAndV9leHRyYSddKTtcblxuICAgIHRoaXMuaWNvblNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ljb24nLFxuICAgICAgICBbJ2FfcG9zJywgJ2Ffb2Zmc2V0JywgJ2FfZGF0YTEnLCAnYV9kYXRhMiddLFxuICAgICAgICBbJ3VfbWF0cml4JywgJ3VfZXhtYXRyaXgnLCAndV90ZXh0dXJlJywgJ3VfdGV4c2l6ZScsICd1X3pvb20nLCAndV9mYWRlZGlzdCcsICd1X21pbmZhZGV6b29tJywgJ3VfbWF4ZmFkZXpvb20nLCAndV9mYWRlem9vbScsICd1X29wYWNpdHknLCAndV9za2V3ZWQnLCAndV9leHRyYSddKTtcblxuICAgIHRoaXMub3V0bGluZVNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ291dGxpbmUnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9jb2xvcicsICd1X3dvcmxkJ11cbiAgICApO1xuXG4gICAgdGhpcy5wYXR0ZXJuU2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcigncGF0dGVybicsXG4gICAgICAgIFsnYV9wb3MnXSxcbiAgICAgICAgWyd1X21hdHJpeCcsICd1X3BhdHRlcm5fdGxfYScsICd1X3BhdHRlcm5fYnJfYScsICd1X3BhdHRlcm5fdGxfYicsICd1X3BhdHRlcm5fYnJfYicsICd1X21peCcsICd1X3BhdHRlcm5tYXRyaXhfYScsICd1X3BhdHRlcm5tYXRyaXhfYicsICd1X29wYWNpdHknLCAndV9pbWFnZSddXG4gICAgKTtcblxuICAgIHRoaXMuZmlsbFNoYWRlciA9IGdsLmluaXRpYWxpemVTaGFkZXIoJ2ZpbGwnLFxuICAgICAgICBbJ2FfcG9zJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9jb2xvciddXG4gICAgKTtcblxuICAgIHRoaXMuY29sbGlzaW9uQm94U2hhZGVyID0gZ2wuaW5pdGlhbGl6ZVNoYWRlcignY29sbGlzaW9uYm94JyxcbiAgICAgICAgWydhX3BvcycsICdhX2V4dHJ1ZGUnLCAnYV9kYXRhJ10sXG4gICAgICAgIFsndV9tYXRyaXgnLCAndV9zY2FsZScsICd1X3pvb20nLCAndV9tYXh6b29tJ11cbiAgICApO1xuXG4gICAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAvLyBUaGUgYmFja2dyb3VuZEJ1ZmZlciBpcyB1c2VkIHdoZW4gZHJhd2luZyB0byB0aGUgZnVsbCAqY2FudmFzKlxuICAgIHRoaXMuYmFja2dyb3VuZEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtU2l6ZSA9IDI7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQnVmZmVyLml0ZW1Db3VudCA9IDQ7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMV0pLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyBUaGUgdGlsZUV4dGVudEJ1ZmZlciBpcyB1c2VkIHdoZW4gZHJhd2luZyB0byBhIGZ1bGwgKnRpbGUqXG4gICAgdGhpcy50aWxlRXh0ZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy50aWxlRXh0ZW50QnVmZmVyLml0ZW1TaXplID0gNDtcbiAgICB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50ID0gNDtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy50aWxlRXh0ZW50QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoW1xuICAgICAgICAvLyB0aWxlIGNvb3JkIHgsIHRpbGUgY29vcmQgeSwgdGV4dHVyZSBjb29yZCB4LCB0ZXh0dXJlIGNvb3JkIHlcbiAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAgICAgICAgICAgICAgICAgICAgMCwgMCxcbiAgICAgICAgdGhpcy50aWxlRXh0ZW50LCAwLCAgICAgICAgICAgICAgICAzMjc2NywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAwLCB0aGlzLnRpbGVFeHRlbnQsICAgICAgMCwgMzI3NjcsXG4gICAgICAgIHRoaXMudGlsZUV4dGVudCwgdGhpcy50aWxlRXh0ZW50LCAgMzI3NjcsIDMyNzY3XG4gICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIFRoZSBkZWJ1Z0J1ZmZlciBpcyB1c2VkIHRvIGRyYXcgdGlsZSBvdXRsaW5lcyBmb3IgZGVidWdnaW5nXG4gICAgdGhpcy5kZWJ1Z0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZGVidWdCdWZmZXIuaXRlbVNpemUgPSAyO1xuICAgIHRoaXMuZGVidWdCdWZmZXIuaXRlbUNvdW50ID0gNTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5kZWJ1Z0J1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KFswLCAwLCA0MDk1LCAwLCA0MDk1LCA0MDk1LCAwLCA0MDk1LCAwLCAwXSksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgIC8vIFRoZSBkZWJ1Z1RleHRCdWZmZXIgaXMgdXNlZCB0byBkcmF3IHRpbGUgSURzIGZvciBkZWJ1Z2dpbmdcbiAgICB0aGlzLmRlYnVnVGV4dEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZGVidWdUZXh0QnVmZmVyLml0ZW1TaXplID0gMjtcbn07XG5cbi8qXG4gKiBSZXNldCB0aGUgY29sb3IgYnVmZmVycyBvZiB0aGUgZHJhd2luZyBjYW52YXMuXG4gKi9cbkdMUGFpbnRlci5wcm90b3R5cGUuY2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qXG4gKiBSZXNldCB0aGUgZHJhd2luZyBjYW52YXMgYnkgY2xlYXJpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRyYXdcbiAqIG5ldyB0aWxlcyBhdCB0aGUgc2FtZSBsb2NhdGlvbiwgd2hpbGUgcmV0YWluaW5nIHByZXZpb3VzbHkgZHJhd24gcGl4ZWxzLlxuICovXG5HTFBhaW50ZXIucHJvdG90eXBlLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJTdGVuY2lsKDB4MCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHhGRik7XG4gICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbn07XG5cbkdMUGFpbnRlci5wcm90b3R5cGUuZHJhd0NsaXBwaW5nTWFzayA9IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnN3aXRjaFNoYWRlcih0aGlzLmZpbGxTaGFkZXIsIHRpbGUucG9zTWF0cml4KTtcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgLy8gQ2xlYXIgdGhlIGVudGlyZSBzdGVuY2lsIGJ1ZmZlciwgZXhjZXB0IGZvciB0aGUgN3RoIGJpdCwgd2hpY2ggc3RvcmVzXG4gICAgLy8gdGhlIGdsb2JhbCBjbGlwcGluZyBtYXNrIHRoYXQgYWxsb3dzIHVzIHRvIGF2b2lkIGRyYXdpbmcgaW4gcmVnaW9ucyBvZlxuICAgIC8vIHRpbGVzIHdlJ3ZlIGFscmVhZHkgcGFpbnRlZCBpbi5cbiAgICBnbC5jbGVhclN0ZW5jaWwoMHgwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEJGKTtcbiAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuXG4gICAgLy8gVGhlIHN0ZW5jaWwgdGVzdCB3aWxsIGZhaWwgYWx3YXlzLCBtZWFuaW5nIHdlIHNldCBhbGwgcGl4ZWxzIGNvdmVyZWRcbiAgICAvLyBieSB0aGlzIGdlb21ldHJ5IHRvIDB4ODAuIFdlIHVzZSB0aGUgaGlnaGVzdCBiaXQgMHg4MCB0byBtYXJrIHRoZSByZWdpb25zXG4gICAgLy8gd2Ugd2FudCB0byBkcmF3IGluLiBBbGwgcGl4ZWxzIHRoYXQgaGF2ZSB0aGlzIGJpdCAqbm90KiBzZXQgd2lsbCBuZXZlciBiZVxuICAgIC8vIGRyYXduIGluLlxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweEMwLCAweDQwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEMwKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuUkVQTEFDRSwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG5cbiAgICAvLyBEcmF3IHRoZSBjbGlwcGluZyBtYXNrXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmZpbGxTaGFkZXIuYV9wb3MsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5pdGVtU2l6ZSwgZ2wuU0hPUlQsIGZhbHNlLCA4LCAwKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCB0aGlzLnRpbGVFeHRlbnRCdWZmZXIuaXRlbUNvdW50KTtcblxuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAweDgwLCAweDgwKTtcbiAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuUkVQTEFDRSk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xufTtcblxuLy8gT3ZlcnJpZGRlbiBieSBoZWFkbGVzcyB0ZXN0cy5cbkdMUGFpbnRlci5wcm90b3R5cGUucHJlcGFyZUJ1ZmZlcnMgPSBmdW5jdGlvbigpIHt9O1xuR0xQYWludGVyLnByb3RvdHlwZS5iaW5kRGVmYXVsdEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xufTtcblxudmFyIGRyYXcgPSB7XG4gICAgc3ltYm9sOiByZXF1aXJlKCcuL2RyYXdfc3ltYm9sJyksXG4gICAgbGluZTogcmVxdWlyZSgnLi9kcmF3X2xpbmUnKSxcbiAgICBmaWxsOiByZXF1aXJlKCcuL2RyYXdfZmlsbCcpLFxuICAgIHJhc3RlcjogcmVxdWlyZSgnLi9kcmF3X3Jhc3RlcicpLFxuICAgIGJhY2tncm91bmQ6IHJlcXVpcmUoJy4vZHJhd19iYWNrZ3JvdW5kJyksXG4gICAgZGVidWc6IHJlcXVpcmUoJy4vZHJhd19kZWJ1ZycpLFxuICAgIHZlcnRpY2VzOiByZXF1aXJlKCcuL2RyYXdfdmVydGljZXMnKVxufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5saW5lQXRsYXMgPSBzdHlsZS5saW5lQXRsYXM7XG5cbiAgICB0aGlzLnNwcml0ZUF0bGFzID0gc3R5bGUuc3ByaXRlQXRsYXM7XG4gICAgdGhpcy5zcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3R5bGUuc3ByaXRlKTtcblxuICAgIHRoaXMuZ2x5cGhBdGxhcyA9IHN0eWxlLmdseXBoQXRsYXM7XG4gICAgdGhpcy5nbHlwaEF0bGFzLmJpbmQodGhpcy5nbCk7XG5cbiAgICB0aGlzLmZyYW1lSGlzdG9yeS5yZWNvcmQodGhpcy50cmFuc2Zvcm0uem9vbSk7XG5cbiAgICB0aGlzLnByZXBhcmVCdWZmZXJzKCk7XG4gICAgdGhpcy5jbGVhckNvbG9yKCk7XG5cbiAgICBmb3IgKHZhciBpID0gc3R5bGUuX2dyb3Vwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgZ3JvdXAgPSBzdHlsZS5fZ3JvdXBzW2ldO1xuICAgICAgICB2YXIgc291cmNlID0gc3R5bGUuc291cmNlc1tncm91cC5zb3VyY2VdO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJTdGVuY2lsKCk7XG4gICAgICAgICAgICBzb3VyY2UucmVuZGVyKGdyb3VwLCB0aGlzKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdMYXllcnMoZ3JvdXAsIHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3VGlsZSA9IGZ1bmN0aW9uKHRpbGUsIGxheWVycykge1xuICAgIHRoaXMuZHJhd0NsaXBwaW5nTWFzayh0aWxlKTtcbiAgICB0aGlzLmRyYXdMYXllcnMobGF5ZXJzLCB0aWxlLnBvc01hdHJpeCwgdGlsZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIGRyYXcuZGVidWcodGhpcywgdGlsZSk7XG4gICAgfVxufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3TGF5ZXJzID0gZnVuY3Rpb24obGF5ZXJzLCBtYXRyaXgsIHRpbGUpIHtcbiAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICBpZiAobGF5ZXIuaGlkZGVuKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgZHJhd1tsYXllci50eXBlXSh0aGlzLCBsYXllciwgbWF0cml4LCB0aWxlKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2VzKSB7XG4gICAgICAgICAgICBkcmF3LnZlcnRpY2VzKHRoaXMsIGxheWVyLCBtYXRyaXgsIHRpbGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gRHJhd3Mgbm9uLW9wYXF1ZSBhcmVhcy4gVGhpcyBpcyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuR0xQYWludGVyLnByb3RvdHlwZS5kcmF3U3RlbmNpbEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuc3dpdGNoU2hhZGVyKHRoaXMuZmlsbFNoYWRlciwgdGhpcy5pZGVudGl0eU1hdHJpeCk7XG5cbiAgICAvLyBCbGVuZCB0byB0aGUgZnJvbnQsIG5vdCB0aGUgYmFjay5cbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG5cbiAgICAvLyBEcncgdGhlIGZpbGxpbmcgcXVhZCB3aGVyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXNuJ3Qgc2V0LlxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJhY2tncm91bmRCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5maWxsU2hhZGVyLmFfcG9zLCB0aGlzLmJhY2tncm91bmRCdWZmZXIuaXRlbVNpemUsIGdsLlNIT1JULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wudW5pZm9ybTRmdih0aGlzLmZpbGxTaGFkZXIudV9jb2xvciwgWzAsIDAsIDAsIDAuNV0pO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMuYmFja2dyb3VuZEJ1ZmZlci5pdGVtQ291bnQpO1xuXG4gICAgLy8gUmV2ZXJ0IGJsZW5kaW5nIG1vZGUgdG8gYmxlbmQgdG8gdGhlIGJhY2suXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORSk7XG59O1xuXG5HTFBhaW50ZXIucHJvdG90eXBlLnRyYW5zbGF0ZU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCwgdGlsZSwgdHJhbnNsYXRlLCBhbmNob3IpIHtcbiAgICBpZiAoIXRyYW5zbGF0ZVswXSAmJiAhdHJhbnNsYXRlWzFdKSByZXR1cm4gbWF0cml4O1xuXG4gICAgaWYgKGFuY2hvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgICB2YXIgc2luQSA9IE1hdGguc2luKC10aGlzLnRyYW5zZm9ybS5hbmdsZSk7XG4gICAgICAgIHZhciBjb3NBID0gTWF0aC5jb3MoLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdHJhbnNsYXRlID0gW1xuICAgICAgICAgICAgdHJhbnNsYXRlWzBdICogY29zQSAtIHRyYW5zbGF0ZVsxXSAqIHNpbkEsXG4gICAgICAgICAgICB0cmFuc2xhdGVbMF0gKiBzaW5BICsgdHJhbnNsYXRlWzFdICogY29zQVxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciB0aWxlUGl4ZWxSYXRpbyA9IHRoaXMudHJhbnNmb3JtLnNjYWxlIC8gKDEgPDwgdGlsZS56b29tKSAvICh0aWxlLnRpbGVFeHRlbnQgLyB0aWxlLnRpbGVTaXplKTtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSBbXG4gICAgICAgIHRyYW5zbGF0ZVswXSAvIHRpbGVQaXhlbFJhdGlvLFxuICAgICAgICB0cmFuc2xhdGVbMV0gLyB0aWxlUGl4ZWxSYXRpbyxcbiAgICAgICAgMFxuICAgIF07XG5cbiAgICB2YXIgdHJhbnNsYXRlZE1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zbGF0ZWRNYXRyaXgsIG1hdHJpeCwgdHJhbnNsYXRpb24pO1xuICAgIHJldHVybiB0cmFuc2xhdGVkTWF0cml4O1xufTtcblxuR0xQYWludGVyLnByb3RvdHlwZS5zYXZlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbdGV4dHVyZS5zaXplXTtcbiAgICBpZiAoIXRleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucmV1c2FibGVUZXh0dXJlc1t0ZXh0dXJlLnNpemVdID0gW3RleHR1cmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgfVxufTtcblxuXG5HTFBhaW50ZXIucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIHRleHR1cmVzID0gdGhpcy5yZXVzYWJsZVRleHR1cmVzW3NpemVdO1xuICAgIHJldHVybiB0ZXh0dXJlcyAmJiB0ZXh0dXJlcy5sZW5ndGggPiAwID8gdGV4dHVyZXMucG9wKCkgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsaWZ5ID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcImRlYnVnXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudW5pZm9ybSBmbG9hdCB1X3BvaW50c2l6ZTtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLncgPSAxLjA7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgdG1wdmFyXzEueiA9IGZsb2F0KChhX3Bvcy54ID49IDMyNzY3LjApKTtcXG4gIGdsX1Bvc2l0aW9uID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9pbnRTaXplID0gdV9wb2ludHNpemU7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XFxufVxcblxcblwifSxcbiAgICBcImRvdFwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZTtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIGdsX1BvaW50U2l6ZSA9IHVfc2l6ZTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgbWVkaXVtcCB2ZWMyIHhfMTtcXG4gIHhfMSA9IChnbF9Qb2ludENvb3JkIC0gMC41KTtcXG4gIG1lZGl1bXAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IGNsYW1wICgoKFxcbiAgICBzcXJ0KGRvdCAoeF8xLCB4XzEpKVxcbiAgIC0gMC41KSAvIChcXG4gICAgKDAuNSAtIHVfYmx1cilcXG4gICAtIDAuNSkpLCAwLjAsIDEuMCk7XFxuICBnbF9GcmFnQ29sb3IgPSAodV9jb2xvciAqICh0bXB2YXJfMiAqICh0bXB2YXJfMiAqIFxcbiAgICAoMy4wIC0gKDIuMCAqIHRtcHZhcl8yKSlcXG4gICkpKTtcXG59XFxuXFxuXCJ9LFxuICAgIFwiZmlsbFwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIGdsX1BvaW50U2l6ZSA9IDIuMDtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudm9pZCBtYWluICgpXFxue1xcbiAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcXG59XFxuXFxuXCJ9LFxuICAgIFwiZ2F1c3NpYW5cIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfb2Zmc2V0O1xcbnZhcnlpbmcgaGlnaHAgdmVjMiBhWzNdO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzEueHkgPSBhX3BvcztcXG4gIHZlYzQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIGdsX1Bvc2l0aW9uID0gdG1wdmFyXzI7XFxuICBoaWdocCB2ZWMyIHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAoKHRtcHZhcl8yLnh5IC8gMi4wKSArIDAuNSk7XFxuICBhWzBdID0gdG1wdmFyXzM7XFxuICB2ZWMyIGNzZV80O1xcbiAgY3NlXzQgPSAodV9vZmZzZXQgKiAxLjE4MjQzKTtcXG4gIGFbMV0gPSAodG1wdmFyXzMgKyBjc2VfNCk7XFxuICBhWzJdID0gKHRtcHZhcl8zIC0gY3NlXzQpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZhcnlpbmcgdmVjMiBhWzNdO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGxvd3AgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKCgodGV4dHVyZTJEICh1X2ltYWdlLCBhWzBdKSAqIDAuNDAyNjIpICsgKHRleHR1cmUyRCAodV9pbWFnZSwgYVsxXSkgKiAwLjI5ODY5KSkgKyAodGV4dHVyZTJEICh1X2ltYWdlLCBhWzJdKSAqIDAuMjk4NjkpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8xO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJsaW5lXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG51bmlmb3JtIG1hdDIgdV9hbnRpYWxpYXNpbmdtYXRyaXg7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBoaWdocCBmbG9hdCBjO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzIgZV8xO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHZlYzIobW9kIChhX3BvcywgMi4wKSkpO1xcbiAgZV8xLnggPSB0bXB2YXJfMi54O1xcbiAgZV8xLnkgPSBzaWduKCh0bXB2YXJfMi55IC0gMC41KSk7XFxuICBhID0gZV8xO1xcbiAgdmVjNCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zLnp3ID0gdmVjMigwLjAsIDAuMCk7XFxuICB0bXB2YXJfMy54eSA9ICgodV9saW5ld2lkdGgueCAqIGFfZGF0YS54eSkgKiAwLjAxNTg3Myk7XFxuICB2ZWM0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl80Lnh5ID0gKGZsb29yKChhX3BvcyAqIDAuNSkpICsgKHRtcHZhcl8zLnh5IC8gdV9yYXRpbykpO1xcbiAgdmVjNCB0bXB2YXJfNTtcXG4gIHRtcHZhcl81ID0gKHVfbWF0cml4ICogdG1wdmFyXzQpO1xcbiAgZ2xfUG9zaXRpb24gPSB0bXB2YXJfNTtcXG4gIHZlYzIgeF82O1xcbiAgeF82ID0gKHVfYW50aWFsaWFzaW5nbWF0cml4ICogYV9kYXRhLnh5KTtcXG4gIGMgPSAoKDEuMC8oKDEuMCAtIFxcbiAgICAoKHRtcHZhcl81LnkgLyB0bXB2YXJfNS53KSAqIHVfZXh0cmEpXFxuICApKSkgKiAoc3FydChcXG4gICAgZG90IChhX2RhdGEueHksIGFfZGF0YS54eSlcXG4gICkgLyBzcXJ0KFxcbiAgICBkb3QgKHhfNiwgeF82KVxcbiAgKSkpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBjO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGZsb2F0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAoc3FydChkb3QgKGEsIGEpKSAqIHVfbGluZXdpZHRoLngpO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICh1X2JsdXIgKiBjKTtcXG4gIGdsX0ZyYWdDb2xvciA9ICh1X2NvbG9yICogY2xhbXAgKChcXG4gICAgbWluICgodG1wdmFyXzEgLSAodV9saW5ld2lkdGgueSAtIHRtcHZhcl8yKSksICh1X2xpbmV3aWR0aC54IC0gdG1wdmFyXzEpKVxcbiAgIC8gdG1wdmFyXzIpLCAwLjAsIDEuMCkpO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJsaW5lcGF0dGVyblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGF0YTtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3JhdGlvO1xcbnVuaWZvcm0gdmVjMiB1X2xpbmV3aWR0aDtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjMiBlXzE7XFxuICB2ZWMyIHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIgPSAodmVjMihtb2QgKGFfcG9zLCAyLjApKSk7XFxuICBlXzEueCA9IHRtcHZhcl8yLng7XFxuICBlXzEueSA9IHNpZ24oKHRtcHZhcl8yLnkgLSAwLjUpKTtcXG4gIGEgPSBlXzE7XFxuICB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8zLnh5ID0gKGZsb29yKChhX3BvcyAqIDAuNSkpICsgKCh1X2xpbmV3aWR0aC54ICogXFxuICAgIChhX2RhdGEueHkgKiAwLjAxNTg3MylcXG4gICkgLyB1X3JhdGlvKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl8zKTtcXG4gIGIgPSAoKGFfZGF0YS56ICogMTI4LjApICsgYV9kYXRhLncpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9iO1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcbnVuaWZvcm0gZmxvYXQgdV9mYWRlO1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGZsb2F0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAoc3FydChkb3QgKGEsIGEpKSAqIHVfbGluZXdpZHRoLngpO1xcbiAgdmVjMiB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yLnggPSAoZmxvYXQobW9kICgoYiAvIHVfcGF0dGVybl9zaXplX2EueCksIDEuMCkpKTtcXG4gIGZsb2F0IGNzZV8zO1xcbiAgY3NlXzMgPSAoYS55ICogdV9saW5ld2lkdGgueCk7XFxuICB0bXB2YXJfMi55ID0gKDAuNSArIChjc2VfMyAvIHVfcGF0dGVybl9zaXplX2EueSkpO1xcbiAgdmVjMiB0bXB2YXJfNDtcXG4gIHRtcHZhcl80LnggPSAoZmxvYXQobW9kICgoYiAvIHVfcGF0dGVybl9zaXplX2IueCksIDEuMCkpKTtcXG4gIHRtcHZhcl80LnkgPSAoMC41ICsgKGNzZV8zIC8gdV9wYXR0ZXJuX3NpemVfYi55KSk7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzU7XFxuICB0bXB2YXJfNSA9IChtaXggKHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGxfYSwgdV9wYXR0ZXJuX2JyX2EsIHRtcHZhcl8yKSksIHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIHRtcHZhcl80KSksIHVfZmFkZSkgKiAoY2xhbXAgKFxcbiAgICAobWluICgodG1wdmFyXzEgLSAodV9saW5ld2lkdGgueSAtIHVfYmx1cikpLCAodV9saW5ld2lkdGgueCAtIHRtcHZhcl8xKSkgLyB1X2JsdXIpXFxuICAsIDAuMCwgMS4wKSAqIHVfb3BhY2l0eSkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdG1wdmFyXzU7XFxufVxcblxcblwifSxcbiAgICBcImxpbmVzZGZwYXR0ZXJuXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybnNjYWxlX2I7XFxudW5pZm9ybSBmbG9hdCB1X3JhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV90ZXhfeV9hO1xcbnVuaWZvcm0gZmxvYXQgdV90ZXhfeV9iO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgdmVjMiBiO1xcbnZhcnlpbmcgdmVjMiBjO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIHZlYzIgZl8xO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICgoYV9kYXRhLnogKiAxMjguMCkgKyBhX2RhdGEudyk7XFxuICB2ZWMyIHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAodmVjMihtb2QgKGFfcG9zLCAyLjApKSk7XFxuICBmXzEueCA9IHRtcHZhcl8zLng7XFxuICBmXzEueSA9IHNpZ24oKHRtcHZhcl8zLnkgLSAwLjUpKTtcXG4gIGEgPSBmXzE7XFxuICB2ZWM0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQuencgPSB2ZWMyKDAuMCwgMC4wKTtcXG4gIHRtcHZhcl80Lnh5ID0gKCh1X2xpbmV3aWR0aC54ICogYV9kYXRhLnh5KSAqIDAuMDE1ODczKTtcXG4gIHZlYzQgdG1wdmFyXzU7XFxuICB0bXB2YXJfNS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgdG1wdmFyXzUueHkgPSAoZmxvb3IoKGFfcG9zICogMC41KSkgKyAodG1wdmFyXzQueHkgLyB1X3JhdGlvKSk7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl81KTtcXG4gIHZlYzIgdG1wdmFyXzY7XFxuICB0bXB2YXJfNi54ID0gKHRtcHZhcl8yICogdV9wYXR0ZXJuc2NhbGVfYS54KTtcXG4gIHRtcHZhcl82LnkgPSAoKGZfMS55ICogdV9wYXR0ZXJuc2NhbGVfYS55KSArIHVfdGV4X3lfYSk7XFxuICBiID0gdG1wdmFyXzY7XFxuICB2ZWMyIHRtcHZhcl83O1xcbiAgdG1wdmFyXzcueCA9ICh0bXB2YXJfMiAqIHVfcGF0dGVybnNjYWxlX2IueCk7XFxuICB0bXB2YXJfNy55ID0gKChmXzEueSAqIHVfcGF0dGVybnNjYWxlX2IueSkgKyB1X3RleF95X2IpO1xcbiAgYyA9IHRtcHZhcl83O1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIHZlYzIgdV9saW5ld2lkdGg7XFxudW5pZm9ybSB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudW5pZm9ybSBmbG9hdCB1X3NkZmdhbW1hO1xcbnVuaWZvcm0gZmxvYXQgdV9taXg7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIHZlYzIgYjtcXG52YXJ5aW5nIHZlYzIgYztcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKHNxcnQoZG90IChhLCBhKSkgKiB1X2xpbmV3aWR0aC54KTtcXG4gIGZsb2F0IGVkZ2UwXzI7XFxuICBlZGdlMF8yID0gKDAuNSAtIHVfc2RmZ2FtbWEpO1xcbiAgbG93cCBmbG9hdCB0bXB2YXJfMztcXG4gIHRtcHZhcl8zID0gY2xhbXAgKCgoXFxuICAgIG1peCAodGV4dHVyZTJEICh1X2ltYWdlLCBiKS53LCB0ZXh0dXJlMkQgKHVfaW1hZ2UsIGMpLncsIHVfbWl4KVxcbiAgIC0gZWRnZTBfMikgLyAoXFxuICAgICgwLjUgKyB1X3NkZmdhbW1hKVxcbiAgIC0gZWRnZTBfMikpLCAwLjAsIDEuMCk7XFxuICBsb3dwIHZlYzQgdG1wdmFyXzQ7XFxuICB0bXB2YXJfNCA9ICh1X2NvbG9yICogKGNsYW1wIChcXG4gICAgKG1pbiAoKHRtcHZhcl8xIC0gKHVfbGluZXdpZHRoLnkgLSB1X2JsdXIpKSwgKHVfbGluZXdpZHRoLnggLSB0bXB2YXJfMSkpIC8gdV9ibHVyKVxcbiAgLCAwLjAsIDEuMCkgKiAodG1wdmFyXzMgKiBcXG4gICAgKHRtcHZhcl8zICogKDMuMCAtICgyLjAgKiB0bXB2YXJfMykpKVxcbiAgKSkpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdG1wdmFyXzQ7XFxufVxcblxcblwifSxcbiAgICBcIm91dGxpbmVcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfd29ybGQ7XFxudmFyeWluZyBoaWdocCB2ZWMyIGE7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgdmVjNCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgZ2xfUG9zaXRpb24gPSB0bXB2YXJfMjtcXG4gIGEgPSAoKChcXG4gICAgKHRtcHZhcl8yLnh5IC8gdG1wdmFyXzIudylcXG4gICArIDEuMCkgLyAyLjApICogdV93b3JsZCk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGhpZ2hwIHZlYzIgeF8xO1xcbiAgeF8xID0gKGEgLSBnbF9GcmFnQ29vcmQueHkpO1xcbiAgaGlnaHAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IGNsYW1wICgoKFxcbiAgICBzcXJ0KGRvdCAoeF8xLCB4XzEpKVxcbiAgIC0gMS4wKSAvIC0xLjApLCAwLjAsIDEuMCk7XFxuICBoaWdocCB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAodV9jb2xvciAqICh0bXB2YXJfMiAqICh0bXB2YXJfMiAqIFxcbiAgICAoMy4wIC0gKDIuMCAqIHRtcHZhcl8yKSlcXG4gICkpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl8zO1xcbn1cXG5cXG5cIn0sXG4gICAgXCJwYXR0ZXJuXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gbWF0MyB1X3BhdHRlcm5tYXRyaXhfYTtcXG51bmlmb3JtIG1hdDMgdV9wYXR0ZXJubWF0cml4X2I7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxudmFyeWluZyB2ZWMyIGE7XFxudmFyeWluZyB2ZWMyIGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgdmVjNCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xLnp3ID0gdmVjMigwLjAsIDEuMCk7XFxuICB0bXB2YXJfMS54eSA9IGFfcG9zO1xcbiAgZ2xfUG9zaXRpb24gPSAodV9tYXRyaXggKiB0bXB2YXJfMSk7XFxuICB2ZWMzIHRtcHZhcl8yO1xcbiAgdG1wdmFyXzIueiA9IDEuMDtcXG4gIHRtcHZhcl8yLnh5ID0gYV9wb3M7XFxuICBhID0gKHVfcGF0dGVybm1hdHJpeF9hICogdG1wdmFyXzIpLnh5O1xcbiAgdmVjMyB0bXB2YXJfMztcXG4gIHRtcHZhcl8zLnogPSAxLjA7XFxuICB0bXB2YXJfMy54eSA9IGFfcG9zO1xcbiAgYiA9ICh1X3BhdHRlcm5tYXRyaXhfYiAqIHRtcHZhcl8zKS54eTtcXG59XFxuXFxuXCIsXCJmcmFnbWVudFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYjtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2I7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIHZlYzIgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9IChtaXggKHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGxfYSwgdV9wYXR0ZXJuX2JyX2EsIFxcbiAgICAodmVjMihtb2QgKGEsIDEuMCkpKVxcbiAgKSksIHRleHR1cmUyRCAodV9pbWFnZSwgbWl4ICh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIFxcbiAgICAodmVjMihtb2QgKGIsIDEuMCkpKVxcbiAgKSksIHVfbWl4KSAqIHVfb3BhY2l0eSk7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMTtcXG59XFxuXFxuXCJ9LFxuICAgIFwicmFzdGVyXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIHZlYzIgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gYV9wb3M7XFxuICBnbF9Qb3NpdGlvbiA9ICh1X21hdHJpeCAqIHRtcHZhcl8xKTtcXG4gIHZlYzIgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9ICgoKFxcbiAgICAoYV90ZXh0dXJlX3BvcyAvIDMyNzY3LjApXFxuICAgLSAwLjUpIC8gdV9idWZmZXJfc2NhbGUpICsgMC41KTtcXG4gIGEgPSB0bXB2YXJfMjtcXG4gIGIgPSAoKHRtcHZhcl8yICogdV9zY2FsZV9wYXJlbnQpICsgdV90bF9wYXJlbnQpO1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTA7XFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHkxO1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2xvdztcXG51bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzc19oaWdoO1xcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3RfZmFjdG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2UwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2UxO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgdmVjMiBiO1xcbnVuaWZvcm0gdmVjMyB1X3NwaW5fd2VpZ2h0cztcXG52b2lkIG1haW4gKClcXG57XFxuICBsb3dwIHZlYzQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9ICgodGV4dHVyZTJEICh1X2ltYWdlMCwgYSkgKiB1X29wYWNpdHkwKSArICh0ZXh0dXJlMkQgKHVfaW1hZ2UxLCBiKSAqIHVfb3BhY2l0eTEpKTtcXG4gIGxvd3AgdmVjMyB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yLnggPSBkb3QgKHRtcHZhcl8xLnh5eiwgdV9zcGluX3dlaWdodHMpO1xcbiAgdG1wdmFyXzIueSA9IGRvdCAodG1wdmFyXzEueHl6LCB1X3NwaW5fd2VpZ2h0cy56eHkpO1xcbiAgdG1wdmFyXzIueiA9IGRvdCAodG1wdmFyXzEueHl6LCB1X3NwaW5fd2VpZ2h0cy55engpO1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMueHl6ID0gbWl4ICh2ZWMzKHVfYnJpZ2h0bmVzc19sb3cpLCB2ZWMzKHVfYnJpZ2h0bmVzc19oaWdoKSwgKChcXG4gICAgKCh0bXB2YXJfMiArICgoXFxuICAgICAgKCgodG1wdmFyXzEueCArIHRtcHZhcl8xLnkpICsgdG1wdmFyXzEueikgLyAzLjApXFxuICAgICAtIHRtcHZhcl8yKSAqIHVfc2F0dXJhdGlvbl9mYWN0b3IpKSAtIDAuNSlcXG4gICAqIHVfY29udHJhc3RfZmFjdG9yKSArIDAuNSkpO1xcbiAgdG1wdmFyXzMudyA9IHRtcHZhcl8xLnc7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMztcXG59XFxuXFxuXCJ9LFxuICAgIFwiaWNvblwiOiB7XCJ2ZXJ0ZXhcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfb2Zmc2V0O1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGF0YTE7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMjtcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVfZXhtYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGVkaXN0O1xcbnVuaWZvcm0gZmxvYXQgdV9taW5mYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfbWF4ZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X2ZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5O1xcbnVuaWZvcm0gYm9vbCB1X3NrZXdlZDtcXG51bmlmb3JtIHZlYzIgdV90ZXhzaXplO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICBmbG9hdCB0bXB2YXJfMTtcXG4gIHRtcHZhcl8xID0gKCgyLjAgLSBmbG9hdChcXG4gICAgKHVfem9vbSA+PSBhX2RhdGEyLngpXFxuICApKSAtICgxLjAgLSBmbG9hdChcXG4gICAgKHVfem9vbSA+PSBhX2RhdGEyLnkpXFxuICApKSk7XFxuICBmbG9hdCB0bXB2YXJfMjtcXG4gIHRtcHZhcl8yID0gY2xhbXAgKCgodV9mYWRlem9vbSAtIGFfZGF0YTEueikgLyB1X2ZhZGVkaXN0KSwgMC4wLCAxLjApO1xcbiAgaWYgKCh1X2ZhZGVkaXN0ID49IDAuMCkpIHtcXG4gICAgYiA9IHRtcHZhcl8yO1xcbiAgfSBlbHNlIHtcXG4gICAgYiA9ICgxLjAgLSB0bXB2YXJfMik7XFxuICB9O1xcbiAgaWYgKCh1X21heGZhZGV6b29tIDwgYV9kYXRhMS56KSkge1xcbiAgICBiID0gMC4wO1xcbiAgfTtcXG4gIGlmICgodV9taW5mYWRlem9vbSA+PSBhX2RhdGExLnopKSB7XFxuICAgIGIgPSAxLjA7XFxuICB9O1xcbiAgZmxvYXQgdG1wdmFyXzM7XFxuICB0bXB2YXJfMyA9ICh0bXB2YXJfMSArIGZsb2F0KCgwLjAgPj0gYikpKTtcXG4gIGlmICh1X3NrZXdlZCkge1xcbiAgICB2ZWM0IHRtcHZhcl80O1xcbiAgICB0bXB2YXJfNC56dyA9IHZlYzIoMC4wLCAwLjApO1xcbiAgICB0bXB2YXJfNC54eSA9IChhX29mZnNldCAvIDY0LjApO1xcbiAgICB2ZWM0IHRtcHZhcl81O1xcbiAgICB0bXB2YXJfNS56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgICB0bXB2YXJfNS54eSA9IChhX3BvcyArICh1X2V4bWF0cml4ICogdG1wdmFyXzQpLnh5KTtcXG4gICAgdmVjNCB0bXB2YXJfNjtcXG4gICAgdG1wdmFyXzYgPSAodV9tYXRyaXggKiB0bXB2YXJfNSk7XFxuICAgIGdsX1Bvc2l0aW9uLnh5dyA9IHRtcHZhcl82Lnh5dztcXG4gICAgZ2xfUG9zaXRpb24ueiA9ICh0bXB2YXJfNi56ICsgKHRtcHZhcl8zICogdG1wdmFyXzYudykpO1xcbiAgfSBlbHNlIHtcXG4gICAgdmVjNCB0bXB2YXJfNztcXG4gICAgdG1wdmFyXzcudyA9IDAuMDtcXG4gICAgdG1wdmFyXzcueHkgPSAoYV9vZmZzZXQgLyA2NC4wKTtcXG4gICAgdG1wdmFyXzcueiA9IHRtcHZhcl8zO1xcbiAgICB2ZWM0IHRtcHZhcl84O1xcbiAgICB0bXB2YXJfOC56dyA9IHZlYzIoMC4wLCAxLjApO1xcbiAgICB0bXB2YXJfOC54eSA9IGFfcG9zO1xcbiAgICBnbF9Qb3NpdGlvbiA9ICgodV9tYXRyaXggKiB0bXB2YXJfOCkgKyAodV9leG1hdHJpeCAqIHRtcHZhcl83KSk7XFxuICB9O1xcbiAgYSA9IChhX2RhdGExLnh5IC8gdV90ZXhzaXplKTtcXG4gIGIgPSAoYiAqIHVfb3BhY2l0eSk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudm9pZCBtYWluICgpXFxue1xcbiAgbG93cCB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAodGV4dHVyZTJEICh1X3RleHR1cmUsIGEpICogYik7XFxuICBnbF9GcmFnQ29sb3IgPSB0bXB2YXJfMTtcXG59XFxuXFxuXCJ9LFxuICAgIFwic2RmXCI6IHtcInZlcnRleFwiOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhMTtcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGEyO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1hdDQgdV9leG1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZWRpc3Q7XFxudW5pZm9ybSBmbG9hdCB1X21pbmZhZGV6b29tO1xcbnVuaWZvcm0gZmxvYXQgdV9tYXhmYWRlem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZXpvb207XFxudW5pZm9ybSBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gYm9vbCB1X3NrZXdlZDtcXG51bmlmb3JtIHZlYzIgdV90ZXhzaXplO1xcbnZhcnlpbmcgdmVjMiBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IGM7XFxudm9pZCBtYWluICgpXFxue1xcbiAgZmxvYXQgdG1wdmFyXzE7XFxuICB0bXB2YXJfMSA9ICgoMi4wIC0gZmxvYXQoXFxuICAgICh1X3pvb20gPj0gYV9kYXRhMi54KVxcbiAgKSkgLSAoMS4wIC0gZmxvYXQoXFxuICAgICh1X3pvb20gPj0gYV9kYXRhMi55KVxcbiAgKSkpO1xcbiAgZmxvYXQgdG1wdmFyXzI7XFxuICB0bXB2YXJfMiA9IGNsYW1wICgoKHVfZmFkZXpvb20gLSBhX2RhdGExLnopIC8gdV9mYWRlZGlzdCksIDAuMCwgMS4wKTtcXG4gIGlmICgodV9mYWRlZGlzdCA+PSAwLjApKSB7XFxuICAgIGIgPSB0bXB2YXJfMjtcXG4gIH0gZWxzZSB7XFxuICAgIGIgPSAoMS4wIC0gdG1wdmFyXzIpO1xcbiAgfTtcXG4gIGlmICgodV9tYXhmYWRlem9vbSA8IGFfZGF0YTEueikpIHtcXG4gICAgYiA9IDAuMDtcXG4gIH07XFxuICBpZiAoKHVfbWluZmFkZXpvb20gPj0gYV9kYXRhMS56KSkge1xcbiAgICBiID0gMS4wO1xcbiAgfTtcXG4gIGZsb2F0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSAodG1wdmFyXzEgKyBmbG9hdCgoMC4wID49IGIpKSk7XFxuICBpZiAodV9za2V3ZWQpIHtcXG4gICAgdmVjNCB0bXB2YXJfNDtcXG4gICAgdG1wdmFyXzQuencgPSB2ZWMyKDAuMCwgMC4wKTtcXG4gICAgdG1wdmFyXzQueHkgPSAoYV9vZmZzZXQgLyA2NC4wKTtcXG4gICAgdmVjNCB0bXB2YXJfNTtcXG4gICAgdG1wdmFyXzUuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gICAgdG1wdmFyXzUueHkgPSAoYV9wb3MgKyAodV9leG1hdHJpeCAqIHRtcHZhcl80KS54eSk7XFxuICAgIHZlYzQgdG1wdmFyXzY7XFxuICAgIHRtcHZhcl82ID0gKHVfbWF0cml4ICogdG1wdmFyXzUpO1xcbiAgICBnbF9Qb3NpdGlvbi54eXcgPSB0bXB2YXJfNi54eXc7XFxuICAgIGdsX1Bvc2l0aW9uLnogPSAodG1wdmFyXzYueiArICh0bXB2YXJfMyAqIHRtcHZhcl82LncpKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZlYzQgdG1wdmFyXzc7XFxuICAgIHRtcHZhcl83LncgPSAwLjA7XFxuICAgIHRtcHZhcl83Lnh5ID0gKGFfb2Zmc2V0IC8gNjQuMCk7XFxuICAgIHRtcHZhcl83LnogPSB0bXB2YXJfMztcXG4gICAgdmVjNCB0bXB2YXJfODtcXG4gICAgdG1wdmFyXzguencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gICAgdG1wdmFyXzgueHkgPSBhX3BvcztcXG4gICAgZ2xfUG9zaXRpb24gPSAoKHVfbWF0cml4ICogdG1wdmFyXzgpICsgKHVfZXhtYXRyaXggKiB0bXB2YXJfNykpO1xcbiAgfTtcXG4gIGMgPSAoMS4wLygoMS4wIC0gKFxcbiAgICAoZ2xfUG9zaXRpb24ueSAvIGdsX1Bvc2l0aW9uLncpXFxuICAgKiB1X2V4dHJhKSkpKTtcXG4gIGEgPSAoYV9kYXRhMS54eSAvIHVfdGV4c2l6ZSk7XFxufVxcblxcblwiLFwiZnJhZ21lbnRcIjpcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfYnVmZmVyO1xcbnVuaWZvcm0gZmxvYXQgdV9nYW1tYTtcXG52YXJ5aW5nIHZlYzIgYTtcXG52YXJ5aW5nIGZsb2F0IGI7XFxudmFyeWluZyBmbG9hdCBjO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGZsb2F0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEgPSAodV9nYW1tYSAqIGMpO1xcbiAgZmxvYXQgZWRnZTBfMjtcXG4gIGVkZ2UwXzIgPSAodV9idWZmZXIgLSB0bXB2YXJfMSk7XFxuICBsb3dwIGZsb2F0IHRtcHZhcl8zO1xcbiAgdG1wdmFyXzMgPSBjbGFtcCAoKCh0ZXh0dXJlMkQgKHVfdGV4dHVyZSwgYSkudyAtIGVkZ2UwXzIpIC8gKFxcbiAgICAodV9idWZmZXIgKyB0bXB2YXJfMSlcXG4gICAtIGVkZ2UwXzIpKSwgMC4wLCAxLjApO1xcbiAgbG93cCB2ZWM0IHRtcHZhcl80O1xcbiAgdG1wdmFyXzQgPSAodV9jb2xvciAqICgodG1wdmFyXzMgKiBcXG4gICAgKHRtcHZhcl8zICogKDMuMCAtICgyLjAgKiB0bXB2YXJfMykpKVxcbiAgKSAqIGIpKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHRtcHZhcl80O1xcbn1cXG5cXG5cIn0sXG4gICAgXCJjb2xsaXNpb25ib3hcIjoge1widmVydGV4XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX2V4dHJ1ZGU7XFxuYXR0cmlidXRlIHZlYzIgYV9kYXRhO1xcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxudmFyeWluZyBmbG9hdCBhO1xcbnZhcnlpbmcgZmxvYXQgYjtcXG52b2lkIG1haW4gKClcXG57XFxuICB2ZWM0IHRtcHZhcl8xO1xcbiAgdG1wdmFyXzEuencgPSB2ZWMyKDAuMCwgMS4wKTtcXG4gIHRtcHZhcl8xLnh5ID0gKGFfcG9zICsgKGFfZXh0cnVkZSAvIHVfc2NhbGUpKTtcXG4gIGdsX1Bvc2l0aW9uID0gKHVfbWF0cml4ICogdG1wdmFyXzEpO1xcbiAgYSA9IGFfZGF0YS54O1xcbiAgYiA9IGFfZGF0YS55O1xcbn1cXG5cXG5cIixcImZyYWdtZW50XCI6XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGZsb2F0IHVfem9vbTtcXG51bmlmb3JtIGZsb2F0IHVfbWF4em9vbTtcXG52YXJ5aW5nIGZsb2F0IGE7XFxudmFyeWluZyBmbG9hdCBiO1xcbnZvaWQgbWFpbiAoKVxcbntcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjUsIDAuMCwgMC41KTtcXG4gIGlmICgoYiA+IHVfem9vbSkpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjUsIDAuMCwgMC4wLCAwLjUpO1xcbiAgfTtcXG4gIGlmICgodV96b29tID49IGEpKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4xMjUpO1xcbiAgfTtcXG4gIGlmICgoYiA+PSB1X21heHpvb20pKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMSwgMC4xKTtcXG4gIH07XFxufVxcblxcblwifVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuL3RpbGVfcHlyYW1pZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTlNvdXJjZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBHZW9KU09OIGRhdGEgc291cmNlIGluc3RhbmNlIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0XG4gKiBAY2xhc3MgR2VvSlNPTlNvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBvcHRpb25zLmRhdGEgQSBHZW9KU09OIGRhdGEgb2JqZWN0IG9yIFVSTCB0byBpdC4gVGhlIGxhdHRlciBpcyBwcmVmZXJhYmxlIGluIGNhc2Ugb2YgbGFyZ2UgR2VvSlNPTiBmaWxlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXh6b29tPTE0XSBNYXhpbXVtIHpvb20gdG8gcHJlc2VydmUgZGV0YWlsIGF0LlxuICogQGV4YW1wbGVcbiAqIHZhciBzb3VyY2VPYmogPSBuZXcgbWFwYm94Z2wuR2VvSlNPTlNvdXJjZSh7XG4gKiAgICBkYXRhOiB7XG4gKiAgICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgICAgICBcImZlYXR1cmVzXCI6IFt7XG4gKiAgICAgICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICAgICAgICAgICAgICAgLTc2LjUzMDYzMjk3MjcxNzI5LFxuICogICAgICAgICAgICAgICAgICAgIDM5LjE4MTc0MDc3OTk0MTA4XG4gKiAgICAgICAgICAgICAgICBdXG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICB9XVxuICogICAgfVxuICogfSk7XG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywgc291cmNlT2JqKTsgLy8gYWRkXG4gKiBtYXAucmVtb3ZlU291cmNlKCdzb21lIGlkJyk7ICAvLyByZW1vdmVcbiAqL1xuZnVuY3Rpb24gR2VvSlNPTlNvdXJjZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl9kYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4em9vbSAhPT0gdW5kZWZpbmVkKSB0aGlzLm1heHpvb20gPSBvcHRpb25zLm1heHpvb207XG5cbiAgICB0aGlzLl9weXJhbWlkID0gbmV3IFRpbGVQeXJhbWlkKHtcbiAgICAgICAgdGlsZVNpemU6IDUxMixcbiAgICAgICAgbWluem9vbTogdGhpcy5taW56b29tLFxuICAgICAgICBtYXh6b29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgIGNhY2hlU2l6ZTogMjAsXG4gICAgICAgIGxvYWQ6IHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIGFib3J0OiB0aGlzLl9hYm9ydFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgdW5sb2FkOiB0aGlzLl91bmxvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgIGFkZDogdGhpcy5fYWRkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICByZW1vdmU6IHRoaXMuX3JlbW92ZVRpbGUuYmluZCh0aGlzKVxuICAgIH0pO1xufVxuXG5HZW9KU09OU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIEdlb0pTT05Tb3VyY2UucHJvdG90eXBlICove1xuICAgIG1pbnpvb206IDAsXG4gICAgbWF4em9vbTogMTQsXG4gICAgX2RpcnR5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNvdXJjZSBnZW9qc29uIGRhdGEgYW5kIHJlcmVuZGVyIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIEEgR2VvSlNPTiBkYXRhIG9iamVjdCBvciBVUkwgdG8gaXQuIFRoZSBsYXR0ZXIgaXMgcHJlZmVyYWJsZSBpbiBjYXNlIG9mIGxhcmdlIEdlb0pTT04gZmlsZXMuXG4gICAgICogQHJldHVybnMge0dlb0pTT05Tb3VyY2V9IHRoaXNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcblxuICAgICAgICBpZiAodGhpcy5tYXApXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLm1hcC50cmFuc2Zvcm0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH0sXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkICYmIHRoaXMuX3B5cmFtaWQubG9hZGVkKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGF0YSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC51cGRhdGUodGhpcy51c2VkLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3B5cmFtaWQucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogU291cmNlLl9yZW5kZXJUaWxlcyxcbiAgICBmZWF0dXJlc0F0OiBTb3VyY2UuX3ZlY3RvckZlYXR1cmVzQXQsXG5cbiAgICBfdXBkYXRlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy53b3JrZXJJRCA9IHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdwYXJzZSBnZW9qc29uJywge1xuICAgICAgICAgICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHRpbGVTaXplOiA1MTIsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICBtYXhab29tOiB0aGlzLm1heHpvb21cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcHlyYW1pZC5yZWxvYWQoKTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX2xvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHZhciBvdmVyc2NhbGluZyA9IHRpbGUuem9vbSA+IHRoaXMubWF4em9vbSA/IE1hdGgucG93KDIsIHRpbGUuem9vbSAtIHRoaXMubWF4em9vbSkgOiAxO1xuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgICAgdWlkOiB0aWxlLnVpZCxcbiAgICAgICAgICAgIGlkOiB0aWxlLmlkLFxuICAgICAgICAgICAgem9vbTogdGlsZS56b29tLFxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgICAgdGlsZVNpemU6IDUxMixcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLm1hcC50cmFuc2Zvcm0uYW5nbGUsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgY29sbGlzaW9uRGVidWc6IHRoaXMubWFwLmNvbGxpc2lvbkRlYnVnXG4gICAgICAgIH07XG5cbiAgICAgICAgdGlsZS53b3JrZXJJRCA9IHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdsb2FkIGdlb2pzb24gdGlsZScsIHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cbiAgICAgICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcblxuICAgICAgICAgICAgaWYgKHRpbGUuYWJvcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuZXJyb3InLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlsZS5sb2FkVmVjdG9yRGF0YShkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRpbGV9KTtcblxuICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfYWJvcnRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUuYWJvcnRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIF9hZGRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgndGlsZS5hZGQnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUucmVtb3ZlJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3VubG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS51bmxvYWRWZWN0b3JEYXRhKHRoaXMubWFwLnBhaW50ZXIpO1xuICAgICAgICB0aGlzLmdseXBoQXRsYXMucmVtb3ZlR2x5cGhzKHRpbGUudWlkKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3JlbW92ZSB0aWxlJywgeyB1aWQ6IHRpbGUudWlkLCBzb3VyY2U6IHRoaXMuaWQgfSwgbnVsbCwgdGlsZS53b3JrZXJJRCk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpLlZlY3RvclRpbGVGZWF0dXJlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb0pTT05XcmFwcGVyO1xuXG4vLyBjb25mb3JtIHRvIHZlY3RvcnRpbGUgYXBpXG5mdW5jdGlvbiBHZW9KU09OV3JhcHBlcihmZWF0dXJlcykge1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICB0aGlzLmxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aDtcbn1cblxuR2VvSlNPTldyYXBwZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIG5ldyBGZWF0dXJlV3JhcHBlcih0aGlzLmZlYXR1cmVzW2ldKTtcbn07XG5cbmZ1bmN0aW9uIEZlYXR1cmVXcmFwcGVyKGZlYXR1cmUpIHtcbiAgICB0aGlzLnR5cGUgPSBmZWF0dXJlLnR5cGU7XG4gICAgdGhpcy5yYXdHZW9tZXRyeSA9IGZlYXR1cmUudHlwZSA9PT0gMSA/IFtmZWF0dXJlLmdlb21ldHJ5XSA6IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gZmVhdHVyZS50YWdzO1xuICAgIHRoaXMuZXh0ZW50ID0gNDA5Njtcbn1cblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByaW5ncyA9IHRoaXMucmF3R2VvbWV0cnk7XG4gICAgdGhpcy5nZW9tZXRyeSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldLFxuICAgICAgICAgICAgbmV3UmluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG5ld1JpbmcucHVzaChuZXcgUG9pbnQocmluZ1tqXVswXSwgcmluZ1tqXVsxXSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkucHVzaChuZXdSaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnk7XG59O1xuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5nZW9tZXRyeSkgdGhpcy5sb2FkR2VvbWV0cnkoKTtcblxuICAgIHZhciByaW5ncyA9IHRoaXMuZ2VvbWV0cnksXG4gICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IHJpbmdbal07XG5cbiAgICAgICAgICAgIHgxID0gTWF0aC5taW4oeDEsIGNvb3JkLngpO1xuICAgICAgICAgICAgeDIgPSBNYXRoLm1heCh4MiwgY29vcmQueCk7XG4gICAgICAgICAgICB5MSA9IE1hdGgubWluKHkxLCBjb29yZC55KTtcbiAgICAgICAgICAgIHkyID0gTWF0aC5tYXgoeTIsIGNvb3JkLnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG59O1xuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUudG9HZW9KU09OID0gVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLnRvR2VvSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVUaWxlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFJhc3RlclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5SYXN0ZXJUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B5cmFtaWQgJiYgdGhpcy5fcHlyYW1pZC5sb2FkZWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3B5cmFtaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQudXBkYXRlKHRoaXMudXNlZCwgdHJhbnNmb3JtLCB0aGlzLm1hcC5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcjogU291cmNlLl9yZW5kZXJUaWxlcyxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICBhamF4LmdldEltYWdlKG5vcm1hbGl6ZVVSTChUaWxlQ29vcmQudXJsKHRpbGUuaWQsIHRoaXMudGlsZXMpLCB0aGlzLnVybCksIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5lcnJvcicsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLm1hcC5wYWludGVyLmdsO1xuICAgICAgICAgICAgdGlsZS50ZXh0dXJlID0gdGhpcy5tYXAucGFpbnRlci5nZXRUZXh0dXJlKGltZy53aWR0aCk7XG4gICAgICAgICAgICBpZiAodGlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcbiAgICAgICAgICAgICAgICB0aWxlLnRleHR1cmUuc2l6ZSA9IGltZy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuXG4gICAgICAgICAgICB0aWxlLnRpbWVBZGRlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXAuYW5pbWF0aW9uTG9vcC5zZXQodGhpcy5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb24pO1xuXG4gICAgICAgICAgICB0aWxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgICAgICB0aWxlLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnRleHR1cmUpIHRoaXMubWFwLnBhaW50ZXIuc2F2ZVRleHR1cmUodGlsZS50ZXh0dXJlKTtcbiAgICB9LFxuXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG52YXIgVGlsZVB5cmFtaWQgPSByZXF1aXJlKCcuL3RpbGVfcHlyYW1pZCcpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU291cmNlVVJMO1xuXG5leHBvcnRzLl9sb2FkVGlsZUpTT04gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGVyciwgdGlsZUpTT04pIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1dGlsLmV4dGVuZCh0aGlzLCB1dGlsLnBpY2sodGlsZUpTT04sXG4gICAgICAgICAgICBbJ3RpbGVzJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdhdHRyaWJ1dGlvbiddKSk7XG5cbiAgICAgICAgdGhpcy5fcHlyYW1pZCA9IG5ldyBUaWxlUHlyYW1pZCh7XG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgICAgIGNhY2hlU2l6ZTogMjAsXG4gICAgICAgICAgICBtaW56b29tOiB0aGlzLm1pbnpvb20sXG4gICAgICAgICAgICBtYXh6b29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgICAgICByZXBhcnNlT3ZlcnNjYWxlZDogdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCxcbiAgICAgICAgICAgIGxvYWQ6IHRoaXMuX2xvYWRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhYm9ydDogdGhpcy5fYWJvcnRUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmxvYWQ6IHRoaXMuX3VubG9hZFRpbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGFkZDogdGhpcy5fYWRkVGlsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVtb3ZlOiB0aGlzLl9yZW1vdmVUaWxlLmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWRvUGxhY2VtZW50OiB0aGlzLl9yZWRvVGlsZVBsYWNlbWVudCA/IHRoaXMuX3JlZG9UaWxlUGxhY2VtZW50LmJpbmQodGhpcykgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwob3B0aW9ucy51cmwpLCBsb2FkZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXIuZnJhbWUobG9hZGVkLmJpbmQodGhpcywgbnVsbCwgb3B0aW9ucykpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuX3JlbmRlclRpbGVzID0gZnVuY3Rpb24obGF5ZXJzLCBwYWludGVyKSB7XG4gICAgaWYgKCF0aGlzLl9weXJhbWlkKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgaWRzID0gdGhpcy5fcHlyYW1pZC5yZW5kZXJlZElEcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkc1tpXSksXG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fcHlyYW1pZC5nZXRUaWxlKGlkc1tpXSksXG4gICAgICAgICAgICB6ID0gcG9zLnosXG4gICAgICAgICAgICB4ID0gcG9zLngsXG4gICAgICAgICAgICB5ID0gcG9zLnksXG4gICAgICAgICAgICB3ID0gcG9zLnc7XG5cbiAgICAgICAgLy8gaWYgeiA+IG1heHpvb20gdGhlbiB0aGUgdGlsZSBpcyBhY3R1YWxseSBhIG92ZXJzY2FsZWQgbWF4em9vbSB0aWxlLFxuICAgICAgICAvLyBzbyBjYWxjdWxhdGUgdGhlIG1hdHJpeCB0aGUgbWF4em9vbSB0aWxlIHdvdWxkIHVzZS5cbiAgICAgICAgeiA9IE1hdGgubWluKHosIHRoaXMubWF4em9vbSk7XG5cbiAgICAgICAgeCArPSB3ICogKDEgPDwgeik7XG4gICAgICAgIHRpbGUuY2FsY3VsYXRlTWF0cmljZXMoeiwgeCwgeSwgcGFpbnRlci50cmFuc2Zvcm0sIHBhaW50ZXIpO1xuXG4gICAgICAgIHBhaW50ZXIuZHJhd1RpbGUodGlsZSwgbGF5ZXJzKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLl92ZWN0b3JGZWF0dXJlc0F0ID0gZnVuY3Rpb24oY29vcmQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3B5cmFtaWQpXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHlyYW1pZC50aWxlQXQoY29vcmQpO1xuICAgIGlmICghcmVzdWx0KVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pO1xuXG4gICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ3F1ZXJ5IGZlYXR1cmVzJywge1xuICAgICAgICB1aWQ6IHJlc3VsdC50aWxlLnVpZCxcbiAgICAgICAgeDogcmVzdWx0LngsXG4gICAgICAgIHk6IHJlc3VsdC55LFxuICAgICAgICBzY2FsZTogcmVzdWx0LnNjYWxlLFxuICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfSwgY2FsbGJhY2ssIHJlc3VsdC50aWxlLndvcmtlcklEKTtcbn07XG5cbi8qXG4gKiBDcmVhdGUgYSB0aWxlZCBkYXRhIHNvdXJjZSBpbnN0YW5jZSBnaXZlbiBhbiBvcHRpb25zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50eXBlIEVpdGhlciBgcmFzdGVyYCBvciBgdmVjdG9yYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVybCBBIHRpbGUgc291cmNlIFVSTC4gVGhpcyBzaG91bGQgZWl0aGVyIGJlIGBtYXBib3g6Ly97bWFwaWR9YCBvciBhIGZ1bGwgYGh0dHBbc11gIHVybCB0aGF0IHBvaW50cyB0byBhIFRpbGVKU09OIGVuZHBvaW50LlxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy50aWxlcyBBbiBhcnJheSBvZiB0aWxlIHNvdXJjZXMuIElmIGB1cmxgIGlzIG5vdCBzcGVjaWZpZWQsIGB0aWxlc2AgY2FuIGJlIHVzZWQgaW5zdGVhZCB0byBzcGVjaWZ5IHRpbGUgc291cmNlcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIE90aGVyIFRpbGVKU09OIGtleXMgc3VjaCBhcyBgbWluem9vbWAgYW5kIGBtYXh6b29tYCBjYW4gYmUgc3BlY2lmaWVkIGluIGEgc291cmNlIG9iamVjdCBpZiBgdGlsZXNgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5pZCBBbiBvcHRpb25hbCBgaWRgIHRvIGFzc2lnbiB0byB0aGUgc291cmNlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGlsZVNpemU9NTEyXSBPcHRpb25hbCB0aWxlIHNpemUgKHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLCBhc3N1bWluZyB0aWxlcyBhcmUgc3F1YXJlKS4gVGhpcyBvcHRpb24gaXMgb25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBzb3VyY2VzXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jYWNoZVNpemUgT3B0aW9uYWwgbWF4IG51bWJlciBvZiB0aWxlcyB0byBjYWNoZSBhdCBhbnkgZ2l2ZW4gdGltZVxuICogQGV4YW1wbGVcbiAqIHZhciBzb3VyY2VPYmogPSBuZXcgbWFwYm94Z2wuU291cmNlLmNyZWF0ZSh7XG4gKiAgICB0eXBlOiAndmVjdG9yJyxcbiAqICAgIHVybDogJ21hcGJveDovL21hcGJveC5tYXBib3gtc3RyZWV0cy12NSdcbiAqIH0pO1xuICogbWFwLmFkZFNvdXJjZSgnc29tZSBpZCcsIHNvdXJjZU9iaik7IC8vIGFkZFxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYXQgZmlsZSBzY29wZSBpbiBvcmRlciB0byBhdm9pZCBhIGNpcmN1bGFyIHJlcXVpcmUuXG4gICAgdmFyIHNvdXJjZXMgPSB7XG4gICAgICAgIHZlY3RvcjogcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV9zb3VyY2UnKSxcbiAgICAgICAgcmFzdGVyOiByZXF1aXJlKCcuL3Jhc3Rlcl90aWxlX3NvdXJjZScpLFxuICAgICAgICBnZW9qc29uOiByZXF1aXJlKCcuL2dlb2pzb25fc291cmNlJyksXG4gICAgICAgIHZpZGVvOiByZXF1aXJlKCcuL3ZpZGVvX3NvdXJjZScpXG4gICAgfTtcblxuICAgIGZvciAodmFyIHR5cGUgaW4gc291cmNlcykge1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2Ygc291cmNlc1t0eXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgc291cmNlc1tzb3VyY2UudHlwZV0oc291cmNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG1hdHJpeCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpO1xudmFyIG1hdDIgPSBnbG1hdHJpeC5tYXQyO1xudmFyIG1hdDQgPSBnbG1hdHJpeC5tYXQ0O1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBCdWZmZXJTZXQgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlci9idWZmZXJfc2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGlsZTtcblxuZnVuY3Rpb24gVGlsZShpZCwgc2l6ZSkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnVpZCA9IHV0aWwudW5pcXVlSWQoKTtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuem9vbSA9IFRpbGVDb29yZC5mcm9tSUQoaWQpLno7XG4gICAgdGhpcy51c2VzID0gMDtcbiAgICB0aGlzLnRpbGVTaXplID0gc2l6ZTtcbn1cblxuVGlsZS5wcm90b3R5cGUgPSB7XG4gICAgLy8gdG9kbyB1bmhhcmRjb2RlXG4gICAgdGlsZUV4dGVudDogNDA5NixcblxuICAgIGNhbGN1bGF0ZU1hdHJpY2VzOiBmdW5jdGlvbih6LCB4LCB5LCB0cmFuc2Zvcm0pIHtcblxuICAgICAgICAvLyBJbml0aWFsaXplIG1vZGVsLXZpZXcgbWF0cml4IHRoYXQgY29udmVydHMgZnJvbSB0aGUgdGlsZSBjb29yZGluYXRlc1xuICAgICAgICAvLyB0byBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgICAgIHZhciB0aWxlU2NhbGUgPSBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgdmFyIHNjYWxlID0gdHJhbnNmb3JtLndvcmxkU2l6ZSAvIHRpbGVTY2FsZTtcblxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBtYXRyaXhcbiAgICAgICAgdGhpcy5wb3NNYXRyaXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgICAgICAgbWF0NC5pZGVudGl0eSh0aGlzLnBvc01hdHJpeCk7XG4gICAgICAgIG1hdDQudHJhbnNsYXRlKHRoaXMucG9zTWF0cml4LCB0aGlzLnBvc01hdHJpeCwgW3ggKiBzY2FsZSwgeSAqIHNjYWxlLCAwXSk7XG5cbiAgICAgICAgbWF0NC5zY2FsZSh0aGlzLnBvc01hdHJpeCwgdGhpcy5wb3NNYXRyaXgsIFsgc2NhbGUgLyB0aGlzLnRpbGVFeHRlbnQsIHNjYWxlIC8gdGhpcy50aWxlRXh0ZW50LCAxIF0pO1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KHRoaXMucG9zTWF0cml4LCB0cmFuc2Zvcm0uZ2V0UHJvak1hdHJpeCgpLCB0aGlzLnBvc01hdHJpeCk7XG5cbiAgICAgICAgLy8gVGhlIGV4dHJ1c2lvbiBtYXRyaXguXG4gICAgICAgIHRoaXMuZXhNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0Lm9ydGhvKHRoaXMuZXhNYXRyaXgsIDAsIHRyYW5zZm9ybS53aWR0aCwgdHJhbnNmb3JtLmhlaWdodCwgMCwgMCwgLTEpO1xuICAgICAgICAvL21hdDQucm90YXRlWih0aGlzLmV4TWF0cml4LCB0aGlzLmV4TWF0cml4LCAtdHJhbnNmb3JtLmFuZ2xlKTtcblxuICAgICAgICAvLyAyeDIgbWF0cml4IGZvciByb3RhdGluZyBwb2ludHNcbiAgICAgICAgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IG1hdDIuY3JlYXRlKCk7XG4gICAgICAgIG1hdDIucm90YXRlKHRoaXMucm90YXRpb25NYXRyaXgsIHRoaXMucm90YXRpb25NYXRyaXgsIHRyYW5zZm9ybS5hbmdsZSk7XG5cbiAgICAgICAgdGhpcy5wb3NNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucG9zTWF0cml4KTtcbiAgICB9LFxuXG4gICAgcG9zaXRpb25BdDogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgY29vcmQgPSBjb29yZC56b29tVG8odGhpcy56b29tKTtcbiAgICAgICAgdmFyIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQodGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoY29vcmQuY29sdW1uIC0gcG9zLngpICogNDA5NixcbiAgICAgICAgICAgIHk6IChjb29yZC5yb3cgLSBwb3MueSkgKiA0MDk2LFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGVtcHR5IEdlb0pTT04gdGlsZVxuICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcblxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KGRhdGEuYnVmZmVycyk7XG4gICAgICAgIHRoaXMuZWxlbWVudEdyb3VwcyA9IGRhdGEuZWxlbWVudEdyb3VwcztcbiAgICB9LFxuXG4gICAgcmVsb2FkU3ltYm9sRGF0YTogZnVuY3Rpb24oZGF0YSwgcGFpbnRlcikge1xuXG4gICAgICAgIGlmICghdGhpcy5idWZmZXJzKSB7XG4gICAgICAgICAgICAvLyB0aGUgdGlsZSBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnVmZmVycy5nbHlwaFZlcnRleC5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuZ2x5cGhFbGVtZW50LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5pY29uVmVydGV4LmRlc3Ryb3kocGFpbnRlci5nbCk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5pY29uRWxlbWVudC5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4LmRlc3Ryb3kocGFpbnRlci5nbCk7XG5cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KGRhdGEuYnVmZmVycyk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5nbHlwaFZlcnRleCA9IGJ1ZmZlcnMuZ2x5cGhWZXJ0ZXg7XG4gICAgICAgIHRoaXMuYnVmZmVycy5nbHlwaEVsZW1lbnQgPSBidWZmZXJzLmdseXBoRWxlbWVudDtcbiAgICAgICAgdGhpcy5idWZmZXJzLmljb25WZXJ0ZXggPSBidWZmZXJzLmljb25WZXJ0ZXg7XG4gICAgICAgIHRoaXMuYnVmZmVycy5pY29uRWxlbWVudCA9IGJ1ZmZlcnMuaWNvbkVsZW1lbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jb2xsaXNpb25Cb3hWZXJ0ZXggPSBidWZmZXJzLmNvbGxpc2lvbkJveFZlcnRleDtcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiBkYXRhLmVsZW1lbnRHcm91cHMpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudEdyb3Vwc1tpZF0gPSBkYXRhLmVsZW1lbnRHcm91cHNbaWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVubG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKHBhaW50ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgYiBpbiB0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyc1tiXS5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIFRpbGVzIGFyZSBnZW5lcmFsbHkgcmVwcmVzZW50ZWQgYXMgcGFja2VkIGludGVnZXIgaWRzIGNvbnN0cnVjdGVkIGJ5XG4gKiBgVGlsZUNvb3JkLnRvSUQoeCwgeSwgeilgXG4gKi9cblxudmFyIFRpbGVDb29yZCA9IGV4cG9ydHM7XG5cblRpbGVDb29yZC50b0lEID0gZnVuY3Rpb24oeiwgeCwgeSwgdykge1xuICAgIHcgPSB3IHx8IDA7XG4gICAgdyAqPSAyO1xuICAgIGlmICh3IDwgMCkgdyA9IHcgKiAtMSAtIDE7XG4gICAgdmFyIGRpbSA9IDEgPDwgejtcbiAgICByZXR1cm4gKChkaW0gKiBkaW0gKiB3ICsgZGltICogeSArIHgpICogMzIpICsgejtcbn07XG5cblRpbGVDb29yZC5hc1N0cmluZyA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHBvcyA9IFRpbGVDb29yZC5mcm9tSUQoaWQpO1xuICAgIHJldHVybiBwb3MueiArIFwiL1wiICsgcG9zLnggKyBcIi9cIiArIHBvcy55O1xufTtcblxuLypcbiAqIFBhcnNlIGEgcGFja2VkIGludGVnZXIgaWQgaW50byBhbiBvYmplY3Qgd2l0aCB4LCB5LCBhbmQgeiBwcm9wZXJ0aWVzXG4gKi9cblRpbGVDb29yZC5mcm9tSUQgPSBmdW5jdGlvbihpZCkge1xuICAgIHZhciB6ID0gaWQgJSAzMiwgZGltID0gMSA8PCB6O1xuICAgIHZhciB4eSA9ICgoaWQgLSB6KSAvIDMyKTtcbiAgICB2YXIgeCA9IHh5ICUgZGltLCB5ID0gKCh4eSAtIHgpIC8gZGltKSAlIGRpbTtcbiAgICB2YXIgdyA9IE1hdGguZmxvb3IoeHkgLyAoZGltICogZGltKSk7XG4gICAgaWYgKHcgJSAyICE9PSAwKSB3ID0gdyAqIC0xIC0gMTtcbiAgICB3IC89IDI7XG4gICAgcmV0dXJuIHsgejogeiwgeDogeCwgeTogeSwgdzogdyB9O1xufTtcblxuLypcbiAqIEdpdmVuIGEgcGFja2VkIGludGVnZXIgaWQsIHJldHVybiBpdHMgem9vbSBsZXZlbFxuICovXG5UaWxlQ29vcmQuem9vbSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIGlkICUgMzI7XG59O1xuXG4vLyBHaXZlbiBhbiBpZCBhbmQgYSBsaXN0IG9mIHVybHMsIGNob29zZSBhIHVybCB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgdGlsZSBVUkxcblRpbGVDb29yZC51cmwgPSBmdW5jdGlvbihpZCwgdXJscywgc291cmNlTWF4Wm9vbSkge1xuICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcblxuICAgIHJldHVybiB1cmxzWyhwb3MueCArIHBvcy55KSAlIHVybHMubGVuZ3RoXVxuICAgICAgICAucmVwbGFjZSgne3ByZWZpeH0nLCAocG9zLnggJSAxNikudG9TdHJpbmcoMTYpICsgKHBvcy55ICUgMTYpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t6fScsIE1hdGgubWluKHBvcy56LCBzb3VyY2VNYXhab29tIHx8IHBvcy56KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t4fScsIHBvcy54KVxuICAgICAgICAucmVwbGFjZSgne3l9JywgcG9zLnkpO1xufTtcblxuLypcbiAqIEdpdmVuIGEgcGFja2VkIGludGVnZXIgaWQsIHJldHVybiB0aGUgaWQgb2YgaXRzIHBhcmVudCB0aWxlXG4gKi9cblRpbGVDb29yZC5wYXJlbnQgPSBmdW5jdGlvbihpZCwgc291cmNlTWF4Wm9vbSkge1xuICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICBpZiAocG9zLnogPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgLy8gdGhlIGlkIHJlcHJlc2VudHMgYW4gb3ZlcnNjYWxlZCB0aWxlLCByZXR1cm4gdGhlIHNhbWUgY29vcmRpbmF0ZXMgd2l0aCBhIGxvd2VyIHpcbiAgICBpZiAocG9zLnogPiBzb3VyY2VNYXhab29tKSB7XG4gICAgICAgIHJldHVybiBUaWxlQ29vcmQudG9JRChwb3MueiAtIDEsIHBvcy54LCBwb3MueSwgcG9zLncpO1xuICAgIH1cblxuICAgIHJldHVybiBUaWxlQ29vcmQudG9JRChwb3MueiAtIDEsIE1hdGguZmxvb3IocG9zLnggLyAyKSwgTWF0aC5mbG9vcihwb3MueSAvIDIpLCBwb3Mudyk7XG59O1xuXG5UaWxlQ29vcmQucGFyZW50V2l0aFpvb20gPSBmdW5jdGlvbihpZCwgem9vbSkge1xuICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICB3aGlsZSAocG9zLnogPiB6b29tKSB7XG4gICAgICAgIHBvcy56LS07XG4gICAgICAgIHBvcy54ID0gTWF0aC5mbG9vcihwb3MueCAvIDIpO1xuICAgICAgICBwb3MueSA9IE1hdGguZmxvb3IocG9zLnkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnksIHBvcy53KTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIHBhY2tlZCBpbnRlZ2VyIGlkLCByZXR1cm4gYW4gYXJyYXkgb2YgaW50ZWdlciBpZHMgcmVwcmVzZW50aW5nXG4gKiBpdHMgZm91ciBjaGlsZHJlbi5cbiAqL1xuVGlsZUNvb3JkLmNoaWxkcmVuID0gZnVuY3Rpb24oaWQsIHNvdXJjZU1heFpvb20pIHtcbiAgICB2YXIgcG9zID0gVGlsZUNvb3JkLmZyb21JRChpZCk7XG5cbiAgICBpZiAocG9zLnogPj0gc291cmNlTWF4Wm9vbSkge1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgdGlsZSBpZCByZXByZXNlbnRpbmcgYSBhbiBvdmVyc2NhbGVkIHRpbGVcbiAgICAgICAgcmV0dXJuIFtUaWxlQ29vcmQudG9JRChwb3MueiArIDEsIHBvcy54LCBwb3MueSwgcG9zLncpXTtcbiAgICB9XG5cbiAgICBwb3MueiArPSAxO1xuICAgIHBvcy54ICo9IDI7XG4gICAgcG9zLnkgKj0gMjtcbiAgICByZXR1cm4gW1xuICAgICAgICBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLngsIHBvcy55LCBwb3MudyksXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCArIDEsIHBvcy55LCBwb3MudyksXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCwgcG9zLnkgKyAxLCBwb3MudyksXG4gICAgICAgIFRpbGVDb29yZC50b0lEKHBvcy56LCBwb3MueCArIDEsIHBvcy55ICsgMSwgcG9zLncpXG4gICAgXTtcbn07XG5cblRpbGVDb29yZC56b29tVG8gPSBmdW5jdGlvbihjLCB6KSB7XG4gICAgYy5jb2x1bW4gPSBjLmNvbHVtbiAqIE1hdGgucG93KDIsIHogLSBjLnpvb20pO1xuICAgIGMucm93ID0gYy5yb3cgKiBNYXRoLnBvdygyLCB6IC0gYy56b29tKTtcbiAgICBjLnpvb20gPSB6O1xuICAgIHJldHVybiBjO1xufTtcblxuLy8gVGFrZW4gZnJvbSBwb2x5bWFwcyBzcmMvTGF5ZXIuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1wbGVnZW8vcG9seW1hcHMvYmxvYi9tYXN0ZXIvc3JjL0xheWVyLmpzI0wzMzMtTDM4M1xuXG5mdW5jdGlvbiBlZGdlKGEsIGIpIHtcbiAgICBpZiAoYS5yb3cgPiBiLnJvdykgeyB2YXIgdCA9IGE7IGEgPSBiOyBiID0gdDsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHgwOiBhLmNvbHVtbixcbiAgICAgICAgeTA6IGEucm93LFxuICAgICAgICB4MTogYi5jb2x1bW4sXG4gICAgICAgIHkxOiBiLnJvdyxcbiAgICAgICAgZHg6IGIuY29sdW1uIC0gYS5jb2x1bW4sXG4gICAgICAgIGR5OiBiLnJvdyAtIGEucm93XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2NhblNwYW5zKGUwLCBlMSwgeW1pbiwgeW1heCwgc2NhbkxpbmUpIHtcbiAgICB2YXIgeTAgPSBNYXRoLm1heCh5bWluLCBNYXRoLmZsb29yKGUxLnkwKSk7XG4gICAgdmFyIHkxID0gTWF0aC5taW4oeW1heCwgTWF0aC5jZWlsKGUxLnkxKSk7XG5cbiAgICAvLyBzb3J0IGVkZ2VzIGJ5IHgtY29vcmRpbmF0ZVxuICAgIGlmICgoZTAueDAgPT09IGUxLngwICYmIGUwLnkwID09PSBlMS55MCkgP1xuICAgICAgICAgICAgKGUwLngwICsgZTEuZHkgLyBlMC5keSAqIGUwLmR4IDwgZTEueDEpIDpcbiAgICAgICAgICAgIChlMC54MSAtIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngwKSkge1xuICAgICAgICB2YXIgdCA9IGUwOyBlMCA9IGUxOyBlMSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBsaW5lcyFcbiAgICB2YXIgbTAgPSBlMC5keCAvIGUwLmR5O1xuICAgIHZhciBtMSA9IGUxLmR4IC8gZTEuZHk7XG4gICAgdmFyIGQwID0gZTAuZHggPiAwOyAvLyB1c2UgeSArIDEgdG8gY29tcHV0ZSB4MFxuICAgIHZhciBkMSA9IGUxLmR4IDwgMDsgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDFcbiAgICBmb3IgKHZhciB5ID0geTA7IHkgPCB5MTsgeSsrKSB7XG4gICAgICAgIHZhciB4MCA9IG0wICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTAuZHksIHkgKyBkMCAtIGUwLnkwKSkgKyBlMC54MDtcbiAgICAgICAgdmFyIHgxID0gbTEgKiBNYXRoLm1heCgwLCBNYXRoLm1pbihlMS5keSwgeSArIGQxIC0gZTEueTApKSArIGUxLngwO1xuICAgICAgICBzY2FuTGluZShNYXRoLmZsb29yKHgxKSwgTWF0aC5jZWlsKHgwKSwgeSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzY2FuVHJpYW5nbGUoYSwgYiwgYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpIHtcbiAgICB2YXIgYWIgPSBlZGdlKGEsIGIpLFxuICAgICAgICBiYyA9IGVkZ2UoYiwgYyksXG4gICAgICAgIGNhID0gZWRnZShjLCBhKTtcblxuICAgIHZhciB0O1xuXG4gICAgLy8gc29ydCBlZGdlcyBieSB5LWxlbmd0aFxuICAgIGlmIChhYi5keSA+IGJjLmR5KSB7IHQgPSBhYjsgYWIgPSBiYzsgYmMgPSB0OyB9XG4gICAgaWYgKGFiLmR5ID4gY2EuZHkpIHsgdCA9IGFiOyBhYiA9IGNhOyBjYSA9IHQ7IH1cbiAgICBpZiAoYmMuZHkgPiBjYS5keSkgeyB0ID0gYmM7IGJjID0gY2E7IGNhID0gdDsgfVxuXG4gICAgLy8gc2NhbiBzcGFuISBzY2FuIHNwYW4hXG4gICAgaWYgKGFiLmR5KSBzY2FuU3BhbnMoY2EsIGFiLCB5bWluLCB5bWF4LCBzY2FuTGluZSk7XG4gICAgaWYgKGJjLmR5KSBzY2FuU3BhbnMoY2EsIGJjLCB5bWluLCB5bWF4LCBzY2FuTGluZSk7XG59XG5cblRpbGVDb29yZC5jb3ZlciA9IGZ1bmN0aW9uKHosIGJvdW5kcywgYWN0dWFsWikge1xuICAgIHZhciB0aWxlcyA9IDEgPDwgejtcbiAgICB2YXIgdCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gc2NhbkxpbmUoeDAsIHgxLCB5KSB7XG4gICAgICAgIHZhciB4LCB3eDtcbiAgICAgICAgaWYgKHkgPj0gMCAmJiB5IDw9IHRpbGVzKSB7XG4gICAgICAgICAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICAgICAgICAgICAgICB3eCA9ICh4ICsgdGlsZXMpICUgdGlsZXM7XG4gICAgICAgICAgICAgICAgdFtUaWxlQ29vcmQudG9JRChhY3R1YWxaLCB3eCwgeSwgTWF0aC5mbG9vcih4IC8gdGlsZXMpKV0gPSB7eDogd3gsIHk6IHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGl2aWRlIHRoZSBzY3JlZW4gdXAgaW4gdHdvIHRyaWFuZ2xlcyBhbmQgc2NhbiBlYWNoIG9mIHRoZW06XG4gICAgLy8gKy0tLS9cbiAgICAvLyB8IC8gfFxuICAgIC8vIC8tLS0rXG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1swXSwgYm91bmRzWzFdLCBib3VuZHNbMl0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1syXSwgYm91bmRzWzNdLCBib3VuZHNbMF0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL3V0aWwvbXJ1X2NhY2hlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVQeXJhbWlkO1xuXG5mdW5jdGlvbiBUaWxlUHlyYW1pZChvcHRpb25zKSB7XG4gICAgdGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG4gICAgdGhpcy5taW56b29tID0gb3B0aW9ucy5taW56b29tO1xuICAgIHRoaXMubWF4em9vbSA9IG9wdGlvbnMubWF4em9vbTtcbiAgICB0aGlzLnJlcGFyc2VPdmVyc2NhbGVkID0gb3B0aW9ucy5yZXBhcnNlT3ZlcnNjYWxlZDtcblxuICAgIHRoaXMuX2xvYWQgPSBvcHRpb25zLmxvYWQ7XG4gICAgdGhpcy5fYWJvcnQgPSBvcHRpb25zLmFib3J0O1xuICAgIHRoaXMuX3VubG9hZCA9IG9wdGlvbnMudW5sb2FkO1xuICAgIHRoaXMuX2FkZCA9IG9wdGlvbnMuYWRkO1xuICAgIHRoaXMuX3JlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuICAgIHRoaXMuX3JlZG9QbGFjZW1lbnQgPSBvcHRpb25zLnJlZG9QbGFjZW1lbnQ7XG5cbiAgICB0aGlzLl90aWxlcyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlID0gbmV3IENhY2hlKG9wdGlvbnMuY2FjaGVTaXplLCBmdW5jdGlvbih0aWxlKSB7IHJldHVybiB0aGlzLl91bmxvYWQodGlsZSk7IH0uYmluZCh0aGlzKSk7XG59XG5cblRpbGVQeXJhbWlkLnByb3RvdHlwZSA9IHtcbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciB0IGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RpbGVzW3RdLmxvYWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIG9yZGVyZWRJRHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdGlsZXMpXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiAoYiAlIDMyKSAtIChhICUgMzIpOyB9KSAvLyB6LW9yZGVyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGlkKSB7IHJldHVybiAraWQ7IH0pO1xuICAgIH0sXG5cbiAgICByZW5kZXJlZElEczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRJRHMoKS5maWx0ZXIoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWxlc1tpZF0ubG9hZGVkICYmICF0aGlzLl9jb3ZlcmVkVGlsZXNbaWRdO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jYWNoZS5yZXNldCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkKHRoaXMuX3RpbGVzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRUaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbaWRdO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIG1hcCBhbmQgc291cmNlIHRpbGVzaXplc1xuICAgIGdldFpvb206IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnpvb20gKyBNYXRoLmxvZyh0cmFuc2Zvcm0udGlsZVNpemUgLyB0aGlzLnRpbGVTaXplKSAvIE1hdGguTE4yO1xuICAgIH0sXG5cbiAgICBjb3ZlcmluZ1pvb21MZXZlbDogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuZ2V0Wm9vbSh0cmFuc2Zvcm0pKTtcbiAgICB9LFxuXG4gICAgY292ZXJpbmdUaWxlczogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB6ID0gdGhpcy5jb3ZlcmluZ1pvb21MZXZlbCh0cmFuc2Zvcm0pO1xuICAgICAgICB2YXIgYWN0dWFsWiA9IHo7XG5cbiAgICAgICAgaWYgKHogPCB0aGlzLm1pbnpvb20pIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHogPiB0aGlzLm1heHpvb20pIHogPSB0aGlzLm1heHpvb207XG5cbiAgICAgICAgdmFyIHRyID0gdHJhbnNmb3JtLFxuICAgICAgICAgICAgdGlsZUNlbnRlciA9IFRpbGVDb29yZC56b29tVG8odHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlciksIHopLFxuICAgICAgICAgICAgY2VudGVyUG9pbnQgPSBuZXcgUG9pbnQodGlsZUNlbnRlci5jb2x1bW4gLSAwLjUsIHRpbGVDZW50ZXIucm93IC0gMC41KTtcblxuICAgICAgICByZXR1cm4gVGlsZUNvb3JkLmNvdmVyKHosIFtcbiAgICAgICAgICAgIFRpbGVDb29yZC56b29tVG8odHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCgwLCAwKSksIHopLFxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCAwKSksIHopLFxuICAgICAgICAgICAgVGlsZUNvb3JkLnpvb21Ubyh0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCB0ci5oZWlnaHQpKSwgeiksXG4gICAgICAgICAgICBUaWxlQ29vcmQuem9vbVRvKHRyLnBvaW50Q29vcmRpbmF0ZShuZXcgUG9pbnQoMCwgdHIuaGVpZ2h0KSksIHopXG4gICAgICAgIF0sIHRoaXMucmVwYXJzZU92ZXJzY2FsZWQgPyBhY3R1YWxaIDogeikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VudGVyUG9pbnQuZGlzdChUaWxlQ29vcmQuZnJvbUlEKGEpKSAtXG4gICAgICAgICAgICAgICAgY2VudGVyUG9pbnQuZGlzdChUaWxlQ29vcmQuZnJvbUlEKGIpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGZpbmQgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIHRpbGUgKHVwIHRvIG1heENvdmVyaW5nWm9vbSkgdGhhdCBhcmUgYWxyZWFkeSBsb2FkZWQ7XG4gICAgLy8gYWRkcyBmb3VuZCB0aWxlcyB0byByZXRhaW4gb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgY2hpbGRyZW4gY29tcGxldGVseSBjb3ZlciB0aGUgdGlsZVxuICAgIGZpbmRMb2FkZWRDaGlsZHJlbjogZnVuY3Rpb24oaWQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSB7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHZhciB6ID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejtcbiAgICAgICAgdmFyIGlkcyA9IFRpbGVDb29yZC5jaGlsZHJlbihpZCwgdGhpcy5tYXh6b29tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90aWxlc1tpZHNbaV1dICYmIHRoaXMuX3RpbGVzW2lkc1tpXV0ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluW2lkc1tpXV0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh6IDwgbWF4Q292ZXJpbmdab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdvIGZ1cnRoZXIgZG93biB0aGUgaGllcmFyY2h5IHRvIGZpbmQgbW9yZSB1bmxvYWRlZCBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kTG9hZGVkQ2hpbGRyZW4oaWRzW2ldLCBtYXhDb3ZlcmluZ1pvb20sIHJldGFpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wbGV0ZTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhIGxvYWRlZCBwYXJlbnQgb2YgdGhlIGdpdmVuIHRpbGUgKHVwIHRvIG1pbkNvdmVyaW5nWm9vbSk7XG4gICAgLy8gYWRkcyB0aGUgZm91bmQgdGlsZSB0byByZXRhaW4gb2JqZWN0IGFuZCByZXR1cm5zIHRoZSB0aWxlIGlmIGZvdW5kXG4gICAgZmluZExvYWRlZFBhcmVudDogZnVuY3Rpb24oaWQsIG1pbkNvdmVyaW5nWm9vbSwgcmV0YWluKSB7XG4gICAgICAgIGZvciAodmFyIHogPSBUaWxlQ29vcmQuZnJvbUlEKGlkKS56OyB6ID49IG1pbkNvdmVyaW5nWm9vbTsgei0tKSB7XG4gICAgICAgICAgICBpZCA9IFRpbGVDb29yZC5wYXJlbnQoaWQsIHRoaXMubWF4em9vbSk7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlcyB0aWxlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB2aWV3cG9ydCBhbmQgYWRkcyBuZXcgdGlsZXMgdGhhdCBhcmUgaW5zaWRlIHRoZSB2aWV3cG9ydC5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHVzZWQsIHRyYW5zZm9ybSwgZmFkZUR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHZhciB0aWxlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgb3Zlcnpvb21pbmcvdW5kZXJ6b29taW5nIGFtb3VudHMuXG4gICAgICAgIHZhciB6b29tID0gTWF0aC5mbG9vcih0aGlzLmdldFpvb20odHJhbnNmb3JtKSk7XG4gICAgICAgIHZhciBtaW5Db3ZlcmluZ1pvb20gPSB1dGlsLmNsYW1wKHpvb20gLSAxMCwgdGhpcy5taW56b29tLCB0aGlzLm1heHpvb20pO1xuICAgICAgICB2YXIgbWF4Q292ZXJpbmdab29tID0gdXRpbC5jbGFtcCh6b29tICsgMSwgIHRoaXMubWluem9vbSwgdGhpcy5tYXh6b29tKTtcblxuICAgICAgICAvLyBSZXRhaW4gaXMgYSBsaXN0IG9mIHRpbGVzIHRoYXQgd2Ugc2hvdWxkbid0IGRlbGV0ZSwgZXZlbiBpZiB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gdGhlIG1vc3QgaWRlYWwgdGlsZSBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgbWF5IGluY2x1ZGUgdGlsZXMgbGlrZVxuICAgICAgICAvLyBwYXJlbnQgb3IgY2hpbGQgdGlsZXMgdGhhdCBhcmUgKmFscmVhZHkqIGxvYWRlZC5cbiAgICAgICAgdmFyIHJldGFpbiA9IHt9O1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgLy8gQ292ZXJlZCBpcyBhIGxpc3Qgb2YgcmV0YWluZWQgdGlsZXMgd2hvJ3MgYXJlYXMgYXJlIGZ1bGwgY292ZXJlZCBieSBvdGhlcixcbiAgICAgICAgLy8gYmV0dGVyLCByZXRhaW5lZCB0aWxlcy4gVGhleSBhcmUgbm90IGRyYXduIHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX2NvdmVyZWRUaWxlcyA9IHt9O1xuXG4gICAgICAgIHZhciByZXF1aXJlZCA9IHVzZWQgPyB0aGlzLmNvdmVyaW5nVGlsZXModHJhbnNmb3JtKSA6IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gK3JlcXVpcmVkW2ldO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuYWRkVGlsZShpZCk7XG5cbiAgICAgICAgICAgIHJldGFpbltpZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5sb2FkZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIFRoZSB0aWxlIHdlIHJlcXVpcmUgaXMgbm90IHlldCBsb2FkZWQuXG4gICAgICAgICAgICAvLyBSZXRhaW4gY2hpbGQgb3IgcGFyZW50IHRpbGVzIHRoYXQgY292ZXIgdGhlIHNhbWUgYXJlYS5cbiAgICAgICAgICAgIGlmICghdGhpcy5maW5kTG9hZGVkQ2hpbGRyZW4oaWQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmluZExvYWRlZFBhcmVudChpZCwgbWluQ292ZXJpbmdab29tLCByZXRhaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpZCBpbiByZXRhaW4pIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLnRpbWVBZGRlZCA+IG5vdyAtIChmYWRlRHVyYXRpb24gfHwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRpbGUgaXMgc3RpbGwgZmFkaW5nIGluLiBGaW5kIHRpbGVzIHRvIGNyb3NzLWZhZGUgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kTG9hZGVkQ2hpbGRyZW4oaWQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3ZlcmVkVGlsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kTG9hZGVkUGFyZW50KGlkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0aWxlcyB3ZSBkb24ndCBuZWVkIGFueW1vcmUuXG4gICAgICAgIHZhciByZW1vdmUgPSB1dGlsLmtleXNEaWZmZXJlbmNlKHRoaXMuX3RpbGVzLCByZXRhaW4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGUoK3JlbW92ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgIGlmICh0aWxlKVxuICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG5cbiAgICAgICAgdmFyIHdyYXBwZWQgPSB0aGlzLl93cmFwcGVkSUQoaWQpO1xuICAgICAgICB0aWxlID0gdGhpcy5fdGlsZXNbd3JhcHBlZF07XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5fY2FjaGUuZ2V0KHdyYXBwZWQpO1xuICAgICAgICAgICAgaWYgKHRpbGUgJiYgdGhpcy5fcmVkb1BsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZG9QbGFjZW1lbnQodGlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gVGlsZUNvb3JkLmZyb21JRChpZCkuejtcbiAgICAgICAgICAgIHZhciBvdmVyc2NhbGluZyA9IHpvb20gPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgICAgICB0aWxlID0gbmV3IFRpbGUod3JhcHBlZCwgdGhpcy50aWxlU2l6ZSAqIG92ZXJzY2FsaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWQodGlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aWxlLnVzZXMrKztcbiAgICAgICAgdGhpcy5fdGlsZXNbaWRdID0gdGlsZTtcbiAgICAgICAgdGhpcy5fYWRkKHRpbGUsIGlkKTtcblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgIGlmICghdGlsZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aWxlLnVzZXMtLTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKHRpbGUsIGlkKTtcblxuICAgICAgICBpZiAodGlsZS51c2VzID4gMClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAodGlsZS5sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmFkZCh0aGlzLl93cmFwcGVkSUQoaWQpLCB0aWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KHRpbGUpO1xuICAgICAgICAgICAgdGhpcy5fdW5sb2FkKHRpbGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFyVGlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl90aWxlcylcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGlsZShpZCk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnJlc2V0KCk7XG4gICAgfSxcblxuICAgIHRpbGVBdDogZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMub3JkZXJlZElEcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZHNbaV1dO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRpbGUucG9zaXRpb25BdChjb29yZCk7XG4gICAgICAgICAgICBpZiAocG9zICYmIHBvcy54ID49IDAgJiYgcG9zLnggPCA0MDk2ICYmIHBvcy55ID49IDAgJiYgcG9zLnkgPCA0MDk2KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNsaWNrIGlzIHdpdGhpbiB0aGUgdmlld3BvcnQuIFRoZXJlIGlzIG9ubHkgZXZlciBvbmUgdGlsZSBpblxuICAgICAgICAgICAgICAgIC8vIGEgbGF5ZXIgdGhhdCBoYXMgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgICAgICAgICAgeTogcG9zLnksXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBwb3Muc2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF93cmFwcGVkSUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBwb3MgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICAgICAgcmV0dXJuIHBvcy53ID09PSAwID8gaWQgOiBUaWxlQ29vcmQudG9JRChwb3MueiwgcG9zLngsIHBvcy55LCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVfY29vcmQnKTtcbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuL3NvdXJjZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVTb3VyY2U7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICd0aWxlU2l6ZSddKSk7XG5cbiAgICBpZiAodGhpcy50aWxlU2l6ZSAhPT0gNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVjdG9yIHRpbGUgc291cmNlcyBtdXN0IGhhdmUgYSB0aWxlU2l6ZSBvZiA1MTInKTtcbiAgICB9XG5cbiAgICBTb3VyY2UuX2xvYWRUaWxlSlNPTi5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5WZWN0b3JUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0cnVlLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B5cmFtaWQgJiYgdGhpcy5fcHlyYW1pZC5sb2FkZWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3B5cmFtaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3B5cmFtaWQudXBkYXRlKHRoaXMudXNlZCwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9weXJhbWlkLnJlbG9hZCgpO1xuICAgIH0sXG5cbiAgICByZWRvUGxhY2VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9weXJhbWlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5fcHlyYW1pZC5vcmRlcmVkSURzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3B5cmFtaWQuZ2V0VGlsZShpZHNbaV0pO1xuICAgICAgICAgICAgdGhpcy5fcmVkb1RpbGVQbGFjZW1lbnQodGlsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyOiBTb3VyY2UuX3JlbmRlclRpbGVzLFxuICAgIGZlYXR1cmVzQXQ6IFNvdXJjZS5fdmVjdG9yRmVhdHVyZXNBdCxcblxuICAgIF9sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLnpvb20gPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLnpvb20gLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVybDogVGlsZUNvb3JkLnVybCh0aWxlLmlkLCB0aGlzLnRpbGVzLCB0aGlzLm1heHpvb20pLFxuICAgICAgICAgICAgdWlkOiB0aWxlLnVpZCxcbiAgICAgICAgICAgIGlkOiB0aWxlLmlkLFxuICAgICAgICAgICAgem9vbTogdGlsZS56b29tLFxuICAgICAgICAgICAgbWF4Wm9vbTogdGhpcy5tYXh6b29tLFxuICAgICAgICAgICAgdGlsZVNpemU6IHRoaXMudGlsZVNpemUgKiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLm1hcC50cmFuc2Zvcm0uYW5nbGUsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgY29sbGlzaW9uRGVidWc6IHRoaXMubWFwLmNvbGxpc2lvbkRlYnVnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRpbGUud29ya2VySUQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZWxvYWQgdGlsZScsIHBhcmFtcywgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIHRpbGUpLCB0aWxlLndvcmtlcklEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbGUud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCB0aWxlJywgcGFyYW1zLCB0aGlzLl90aWxlTG9hZGVkLmJpbmQodGhpcywgdGlsZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90aWxlTG9hZGVkOiBmdW5jdGlvbih0aWxlLCBlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRpbGUuYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuZXJyb3InLCB7dGlsZTogdGlsZX0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlsZS5sb2FkVmVjdG9yRGF0YShkYXRhKTtcblxuICAgICAgICBpZiAodGlsZS5yZWRvV2hlbkRvbmUpIHtcbiAgICAgICAgICAgIHRpbGUucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9yZWRvVGlsZVBsYWNlbWVudCh0aWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX2Fib3J0VGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnYWJvcnQgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfYWRkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZVRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgfSxcblxuICAgIF91bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgdGhpcy5nbHlwaEF0bGFzLnJlbW92ZUdseXBocyh0aWxlLnVpZCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZW1vdmUgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH0sXG5cbiAgICBfcmVkb1RpbGVQbGFjZW1lbnQ6IGZ1bmN0aW9uKHRpbGUpIHtcblxuICAgICAgICBpZiAoIXRpbGUubG9hZGVkIHx8IHRpbGUucmVkb2luZ1BsYWNlbWVudCkge1xuICAgICAgICAgICAgdGlsZS5yZWRvV2hlbkRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlsZS5yZWRvaW5nUGxhY2VtZW50ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncmVkbyBwbGFjZW1lbnQnLCB7XG4gICAgICAgICAgICB1aWQ6IHRpbGUudWlkLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgYW5nbGU6IHRoaXMubWFwLnRyYW5zZm9ybS5hbmdsZSxcbiAgICAgICAgICAgIHBpdGNoOiB0aGlzLm1hcC50cmFuc2Zvcm0ucGl0Y2gsXG4gICAgICAgICAgICBjb2xsaXNpb25EZWJ1ZzogdGhpcy5tYXAuY29sbGlzaW9uRGVidWdcbiAgICAgICAgfSwgZG9uZS5iaW5kKHRoaXMpLCB0aWxlLndvcmtlcklEKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKF8sIGRhdGEpIHtcbiAgICAgICAgICAgIHRpbGUucmVsb2FkU3ltYm9sRGF0YShkYXRhLCB0aGlzLm1hcC5wYWludGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgndGlsZS5sb2FkJywge3RpbGU6IHRpbGV9KTtcblxuICAgICAgICAgICAgdGlsZS5yZWRvaW5nUGxhY2VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGlsZS5yZWRvV2hlbkRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWRvVGlsZVBsYWNlbWVudCh0aWxlKTtcbiAgICAgICAgICAgICAgICB0aWxlLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIExhdExuZyA9IHJlcXVpcmUoJy4uL2dlby9sYXRfbG5nJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlkZW9Tb3VyY2U7XG5cbi8qKlxuICogQ3JlYXRlIGEgVmlkZW8gZGF0YSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3RcbiAqIEBjbGFzcyBWaWRlb1NvdXJjZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG9wdGlvbnMudXJsIEEgc3RyaW5nIG9yIGFycmF5IG9mIFVSTChzKSB0byB2aWRlbyBmaWxlc1xuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5jb29yZGluYXRlcyBsYXQsbG5nIGNvb3JkaW5hdGVzIGluIG9yZGVyIGNsb2Nrd2lzZSBzdGFydGluZyBhdCB0aGUgdG9wIGxlZnQ6IHRsLCB0ciwgYnIsIGJsXG4gKiBAZXhhbXBsZVxuICogdmFyIHNvdXJjZU9iaiA9IG5ldyBtYXBib3hnbC5WaWRlb1NvdXJjZSh7XG4gKiAgICB1cmw6IFtcbiAqICAgICAgICAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS92aWRlb3MvYmFsdGltb3JlLXNtb2tlLm1wNCcsXG4gKiAgICAgICAgJ2h0dHBzOi8vd3d3Lm1hcGJveC5jb20vdmlkZW9zL2JhbHRpbW9yZS1zbW9rZS53ZWJtJ1xuICogICAgXSxcbiAqICAgIGNvb3JkaW5hdGVzOiBbXG4gKiAgICAgICAgWzM5LjE4NTc5OTA3MjI5NzQ4LCAtNzYuNTQzMzU3MzcyMjgzOTRdLFxuICogICAgICAgIFszOS4xODM4MzY0ODQ3NTg3LCAtNzYuNTI4MDM2NTk0MzkwODddLFxuICogICAgICAgIFszOS4xNzY4MzM5MjUwNzYwNiwgLTc2LjUyOTUzODYzMTQzOTJdLFxuICogICAgICAgIFszOS4xNzg3NjM0NDEwNjY0MiwgLTc2LjU0NTIwMjczMjA4NjE4XVxuICogICAgXVxuICogfSk7XG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywgc291cmNlT2JqKTsgLy8gYWRkXG4gKiBtYXAucmVtb3ZlU291cmNlKCdzb21lIGlkJyk7ICAvLyByZW1vdmVcbiAqL1xuZnVuY3Rpb24gVmlkZW9Tb3VyY2Uob3B0aW9ucykge1xuICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBvcHRpb25zLmNvb3JkaW5hdGVzO1xuXG4gICAgYWpheC5nZXRWaWRlbyhvcHRpb25zLnVybCwgZnVuY3Rpb24oZXJyLCB2aWRlbykge1xuICAgICAgICAvLyBAVE9ETyBoYW5kbGUgZXJyb3JzIHZpYSBldmVudC5cbiAgICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMudmlkZW8gPSB2aWRlbztcbiAgICAgICAgdGhpcy52aWRlby5sb29wID0gdHJ1ZTtcblxuICAgICAgICB2YXIgbG9vcElEO1xuXG4gICAgICAgIC8vIHN0YXJ0IHJlcGFpbnRpbmcgd2hlbiB2aWRlbyBzdGFydHMgcGxheWluZ1xuICAgICAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvb3BJRCA9IHRoaXMubWFwLnN0eWxlLmFuaW1hdGlvbkxvb3Auc2V0KEluZmluaXR5KTtcbiAgICAgICAgICAgIHRoaXMubWFwLl9yZXJlbmRlcigpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIHN0b3AgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0b3BzXG4gICAgICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLnN0eWxlLmFuaW1hdGlvbkxvb3AuY2FuY2VsKGxvb3BJRCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVUaWxlKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbn1cblxuVmlkZW9Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRpbGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogQ2FsY3VsYXRlIHdoaWNoIG1lcmNhdG9yIHRpbGUgaXMgc3VpdGFibGUgZm9yIHJlbmRlcmluZyB0aGUgdmlkZW8gaW5cbiAgICAgICAgICogYW5kIGNyZWF0ZSBhIGJ1ZmZlciB3aXRoIHRoZSBjb3JuZXIgY29vcmRpbmF0ZXMuIFRoZXNlIGNvb3JkaW5hdGVzXG4gICAgICAgICAqIG1heSBiZSBvdXRzaWRlIHRoZSB0aWxlLCBiZWNhdXNlIHJhc3RlciB0aWxlcyBhcmVuJ3QgY2xpcHBlZCB3aGVuIHJlbmRlcmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcDtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uKGxhdGxuZykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XG4gICAgICAgICAgICByZXR1cm4gVGlsZUNvb3JkLnpvb21UbyhtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShsb2MpLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgY29vcmRzW2ldLnJvdyk7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSBtYXhYIC0gbWluWDtcbiAgICAgICAgdmFyIGR5ID0gbWF4WSAtIG1pblk7XG4gICAgICAgIHZhciBkTWF4ID0gTWF0aC5tYXgoZHgsIGR5KTtcbiAgICAgICAgdmFyIGNlbnRlciA9IFRpbGVDb29yZC56b29tVG8oe1xuICAgICAgICAgICAgY29sdW1uOiAobWluWCArIG1heFgpIC8gMixcbiAgICAgICAgICAgIHJvdzogKG1pblkgKyBtYXhZKSAvIDIsXG4gICAgICAgICAgICB6b29tOiAwXG4gICAgICAgIH0sIE1hdGguZmxvb3IoLU1hdGgubG9nKGRNYXgpIC8gTWF0aC5MTjIpKTtcblxuICAgICAgICB2YXIgdGlsZUV4dGVudCA9IDQwOTY7XG4gICAgICAgIHZhciB0aWxlQ29vcmRzID0gY29vcmRzLm1hcChmdW5jdGlvbihjb29yZCkge1xuICAgICAgICAgICAgdmFyIHpvb21lZENvb3JkID0gVGlsZUNvb3JkLnpvb21Ubyhjb29yZCwgY2VudGVyLnpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCh6b29tZWRDb29yZC5jb2x1bW4gLSBjZW50ZXIuY29sdW1uKSAqIHRpbGVFeHRlbnQpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLnJvdyAtIGNlbnRlci5yb3cpICogdGlsZUV4dGVudCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZ2wgPSBtYXAucGFpbnRlci5nbDtcbiAgICAgICAgdmFyIG1heEludDE2ID0gMzI3Njc7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBJbnQxNkFycmF5KFtcbiAgICAgICAgICAgIHRpbGVDb29yZHNbMF0ueCwgdGlsZUNvb3Jkc1swXS55LCAwLCAwLFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1sxXS54LCB0aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwLFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1szXS54LCB0aWxlQ29vcmRzWzNdLnksIDAsIG1heEludDE2LFxuICAgICAgICAgICAgdGlsZUNvb3Jkc1syXS54LCB0aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNlxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLnRpbGUgPSBuZXcgVGlsZSgpO1xuICAgICAgICB0aGlzLnRpbGUuYnVja2V0cyA9IHt9O1xuXG4gICAgICAgIHRoaXMudGlsZS5ib3VuZHNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGlsZS5ib3VuZHNCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW8gJiYgdGhpcy52aWRlby5yZWFkeVN0YXRlID49IDI7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihsYXllcnMsIHBhaW50ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA8IDIpIHJldHVybjsgLy8gbm90IGVub3VnaCBkYXRhIGZvciBjdXJyZW50IHBvc2l0aW9uXG5cbiAgICAgICAgdmFyIGMgPSB0aGlzLmNlbnRlcjtcbiAgICAgICAgdGhpcy50aWxlLmNhbGN1bGF0ZU1hdHJpY2VzKGMuem9vbSwgYy5jb2x1bW4sIGMucm93LCB0aGlzLm1hcC50cmFuc2Zvcm0sIHBhaW50ZXIpO1xuXG4gICAgICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgICAgIGlmICghdGhpcy50aWxlLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGlsZS50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhaW50ZXIuZHJhd0xheWVycyhsYXllcnMsIHRoaXMudGlsZS5wb3NNYXRyaXgsIHRoaXMudGlsZSk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKHBvaW50LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL3V0aWwvYWN0b3InKTtcbnZhciBXb3JrZXJUaWxlID0gcmVxdWlyZSgnLi93b3JrZXJfdGlsZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgdnQgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpO1xudmFyIFByb3RvYnVmID0gcmVxdWlyZSgncGJmJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG5cbnZhciBnZW9qc29udnQgPSByZXF1aXJlKCdnZW9qc29uLXZ0Jyk7XG52YXIgR2VvSlNPTldyYXBwZXIgPSByZXF1aXJlKCcuL2dlb2pzb25fd3JhcHBlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlcjtcblxuZnVuY3Rpb24gV29ya2VyKHNlbGYpIHtcbiAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgIHRoaXMuYWN0b3IgPSBuZXcgQWN0b3Ioc2VsZiwgdGhpcyk7XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG5cbiAgICB0aGlzLmxvYWRlZCA9IHt9O1xuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgdGhpcy5nZW9KU09OSW5kZXhlcyA9IHt9O1xufVxuXG51dGlsLmV4dGVuZChXb3JrZXIucHJvdG90eXBlLCB7XG4gICAgJ3NldCBsYXllcnMnOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBsYXllcnM7XG4gICAgfSxcblxuICAgICdsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcblxuICAgICAgICBpZiAoIXRoaXMubG9hZGluZ1tzb3VyY2VdKVxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nW3NvdXJjZV0gPSB7fTtcblxuXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5sb2FkaW5nW3NvdXJjZV1bdWlkXSA9IG5ldyBXb3JrZXJUaWxlKHBhcmFtcyk7XG5cbiAgICAgICAgdGlsZS54aHIgPSBhamF4LmdldEFycmF5QnVmZmVyKHBhcmFtcy51cmwsIGRvbmUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxvYWRpbmdbc291cmNlXVt1aWRdO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcblxuICAgICAgICAgICAgdGlsZS5kYXRhID0gbmV3IHZ0LlZlY3RvclRpbGUobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICB0aWxlLnBhcnNlKHRpbGUuZGF0YSwgdGhpcy5sYXllcnMsIHRoaXMuYWN0b3IsIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXSA9IHRoaXMubG9hZGVkW3NvdXJjZV0gfHwge307XG4gICAgICAgICAgICB0aGlzLmxvYWRlZFtzb3VyY2VdW3VpZF0gPSB0aWxlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdyZWxvYWQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMubG9hZGVkW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcbiAgICAgICAgaWYgKGxvYWRlZCAmJiBsb2FkZWRbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSBsb2FkZWRbdWlkXTtcbiAgICAgICAgICAgIHRpbGUucGFyc2UodGlsZS5kYXRhLCB0aGlzLmxheWVycywgdGhpcy5hY3RvciwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdhYm9ydCB0aWxlJzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcbiAgICAgICAgaWYgKGxvYWRpbmcgJiYgbG9hZGluZ1t1aWRdKSB7XG4gICAgICAgICAgICBsb2FkaW5nW3VpZF0ueGhyLmFib3J0KCk7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGluZ1t1aWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdyZW1vdmUgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGVkW3VpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3JlZG8gcGxhY2VtZW50JzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcblxuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IGxvYWRlZFt1aWRdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRpbGUucmVkb1BsYWNlbWVudChwYXJhbXMuYW5nbGUsIHBhcmFtcy5waXRjaCwgcGFyYW1zLmNvbGxpc2lvbkRlYnVnKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQucmVzdWx0LCByZXN1bHQudHJhbnNmZXJhYmxlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsb2FkaW5nICYmIGxvYWRpbmdbdWlkXSkge1xuICAgICAgICAgICAgbG9hZGluZ1t1aWRdLmFuZ2xlID0gcGFyYW1zLmFuZ2xlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdwYXJzZSBnZW9qc29uJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaW5kZXhEYXRhID0gZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHRoaXMuZ2VvSlNPTkluZGV4ZXNbcGFyYW1zLnNvdXJjZV0gPSBnZW9qc29udnQoZGF0YSwge2Jhc2Vab29tOiBwYXJhbXMubWF4Wm9vbX0pO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAvLyBUT0RPIGFjY2VwdCBwYXJhbXMudXJsIGZvciB1cmxzIGluc3RlYWRcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuZGF0YSA9PT0gJ3N0cmluZycpIGFqYXguZ2V0SlNPTihwYXJhbXMuZGF0YSwgaW5kZXhEYXRhKTtcbiAgICAgICAgZWxzZSBpbmRleERhdGEobnVsbCwgcGFyYW1zLmRhdGEpO1xuICAgIH0sXG5cbiAgICAnbG9hZCBnZW9qc29uIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlLFxuICAgICAgICAgICAgY29vcmQgPSBUaWxlQ29vcmQuZnJvbUlEKHBhcmFtcy5pZCk7XG5cbiAgICAgICAgLy8gY29uc29sZS50aW1lKCd0aWxlICcgKyBjb29yZC56ICsgJyAnICsgY29vcmQueCArICcgJyArIGNvb3JkLnkpO1xuXG4gICAgICAgIHZhciBnZW9KU09OVGlsZSA9IHRoaXMuZ2VvSlNPTkluZGV4ZXNbc291cmNlXS5nZXRUaWxlKGNvb3JkLnosIGNvb3JkLngsIGNvb3JkLnkpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUudGltZUVuZCgndGlsZSAnICsgY29vcmQueiArICcgJyArIGNvb3JkLnggKyAnICcgKyBjb29yZC55KTtcblxuICAgICAgICAvLyBpZiAoIWdlb0pTT05UaWxlKSBjb25zb2xlLmxvZygnbm90IGZvdW5kJywgdGhpcy5nZW9KU09OSW5kZXhlc1tzb3VyY2VdLCBjb29yZCk7XG5cbiAgICAgICAgaWYgKCFnZW9KU09OVGlsZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpOyAvLyBub3RoaW5nIGluIHRoZSBnaXZlbiB0aWxlXG5cbiAgICAgICAgdmFyIHRpbGUgPSBuZXcgV29ya2VyVGlsZShwYXJhbXMpO1xuICAgICAgICB0aWxlLnBhcnNlKG5ldyBHZW9KU09OV3JhcHBlcihnZW9KU09OVGlsZS5mZWF0dXJlcyksIHRoaXMubGF5ZXJzLCB0aGlzLmFjdG9yLCBjYWxsYmFjayk7XG5cbiAgICAgICAgdGhpcy5sb2FkZWRbc291cmNlXSA9IHRoaXMubG9hZGVkW3NvdXJjZV0gfHwge307XG4gICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV1bcGFyYW1zLnVpZF0gPSB0aWxlO1xuICAgIH0sXG5cbiAgICAncXVlcnkgZmVhdHVyZXMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0gJiYgdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV1bcGFyYW1zLnVpZF07XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aWxlLmZlYXR1cmVUcmVlLnF1ZXJ5KHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlVHJlZSA9IHJlcXVpcmUoJy4uL2RhdGEvZmVhdHVyZV90cmVlJyk7XG52YXIgQ29sbGlzaW9uID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl90aWxlJyk7XG52YXIgQnVmZmVyU2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWZmZXIvYnVmZmVyX3NldCcpO1xudmFyIGNyZWF0ZUJ1Y2tldCA9IHJlcXVpcmUoJy4uL2RhdGEvY3JlYXRlX2J1Y2tldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlclRpbGU7XG5cbmZ1bmN0aW9uIFdvcmtlclRpbGUocGFyYW1zKSB7XG4gICAgdGhpcy5pZCA9IHBhcmFtcy5pZDtcbiAgICB0aGlzLnVpZCA9IHBhcmFtcy51aWQ7XG4gICAgdGhpcy56b29tID0gcGFyYW1zLnpvb207XG4gICAgdGhpcy5tYXhab29tID0gcGFyYW1zLm1heFpvb207XG4gICAgdGhpcy50aWxlU2l6ZSA9IHBhcmFtcy50aWxlU2l6ZTtcbiAgICB0aGlzLnNvdXJjZSA9IHBhcmFtcy5zb3VyY2U7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IHBhcmFtcy5vdmVyc2NhbGluZztcbiAgICB0aGlzLmFuZ2xlID0gcGFyYW1zLmFuZ2xlO1xuICAgIHRoaXMucGl0Y2ggPSBwYXJhbXMucGl0Y2g7XG4gICAgdGhpcy5jb2xsaXNpb25EZWJ1ZyA9IHBhcmFtcy5jb2xsaXNpb25EZWJ1ZztcblxuICAgIHRoaXMuc3RhY2tzID0ge307XG59XG5cbldvcmtlclRpbGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgbGF5ZXJzLCBhY3RvciwgY2FsbGJhY2spIHtcblxuICAgIHRoaXMuc3RhdHVzID0gJ3BhcnNpbmcnO1xuXG4gICAgdGhpcy5mZWF0dXJlVHJlZSA9IG5ldyBGZWF0dXJlVHJlZSh0aGlzLmlkKTtcblxuICAgIHZhciBpLCBrLFxuICAgICAgICB0aWxlID0gdGhpcyxcbiAgICAgICAgbGF5ZXIsXG4gICAgICAgIGJ1Y2tldCxcbiAgICAgICAgYnVmZmVycyA9IG5ldyBCdWZmZXJTZXQoKSxcbiAgICAgICAgY29sbGlzaW9uID0gdGhpcy5jb2xsaXNpb24gPSBuZXcgQ29sbGlzaW9uKHRoaXMuem9vbSwgNDA5NiwgdGhpcy50aWxlU2l6ZSksXG4gICAgICAgIGJ1Y2tldHMgPSB7fSxcbiAgICAgICAgYnVja2V0c0luT3JkZXIgPSB0aGlzLmJ1Y2tldHNJbk9yZGVyID0gW10sXG4gICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyID0ge307XG5cbiAgICBjb2xsaXNpb24ucmVzZXQodGhpcy5hbmdsZSwgdGhpcy5waXRjaCk7XG5cbiAgICAvLyBNYXAgbm9uLXJlZiBsYXllcnMgdG8gYnVja2V0cy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgIGlmIChsYXllci5zb3VyY2UgIT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKGxheWVyLnJlZilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBtaW56b29tID0gbGF5ZXIubWluem9vbTtcbiAgICAgICAgaWYgKG1pbnpvb20gJiYgdGhpcy56b29tIDwgbWluem9vbSAmJiBtaW56b29tIDwgdGhpcy5tYXhab29tKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIG1heHpvb20gPSBsYXllci5tYXh6b29tO1xuICAgICAgICBpZiAobWF4em9vbSAmJiB0aGlzLnpvb20gPj0gbWF4em9vbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB2aXNpYmlsaXR5ID0gbGF5ZXIubGF5b3V0LnZpc2liaWxpdHk7XG4gICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSAnbm9uZScpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBidWNrZXQgPSBjcmVhdGVCdWNrZXQobGF5ZXIsIGJ1ZmZlcnMsIGNvbGxpc2lvbiwgdGhpcy56b29tLCB0aGlzLm92ZXJzY2FsaW5nLCB0aGlzLmNvbGxpc2lvbkRlYnVnKTtcbiAgICAgICAgYnVja2V0LmxheWVycyA9IFtsYXllci5pZF07XG5cbiAgICAgICAgYnVja2V0c1tidWNrZXQuaWRdID0gYnVja2V0O1xuICAgICAgICBidWNrZXRzSW5PcmRlci5wdXNoKGJ1Y2tldCk7XG5cbiAgICAgICAgaWYgKGRhdGEubGF5ZXJzKSB7XG4gICAgICAgICAgICAvLyB2ZWN0b3J0aWxlXG4gICAgICAgICAgICB2YXIgc291cmNlTGF5ZXIgPSBsYXllclsnc291cmNlLWxheWVyJ107XG4gICAgICAgICAgICBpZiAoIWJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVyXSlcbiAgICAgICAgICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcl0gPSB7fTtcbiAgICAgICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVyXVtidWNrZXQuaWRdID0gYnVja2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2VvanNvbiB0aWxlXG4gICAgICAgICAgICBidWNrZXRzQnlTb3VyY2VMYXllcltidWNrZXQuaWRdID0gYnVja2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5kZXggcmVmIGxheWVycy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgIGlmIChsYXllci5zb3VyY2UgIT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKCFsYXllci5yZWYpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBidWNrZXQgPSBidWNrZXRzW2xheWVyLnJlZl07XG4gICAgICAgIGlmICghYnVja2V0KVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgYnVja2V0LmxheWVycy5wdXNoKGxheWVyLmlkKTtcbiAgICB9XG5cbiAgICAvLyByZWFkIGVhY2ggbGF5ZXIsIGFuZCBzb3J0IGl0cyBmZWF0dXJlcyBpbnRvIGJ1Y2tldHNcbiAgICBpZiAoZGF0YS5sYXllcnMpIHtcbiAgICAgICAgLy8gdmVjdG9ydGlsZVxuICAgICAgICBmb3IgKGsgaW4gYnVja2V0c0J5U291cmNlTGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyID0gZGF0YS5sYXllcnNba107XG4gICAgICAgICAgICBpZiAoIWxheWVyKSBjb250aW51ZTtcbiAgICAgICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGxheWVyLCBidWNrZXRzQnlTb3VyY2VMYXllcltrXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZW9qc29uXG4gICAgICAgIHNvcnRMYXllckludG9CdWNrZXRzKGRhdGEsIGJ1Y2tldHNCeVNvdXJjZUxheWVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzb3J0TGF5ZXJJbnRvQnVja2V0cyhsYXllciwgYnVja2V0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGxheWVyLmZlYXR1cmUoaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYnVja2V0cykge1xuICAgICAgICAgICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldC5maWx0ZXIoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0LmZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZQbGFjZW1lbnRCdWNrZXQ7XG4gICAgdmFyIHJlbWFpbmluZyA9IGJ1Y2tldHNJbk9yZGVyLmxlbmd0aDtcblxuICAgIC8qXG4gICAgICogIFRoZSBhc3luYyBwYXJzaW5nIGhlcmUgaXMgYSBiaXQgdHJpY2t5LlxuICAgICAqICBTb21lIGJ1Y2tldHMgZGVwZW5kIG9uIHJlc291cmNlcyB0aGF0IG1heSBuZWVkIHRvIGJlIGxvYWRlZCBhc3luYyAoZ2x5cGhzKS5cbiAgICAgKiAgU29tZSBidWNrZXRzIG5lZWQgdG8gYmUgcGFyc2VkIGluIG9yZGVyICh0byBnZXQgY29sbGlzaW9uIHByaW9yaXRpZXMgcmlnaHQpLlxuICAgICAqXG4gICAgICogIERlcGVuZGVuY2llcyBjYWxscyBhcmUgaW5pdGlhdGVkIGZpcnN0IHRvIGdldCB0aG9zZSByb2xsaW5nLlxuICAgICAqICBCdWNrZXRzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZSBwYXJzZWQgaW4gb3JkZXIsIGFyZW4ndCB0byBzYXZlIHRpbWUuXG4gICAgICovXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYnVja2V0c0luT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0c0luT3JkZXJbaV07XG5cbiAgICAgICAgLy8gTGluayBidWNrZXRzIHRoYXQgbmVlZCB0byBiZSBwYXJzZWQgaW4gb3JkZXJcbiAgICAgICAgaWYgKGJ1Y2tldC5jb2xsaXNpb24pIHtcbiAgICAgICAgICAgIGlmIChwcmV2UGxhY2VtZW50QnVja2V0KSB7XG4gICAgICAgICAgICAgICAgcHJldlBsYWNlbWVudEJ1Y2tldC5uZXh0ID0gYnVja2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWNrZXQucHJldmlvdXNQbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBsYWNlbWVudEJ1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWNrZXQuZ2V0RGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBidWNrZXQuZ2V0RGVwZW5kZW5jaWVzKHRoaXMsIGFjdG9yLCBkZXBlbmRlbmNpZXNEb25lKGJ1Y2tldCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgcGFyc2UgYnVja2V0cyB3aGVyZSBvcmRlciBkb2Vzbid0IG1hdHRlciBhbmQgbm8gZGVwZW5kZW5jaWVzXG4gICAgICAgIGlmICghYnVja2V0LmNvbGxpc2lvbiAmJiAhYnVja2V0LmdldERlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcGVuZGVuY2llc0RvbmUoYnVja2V0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5kZXBlbmRlbmNpZXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgYnVja2V0LCBlcnIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQnVja2V0KHRpbGUsIGJ1Y2tldCwgc2tpcCkge1xuICAgICAgICBpZiAoYnVja2V0LmdldERlcGVuZGVuY2llcyAmJiAhYnVja2V0LmRlcGVuZGVuY2llc0xvYWRlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoYnVja2V0LmNvbGxpc2lvbiAmJiAhYnVja2V0LnByZXZpb3VzUGxhY2VkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChidWNrZXQuZmVhdHVyZXMubGVuZ3RoKSBidWNrZXQuYWRkRmVhdHVyZXMoKTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgICAgIGlmIChidWNrZXQuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGJ1Y2tldC5mZWF0dXJlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5mZWF0dXJlVHJlZS5pbnNlcnQoZmVhdHVyZS5iYm94KCksIGJ1Y2tldC5sYXllcnMsIGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1Y2tldFN0YXRzID0gc2VsZi5idWNrZXRTdGF0cyB8fCB7X3RvdGFsOiAwfTtcbiAgICAgICAgICAgICAgICBzZWxmLmJ1Y2tldFN0YXRzLl90b3RhbCArPSB0aW1lO1xuICAgICAgICAgICAgICAgIHNlbGYuYnVja2V0U3RhdHNbYnVja2V0LmlkXSA9IChzZWxmLmJ1Y2tldFN0YXRzW2J1Y2tldC5pZF0gfHwgMCkgKyB0aW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKCFyZW1haW5pbmcpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSBwYXJzaW5nIHRoZSBuZXh0IGJ1Y2tldCwgaWYgaXQgaXMgcmVhZHlcbiAgICAgICAgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBidWNrZXQubmV4dC5wcmV2aW91c1BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQubmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuXG4gICAgICAgIHRpbGUuc3RhdHVzID0gJ2RvbmUnO1xuXG4gICAgICAgIGlmICh0aWxlLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aWxlLnJlZG9QbGFjZW1lbnQodGlsZS5hbmdsZSwgdGlsZS5waXRjaCkucmVzdWx0O1xuICAgICAgICAgICAgYnVmZmVycy5nbHlwaFZlcnRleCA9IHJlc3VsdC5idWZmZXJzLmdseXBoVmVydGV4O1xuICAgICAgICAgICAgYnVmZmVycy5pY29uVmVydGV4ID0gcmVzdWx0LmJ1ZmZlcnMuaWNvblZlcnRleDtcbiAgICAgICAgICAgIGJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4ID0gcmVzdWx0LmJ1ZmZlcnMuY29sbGlzaW9uQm94VmVydGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXSxcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cHMgPSB7fTtcblxuICAgICAgICBmb3IgKGsgaW4gYnVmZmVycykge1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJ1ZmZlcnNba10uYXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrIGluIGJ1Y2tldHMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRHcm91cHNba10gPSBidWNrZXRzW2tdLmVsZW1lbnRHcm91cHM7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzOiBlbGVtZW50R3JvdXBzLFxuICAgICAgICAgICAgYnVmZmVyczogYnVmZmVyc1xuICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKTtcbiAgICB9XG59O1xuXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5yZWRvUGxhY2VtZW50ID0gZnVuY3Rpb24oYW5nbGUsIHBpdGNoLCBjb2xsaXNpb25EZWJ1Zykge1xuXG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSAnZG9uZScpIHtcbiAgICAgICAgdGhpcy5yZWRvUGxhY2VtZW50QWZ0ZXJEb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcnMgPSBuZXcgQnVmZmVyU2V0KCk7XG4gICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICB2YXIgZWxlbWVudEdyb3VwcyA9IHt9O1xuICAgIHZhciBjb2xsaXNpb24gPSB0aGlzLmNvbGxpc2lvbjtcblxuICAgIGNvbGxpc2lvbi5yZXNldChhbmdsZSwgcGl0Y2gpO1xuXG4gICAgdmFyIGJ1Y2tldHNJbk9yZGVyID0gdGhpcy5idWNrZXRzSW5PcmRlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldHNJbk9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWNrZXQgPSBidWNrZXRzSW5PcmRlcltpXTtcblxuICAgICAgICBpZiAoYnVja2V0LnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICBidWNrZXQucGxhY2VGZWF0dXJlcyhidWZmZXJzLCBjb2xsaXNpb25EZWJ1Zyk7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzW2J1Y2tldC5pZF0gPSBidWNrZXQuZWxlbWVudEdyb3VwcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gYnVmZmVycykge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goYnVmZmVyc1trXS5hcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBlbGVtZW50R3JvdXBzOiBlbGVtZW50R3JvdXBzLFxuICAgICAgICAgICAgYnVmZmVyczogYnVmZmVyc1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzOiB0cmFuc2ZlcmFibGVzXG4gICAgfTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25Mb29wO1xuXG5mdW5jdGlvbiBBbmltYXRpb25Mb29wKCkge1xuICAgIHRoaXMubiA9IDA7XG4gICAgdGhpcy50aW1lcyA9IFtdO1xufVxuXG4vLyBBcmUgYWxsIGFuaW1hdGlvbnMgZG9uZT9cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnN0b3BwZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC50aW1lID49IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICF0aGlzLnRpbWVzLmxlbmd0aDtcbn07XG5cbi8vIEFkZCBhIG5ldyBhbmltYXRpb24gdGhhdCB3aWxsIHJ1biB0IG1pbGxpc2Vjb25kc1xuLy8gUmV0dXJucyBhbiBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCBpdCBsYXllclxuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZXMucHVzaCh7IGlkOiB0aGlzLm4sIHRpbWU6IHQgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH0pO1xuICAgIHJldHVybiB0aGlzLm4rKztcbn07XG5cbi8vIENhbmNlbCBhbiBhbmltYXRpb25cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5pZCAhPT0gbjtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVNwcml0ZTtcblxuZnVuY3Rpb24gSW1hZ2VTcHJpdGUoYmFzZSkge1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5yZXRpbmEgPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxO1xuXG4gICAgYmFzZSA9IHRoaXMuYmFzZSArICh0aGlzLnJldGluYSA/ICdAMngnIDogJycpO1xuXG4gICAgYWpheC5nZXRKU09OKGJhc2UgKyAnLmpzb24nLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5pbWcpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBhamF4LmdldEltYWdlKGJhc2UgKyAnLnBuZycsIGZ1bmN0aW9uKGVyciwgaW1nKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlbXVsdGlwbHkgdGhlIHNwcml0ZVxuICAgICAgICB2YXIgZGF0YSA9IGltZy5nZXREYXRhKCk7XG4gICAgICAgIHZhciBuZXdkYXRhID0gaW1nLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gZGF0YVtpICsgM10gLyAyNTU7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAwXSA9IGRhdGFbaSArIDBdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICogYWxwaGE7XG4gICAgICAgICAgICBuZXdkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbWcgPSBpbWc7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRlZCk7XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiYgdGhpcy5pbWcpO1xufTtcblxuSW1hZ2VTcHJpdGUucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKC8qZ2wqLykge1xuICAgIGlmIChicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxICE9PSB0aGlzLnJldGluYSkge1xuICAgICAgICB2YXIgbmV3U3ByaXRlID0gbmV3IEltYWdlU3ByaXRlKHRoaXMuYmFzZSk7XG4gICAgICAgIG5ld1Nwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbWcgPSBuZXdTcHJpdGUuaW1nO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3U3ByaXRlLmRhdGE7XG4gICAgICAgICAgICB0aGlzLnJldGluYSA9IG5ld1Nwcml0ZS5yZXRpbmE7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gU3ByaXRlUG9zaXRpb24oKSB7fVxuU3ByaXRlUG9zaXRpb24ucHJvdG90eXBlID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBwaXhlbFJhdGlvOiAxLCBzZGY6IGZhbHNlIH07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5nZXRTcHJpdGVQb3NpdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubG9hZGVkKCkpIHJldHVybiBuZXcgU3ByaXRlUG9zaXRpb24oKTtcblxuICAgIHZhciBwb3MgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW25hbWVdO1xuICAgIGlmIChwb3MgJiYgdGhpcy5pbWcpIHJldHVybiBwb3M7XG5cbiAgICByZXR1cm4gbmV3IFNwcml0ZVBvc2l0aW9uKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVmZXJlbmNlID0gcmVxdWlyZSgnLi9yZWZlcmVuY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucmVmZXJlbmNlLmxheW91dC5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBwcm9wcykge1xuICAgICAgICAgICAgdGhpc1twXSA9IHByb3BzW3BdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gcmVmZXJlbmNlW2NsYXNzTmFtZV07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BdLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIFByb3BlcnRpZXMucHJvdG90eXBlW3Byb3BdID0gcHJvcGVydGllc1twcm9wXS5kZWZhdWx0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0c1tjbGFzc05hbWUucmVwbGFjZSgnbGF5b3V0XycsICcnKV0gPSBQcm9wZXJ0aWVzO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpO1xudmFyIHBhcnNlQ1NTQ29sb3IgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbnJlZmVyZW5jZS5wYWludC5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHZhciBDYWxjdWxhdGVkID0gZnVuY3Rpb24oKSB7fTtcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gcmVmZXJlbmNlW2NsYXNzTmFtZV07XG4gICAgZm9yICh2YXIgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcGVydGllc1twXSxcbiAgICAgICAgICAgIHZhbHVlID0gcHJvcC5kZWZhdWx0O1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ2NvbG9yJykgdmFsdWUgPSBwYXJzZUNTU0NvbG9yKHZhbHVlKTtcblxuICAgICAgICBDYWxjdWxhdGVkLnByb3RvdHlwZVtwXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIENhbGN1bGF0ZWQucHJvdG90eXBlLmhpZGRlbiA9IGZhbHNlO1xuICAgIG1vZHVsZS5leHBvcnRzW2NsYXNzTmFtZS5yZXBsYWNlKCdwYWludF8nLCAnJyldID0gQ2FsY3VsYXRlZDtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9yZWZlcmVuY2UvbGF0ZXN0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgU291cmNlID0gcmVxdWlyZSgnLi4vc291cmNlL3NvdXJjZScpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuL3N0eWxlX2xheWVyJyk7XG52YXIgSW1hZ2VTcHJpdGUgPSByZXF1aXJlKCcuL2ltYWdlX3Nwcml0ZScpO1xudmFyIEdseXBoU291cmNlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoX3NvdXJjZScpO1xudmFyIEdseXBoQXRsYXMgPSByZXF1aXJlKCcuLi9zeW1ib2wvZ2x5cGhfYXRsYXMnKTtcbnZhciBTcHJpdGVBdGxhcyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9zcHJpdGVfYXRsYXMnKTtcbnZhciBMaW5lQXRsYXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvbGluZV9hdGxhcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVTdHlsZVVSTDtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL3V0aWwvZGlzcGF0Y2hlcicpO1xudmFyIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuL2FuaW1hdGlvbl9sb29wJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvbGF0ZXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cbmZ1bmN0aW9uIFN0eWxlKHN0eWxlc2hlZXQsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSBhbmltYXRpb25Mb29wIHx8IG5ldyBBbmltYXRpb25Mb29wKCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIoTWF0aC5tYXgoYnJvd3Nlci5oYXJkd2FyZUNvbmN1cnJlbmN5IC0gMSwgMSksIHRoaXMpO1xuICAgIHRoaXMuZ2x5cGhBdGxhcyA9IG5ldyBHbHlwaEF0bGFzKDEwMjQsIDEwMjQpO1xuICAgIHRoaXMuc3ByaXRlQXRsYXMgPSBuZXcgU3ByaXRlQXRsYXMoNTEyLCA1MTIpO1xuICAgIHRoaXMuc3ByaXRlQXRsYXMucmVzaXplKGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5saW5lQXRsYXMgPSBuZXcgTGluZUF0bGFzKDI1NiwgNTEyKTtcblxuICAgIHRoaXMuX2xheWVycyA9IHt9O1xuICAgIHRoaXMuX29yZGVyICA9IFtdO1xuICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuXG4gICAgdGhpcy56b29tSGlzdG9yeSA9IHt9O1xuXG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ19mb3J3YXJkU291cmNlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRUaWxlRXZlbnQnLFxuICAgICAgICAnX3JlZG9QbGFjZW1lbnQnXG4gICAgXSwgdGhpcyk7XG5cbiAgICB2YXIgbG9hZGVkID0gZnVuY3Rpb24oZXJyLCBzdHlsZXNoZWV0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbGlkID0gdmFsaWRhdGUoc3R5bGVzaGVldCk7XG4gICAgICAgIGlmICh2YWxpZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbGlkLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuXG4gICAgICAgIHZhciBzb3VyY2VzID0gc3R5bGVzaGVldC5zb3VyY2VzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNvdXJjZShpZCwgc291cmNlc1tpZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlc2hlZXQuc3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZShzdHlsZXNoZWV0LnNwcml0ZSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZS5vbignbG9hZCcsIHRoaXMuZmlyZS5iaW5kKHRoaXMsICdjaGFuZ2UnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdseXBoU291cmNlID0gbmV3IEdseXBoU291cmNlKHN0eWxlc2hlZXQuZ2x5cGhzLCB0aGlzLmdseXBoQXRsYXMpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGlmICh0eXBlb2Ygc3R5bGVzaGVldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWpheC5nZXRKU09OKG5vcm1hbGl6ZVVSTChzdHlsZXNoZWV0KSwgbG9hZGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBicm93c2VyLmZyYW1lKGxvYWRlZC5iaW5kKHRoaXMsIG51bGwsIHN0eWxlc2hlZXQpKTtcbiAgICB9XG59XG5cblN0eWxlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgX2xvYWRlZDogZmFsc2UsXG5cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpXG4gICAgICAgICAgICBpZiAoIXRoaXMuc291cmNlc1tpZF0ubG9hZGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnNwcml0ZSAmJiAhdGhpcy5zcHJpdGUubG9hZGVkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIF9yZXNvbHZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlkLCBsYXllcjtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fb3JkZXIgID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsYXllciA9IG5ldyBTdHlsZUxheWVyKHRoaXMuc3R5bGVzaGVldC5sYXllcnNbaV0sIHRoaXMuc3R5bGVzaGVldC5jb25zdGFudHMgfHwge30pO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICAgICAgdGhpcy5fb3JkZXIucHVzaChsYXllci5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIGxheW91dCBwcm9wZXJ0aWVzLlxuICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNvbHZlTGF5b3V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZSBhbmQgcGFpbnQgcHJvcGVydGllcy5cbiAgICAgICAgZm9yIChpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0ucmVzb2x2ZVJlZmVyZW5jZSh0aGlzLl9sYXllcnMpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNvbHZlUGFpbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dyb3VwTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycygpO1xuICAgIH0sXG5cbiAgICBfZ3JvdXBMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JvdXA7XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBzID0gW107XG5cbiAgICAgICAgLy8gU3BsaXQgaW50byBncm91cHMgb2YgY29uc2VjdXRpdmUgdG9wLWxldmVsIGxheWVycyB3aXRoIHRoZSBzYW1lIHNvdXJjZS5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vcmRlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3RoaXMuX29yZGVyW2ldXTtcblxuICAgICAgICAgICAgaWYgKCFncm91cCB8fCBsYXllci5zb3VyY2UgIT09IGdyb3VwLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGdyb3VwID0gW107XG4gICAgICAgICAgICAgICAgZ3JvdXAuc291cmNlID0gbGF5ZXIuc291cmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JvdXAucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Jyb2FkY2FzdExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcmRlcmVkID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICBvcmRlcmVkLnB1c2godGhpcy5fbGF5ZXJzW2lkXS5qc29uKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdCgnc2V0IGxheWVycycsIG9yZGVyZWQpO1xuICAgIH0sXG5cbiAgICBfY2FzY2FkZTogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCkgcmV0dXJuO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0uY2FzY2FkZShjbGFzc2VzLCBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldC50cmFuc2l0aW9uIHx8IHt9LFxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgIH0sXG5cbiAgICBfcmVjYWxjdWxhdGU6IGZ1bmN0aW9uKHopIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKVxuICAgICAgICAgICAgdGhpcy5zb3VyY2VzW2lkXS51c2VkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlWm9vbUhpc3Rvcnkoeik7XG5cbiAgICAgICAgdGhpcy5yYXN0ZXJGYWRlRHVyYXRpb24gPSAzMDA7XG4gICAgICAgIGZvciAoaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXIucmVjYWxjdWxhdGUoeiwgdGhpcy56b29tSGlzdG9yeSkgJiYgbGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VzW2xheWVyLnNvdXJjZV0udXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4Wm9vbVRyYW5zaXRpb25EdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IodGhpcy56KSAhPT0gTWF0aC5mbG9vcih6KSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wLnNldChtYXhab29tVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMuZmlyZSgnem9vbScpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlWm9vbUhpc3Rvcnk6IGZ1bmN0aW9uKHopIHtcblxuICAgICAgICB2YXIgemggPSB0aGlzLnpvb21IaXN0b3J5O1xuXG4gICAgICAgIGlmICh6aC5sYXN0SW50ZWdlclpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmlyc3QgdGltZVxuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSAwO1xuICAgICAgICAgICAgemgubGFzdFpvb20gPSB6O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBhbiBpbnRlZ2VyIHpvb20gbGV2ZWwgYXMgcGFzc2VkIHNpbmNlIHRoZSBsYXN0IGZyYW1lXG4gICAgICAgIC8vIGFuZCBpZiB5ZXMsIHJlY29yZCBpdCB3aXRoIHRoZSB0aW1lLiBVc2VkIGZvciB0cmFuc2l0aW9uaW5nIHBhdHRlcm5zLlxuICAgICAgICBpZiAoTWF0aC5mbG9vcih6aC5sYXN0Wm9vbSkgPCBNYXRoLmZsb29yKHopKSB7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb20gPSBNYXRoLmZsb29yKHopO1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmZsb29yKHpoLmxhc3Rab29tKSA+IE1hdGguZmxvb3IoeikpIHtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbSA9IE1hdGguZmxvb3IoeiArIDEpO1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICB6aC5sYXN0Wm9vbSA9IHo7XG4gICAgfSxcblxuICAgIGFkZFNvdXJjZTogZnVuY3Rpb24oaWQsIHNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYSBzb3VyY2Ugd2l0aCB0aGlzIElEJyk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gU291cmNlLmNyZWF0ZShzb3VyY2UpO1xuICAgICAgICB0aGlzLnNvdXJjZXNbaWRdID0gc291cmNlO1xuICAgICAgICBzb3VyY2UuaWQgPSBpZDtcbiAgICAgICAgc291cmNlLnN0eWxlID0gdGhpcztcbiAgICAgICAgc291cmNlLmRpc3BhdGNoZXIgPSB0aGlzLmRpc3BhdGNoZXI7XG4gICAgICAgIHNvdXJjZS5nbHlwaEF0bGFzID0gdGhpcy5nbHlwaEF0bGFzO1xuICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIC5vbignbG9hZCcsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmxvYWQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KTtcbiAgICAgICAgdGhpcy5maXJlKCdzb3VyY2UuYWRkJywge3NvdXJjZTogc291cmNlfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzb3VyY2UgZnJvbSB0aGlzIHN0eWxlc2hlZXQsIGdpdmVuIGl0cyBpZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgb2YgdGhlIHNvdXJjZSB0byByZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IHRoaXMgc3R5bGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gc291cmNlIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZXNbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gc291cmNlIHdpdGggdGhpcyBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5zb3VyY2VzW2lkXTtcbiAgICAgICAgc291cmNlXG4gICAgICAgICAgICAub2ZmKCdsb2FkJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9mZignZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCdjaGFuZ2UnLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmFkZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmxvYWQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9mZigndGlsZS5lcnJvcicsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NvdXJjZS5yZW1vdmUnLCB7c291cmNlOiBzb3VyY2V9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNvdXJjZSBieSBpZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgb2YgdGhlIGRlc2lyZWQgc291cmNlXG4gICAgICogQHJldHVybnMge09iamVjdH0gc291cmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNbaWRdO1xuICAgIH0sXG5cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIsIGJlZm9yZSkge1xuICAgICAgICBpZiAodGhpcy5fbGF5ZXJzW2xheWVyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIGFscmVhZHkgYSBsYXllciB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBsYXllciA9IG5ldyBTdHlsZUxheWVyKGxheWVyLCB0aGlzLnN0eWxlc2hlZXQuY29uc3RhbnRzIHx8IHt9KTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICB0aGlzLl9vcmRlci5zcGxpY2UoYmVmb3JlID8gdGhpcy5fb3JkZXIuaW5kZXhPZihiZWZvcmUpIDogSW5maW5pdHksIDAsIGxheWVyLmlkKTtcbiAgICAgICAgbGF5ZXIucmVzb2x2ZUxheW91dCgpO1xuICAgICAgICBsYXllci5yZXNvbHZlUmVmZXJlbmNlKHRoaXMuX2xheWVycyk7XG4gICAgICAgIGxheWVyLnJlc29sdmVQYWludCgpO1xuICAgICAgICB0aGlzLl9ncm91cExheWVycygpO1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMoKTtcbiAgICAgICAgdGhpcy5maXJlKCdsYXllci5hZGQnLCB7bGF5ZXI6IGxheWVyfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsYXllciBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBpZCBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMge1N0eWxlfSB0aGlzIHN0eWxlXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW2lkXTtcbiAgICAgICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gbGF5ZXIgd2l0aCB0aGlzIElEJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXllcnNbaV0ucmVmID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG4gICAgICAgIHRoaXMuX29yZGVyLnNwbGljZSh0aGlzLl9vcmRlci5pbmRleE9mKGlkKSwgMSk7XG4gICAgICAgIHRoaXMuX2dyb3VwTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycygpO1xuICAgICAgICB0aGlzLmZpcmUoJ2xheWVyLnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxheWVyIGJ5IGlkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBpZCBvZiB0aGUgZGVzaXJlZCBsYXllclxuICAgICAqIEByZXR1cm5zIHtMYXllcn0gbGF5ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldExheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgYSBsYXllciBoYXMgYSBgcmVmYCBwcm9wZXJ0eSB0aGF0IG1ha2VzIGl0IGRlcml2ZSBzb21lIHZhbHVlc1xuICAgICAqIGZyb20gYW5vdGhlciBsYXllciwgcmV0dXJuIHRoYXQgcmVmZXJlbnQgbGF5ZXIuIE90aGVyd2lzZSxcbiAgICAgKiByZXR1cm5zIHRoZSBsYXllciBpdHNlbGYuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBsYXllcidzIGlkXG4gICAgICogQHJldHVybnMge0xheWVyfSB0aGUgcmVmZXJlbnQgbGF5ZXIgb3IgdGhlIGxheWVyIGl0c2VsZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UmVmZXJlbnRMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcihpZCk7XG4gICAgICAgIGlmIChsYXllci5yZWYpIHtcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcihsYXllci5yZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9LFxuXG4gICAgc2V0RmlsdGVyOiBmdW5jdGlvbihsYXllciwgZmlsdGVyKSB7XG4gICAgICAgIGxheWVyID0gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKTtcbiAgICAgICAgbGF5ZXIuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RMYXllcnMoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VzW2xheWVyLnNvdXJjZV0ucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxheWVyJ3MgZmlsdGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsYXllciB0aGUgbGF5ZXIgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgbGF5ZXIncyBmaWx0ZXIsIGlmIGFueVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKS5maWx0ZXI7XG4gICAgfSxcblxuICAgIHNldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGF5ZXIgPSB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXIpO1xuICAgICAgICBsYXllci5zZXRMYXlvdXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdExheWVycygpO1xuICAgICAgICB0aGlzLnNvdXJjZXNbbGF5ZXIuc291cmNlXS5yZWxvYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGF5b3V0IHByb3BlcnR5J3MgdmFsdWUgZnJvbSBhIGdpdmVuIGxheWVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVyIHRoZSBsYXllciB0byBpbnNwZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKS5nZXRMYXlvdXRQcm9wZXJ0eShuYW1lKTtcbiAgICB9LFxuXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlLCBrbGFzcykge1xuICAgICAgICB0aGlzLmdldExheWVyKGxheWVyKS5zZXRQYWludFByb3BlcnR5KG5hbWUsIHZhbHVlLCBrbGFzcyk7XG4gICAgfSxcblxuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCBrbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcihsYXllcikuZ2V0UGFpbnRQcm9wZXJ0eShuYW1lLCBrbGFzcyk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzQXQ6IGZ1bmN0aW9uKGNvb3JkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIGlmIChwYXJhbXMubGF5ZXIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5sYXllciA9IHsgaWQ6IHBhcmFtcy5sYXllciB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5hc3luY0VhY2goT2JqZWN0LmtleXModGhpcy5zb3VyY2VzKSwgZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICAgICAgICAgIHNvdXJjZS5mZWF0dXJlc0F0KGNvb3JkLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgZmVhdHVyZXMgPSBmZWF0dXJlcy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG5cbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUubGF5ZXIgPSB0aGlzLl9sYXllcnNbZmVhdHVyZS5sYXllcl0uanNvbigpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZmVhdHVyZXMpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnJlbW92ZSgpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlU291cmNlczogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzW2lkXS51cGRhdGUodHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVkb1BsYWNlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlc1tpZF0ucmVkb1BsYWNlbWVudCkgdGhpcy5zb3VyY2VzW2lkXS5yZWRvUGxhY2VtZW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZvcndhcmRTb3VyY2VFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3NvdXJjZS4nICsgZS50eXBlLCB1dGlsLmV4dGVuZCh7c291cmNlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRUaWxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3NvdXJjZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIC8vIENhbGxiYWNrcyBmcm9tIHdlYiB3b3JrZXJzXG5cbiAgICAnZ2V0IHNwcml0ZSBqc29uJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zcHJpdGU7XG4gICAgICAgIGlmIChzcHJpdGUubG9hZGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsgc3ByaXRlOiBzcHJpdGUuZGF0YSwgcmV0aW5hOiBzcHJpdGUucmV0aW5hIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ByaXRlLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZ2V0IGljb25zJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5zcHJpdGU7XG4gICAgICAgIHZhciBzcHJpdGVBdGxhcyA9IHRoaXMuc3ByaXRlQXRsYXM7XG4gICAgICAgIGlmIChzcHJpdGUubG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHNwcml0ZUF0bGFzLnNldFNwcml0ZShzcHJpdGUpO1xuICAgICAgICAgICAgc3ByaXRlQXRsYXMuYWRkSWNvbnMocGFyYW1zLmljb25zLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcHJpdGUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzcHJpdGVBdGxhcy5zZXRTcHJpdGUoc3ByaXRlKTtcbiAgICAgICAgICAgICAgICBzcHJpdGVBdGxhcy5hZGRJY29ucyhwYXJhbXMuaWNvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdnZXQgZ2x5cGhzJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdseXBoU291cmNlLmdldFNpbXBsZUdseXBocyhwYXJhbXMuZm9udHN0YWNrLCBwYXJhbXMuY29kZXBvaW50cywgcGFyYW1zLnVpZCwgY2FsbGJhY2spO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSwgY29uc3RhbnRzKSB7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnID8gY29uc3RhbnRzW3ZhbHVlXSA6IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuXG4gICAgdmFsdWUgPSByZXNvbHZlKHZhbHVlKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbaV0gaW4gY29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXNvbHZlKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZS5zdG9wcykge1xuICAgICAgICB2YWx1ZSA9IHV0aWwuZXh0ZW5kKHt9LCB2YWx1ZSk7XG4gICAgICAgIHZhbHVlLnN0b3BzID0gdmFsdWUuc3RvcHMuc2xpY2UoKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdG9wc1tpXVsxXSBpbiBjb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wc1tpXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3RvcHNbaV1bMF0sXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUuc3RvcHNbaV1bMV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydHMucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBjb25zdGFudHMpIHtcbiAgICBpZiAoIWNvbnN0YW50cylcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICByZXN1bHRba2V5XSA9IGV4cG9ydHMucmVzb2x2ZShwcm9wZXJ0aWVzW2tleV0sIGNvbnN0YW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZUNTU0NvbG9yID0gcmVxdWlyZSgnY3NzY29sb3JwYXJzZXInKS5wYXJzZUNTU0NvbG9yO1xudmFyIG1hcGJveEdMRnVuY3Rpb24gPSByZXF1aXJlKCdtYXBib3gtZ2wtZnVuY3Rpb24nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVEZWNsYXJhdGlvbjtcblxuZnVuY3Rpb24gU3R5bGVEZWNsYXJhdGlvbihyZWZlcmVuY2UsIHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gcmVmZXJlbmNlLnR5cGU7XG4gICAgdGhpcy50cmFuc2l0aW9uYWJsZSA9IHJlZmVyZW5jZS50cmFuc2l0aW9uO1xuXG4gICAgLy8gaW1tdXRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHZhbHVlLiB1c2VkIGZvciBjb21wYXJpc29uXG4gICAgdGhpcy5qc29uID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2NvbG9yJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5zdG9wcykge1xuICAgICAgICB0aGlzLnZhbHVlID0gcHJlcGFyZUNvbG9yRnVuY3Rpb24odmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUNvbG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlLmZ1bmN0aW9uID09PSAnaW50ZXJwb2xhdGVkJykge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZSA9IG1hcGJveEdMRnVuY3Rpb24uaW50ZXJwb2xhdGVkKHRoaXMudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlID0gbWFwYm94R0xGdW5jdGlvblsncGllY2V3aXNlLWNvbnN0YW50J10odGhpcy52YWx1ZSk7XG4gICAgICAgIGlmIChyZWZlcmVuY2UudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGUgPSB0cmFuc2l0aW9uZWQodGhpcy5jYWxjdWxhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uZWQoY2FsY3VsYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHosIHpoLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgZnJhY3Rpb24gPSB6ICUgMTtcbiAgICAgICAgdmFyIHQgPSBNYXRoLm1pbigoRGF0ZS5ub3coKSAtIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUpIC8gZHVyYXRpb24sIDEpO1xuICAgICAgICB2YXIgZnJvbVNjYWxlID0gMTtcbiAgICAgICAgdmFyIHRvU2NhbGUgPSAxO1xuICAgICAgICB2YXIgbWl4LCBmcm9tLCB0bztcblxuICAgICAgICBpZiAoeiA+IHpoLmxhc3RJbnRlZ2VyWm9vbSkge1xuICAgICAgICAgICAgbWl4ID0gZnJhY3Rpb24gKyAoMSAtIGZyYWN0aW9uKSAqIHQ7XG4gICAgICAgICAgICBmcm9tU2NhbGUgKj0gMjtcbiAgICAgICAgICAgIGZyb20gPSBjYWxjdWxhdGUoeiAtIDEpO1xuICAgICAgICAgICAgdG8gPSBjYWxjdWxhdGUoeik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtaXggPSAxIC0gKDEgLSB0KSAqIGZyYWN0aW9uO1xuICAgICAgICAgICAgdG8gPSBjYWxjdWxhdGUoeik7XG4gICAgICAgICAgICBmcm9tID0gY2FsY3VsYXRlKHogKyAxKTtcbiAgICAgICAgICAgIGZyb21TY2FsZSAvPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICBmcm9tU2NhbGU6IGZyb21TY2FsZSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIHRvU2NhbGU6IHRvU2NhbGUsXG4gICAgICAgICAgICB0OiBtaXhcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBwYXJzZUNvbG9yKHZhbHVlKSB7XG4gICAgaWYgKGNvbG9yQ2FjaGVbdmFsdWVdKSByZXR1cm4gY29sb3JDYWNoZVt2YWx1ZV07XG4gICAgdmFyIGNvbG9yID0gcHJlcGFyZUNvbG9yKHBhcnNlQ1NTQ29sb3IodmFsdWUpKTtcbiAgICBjb2xvckNhY2hlW3ZhbHVlXSA9IGNvbG9yO1xuICAgIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yKGMpIHtcbiAgICByZXR1cm4gW2NbMF0gLyAyNTUsIGNbMV0gLyAyNTUsIGNbMl0gLyAyNTUsIGNbM10gLyAxXTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbG9yRnVuY3Rpb24oZikge1xuICAgIHJldHVybiB1dGlsLmV4dGVuZCh7fSwgZiwge3N0b3BzOiBmLnN0b3BzLm1hcChmdW5jdGlvbihzdG9wKSB7XG4gICAgICAgIHJldHVybiBbc3RvcFswXSwgcGFyc2VDb2xvcihzdG9wWzFdKV07XG4gICAgfSl9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuL3JlZmVyZW5jZScpO1xudmFyIFN0eWxlQ29uc3RhbnQgPSByZXF1aXJlKCcuL3N0eWxlX2NvbnN0YW50Jyk7XG52YXIgU3R5bGVEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vc3R5bGVfZGVjbGFyYXRpb24nKTtcblxudmFyIGxvb2t1cCA9IHtcbiAgICBwYWludDoge30sXG4gICAgbGF5b3V0OiB7fVxufTtcblxucmVmZXJlbmNlLmxheWVyLnR5cGUudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGxvb2t1cC5wYWludFt0eXBlXSA9IG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2VbJ3BhaW50XycgKyB0eXBlXSk7XG4gICAgbG9va3VwLmxheW91dFt0eXBlXSA9IG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2VbJ2xheW91dF8nICsgdHlwZV0pO1xufSk7XG5cbmZ1bmN0aW9uIG1ha2VDb25zdHJ1Y3RvcihyZWZlcmVuY2UpIHtcbiAgICBmdW5jdGlvbiBTdHlsZURlY2xhcmF0aW9uU2V0KHByb3BlcnRpZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnMgPSB7fTtcblxuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSBjb25zdGFudHM7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzW2tdID0gU3R5bGVDb25zdGFudC5yZXNvbHZlKHByb3BlcnRpZXNba10sIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhyZWZlcmVuY2UpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSByZWZlcmVuY2Vba107XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0eWxlRGVjbGFyYXRpb25TZXQucHJvdG90eXBlLCBrLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNba10gPSBuZXcgU3R5bGVEZWNsYXJhdGlvbihwcm9wZXJ0eSwgU3R5bGVDb25zdGFudC5yZXNvbHZlKHYsIHRoaXMuX2NvbnN0YW50cykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5LnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZURlY2xhcmF0aW9uU2V0LnByb3RvdHlwZSwgayArICctdHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnNba10gPSB2O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25zW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBTdHlsZURlY2xhcmF0aW9uU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcztcbiAgICB9O1xuXG4gICAgU3R5bGVEZWNsYXJhdGlvblNldC5wcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGssIGdsb2JhbCkge1xuICAgICAgICB2YXIgdCA9IHRoaXMuX3RyYW5zaXRpb25zW2tdIHx8IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHVyYXRpb246IHV0aWwuY29hbGVzY2UodC5kdXJhdGlvbiwgZ2xvYmFsLmR1cmF0aW9uLCAzMDApLFxuICAgICAgICAgICAgZGVsYXk6IHV0aWwuY29hbGVzY2UodC5kZWxheSwgZ2xvYmFsLmRlbGF5LCAwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBTdHlsZURlY2xhcmF0aW9uU2V0LnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciB2IGluIHRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmVzdWx0W3ZdID0gdGhpcy5fdmFsdWVzW3ZdLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdCBpbiB0aGlzLl90cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgcmVzdWx0W3QgKyAnLXRyYW5zaXRpb24nXSA9IHRoaXMuX3RyYW5zaXRpb25zW3ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0eWxlRGVjbGFyYXRpb25TZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVuZGVyVHlwZSwgbGF5ZXJUeXBlLCBwcm9wZXJ0aWVzLCBjb25zdGFudHMpIHtcbiAgICByZXR1cm4gbmV3IGxvb2t1cFtyZW5kZXJUeXBlXVtsYXllclR5cGVdKHByb3BlcnRpZXMsIGNvbnN0YW50cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlQ29uc3RhbnQgPSByZXF1aXJlKCcuL3N0eWxlX2NvbnN0YW50Jyk7XG52YXIgU3R5bGVUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9zdHlsZV90cmFuc2l0aW9uJyk7XG52YXIgU3R5bGVEZWNsYXJhdGlvblNldCA9IHJlcXVpcmUoJy4vc3R5bGVfZGVjbGFyYXRpb25fc2V0Jyk7XG52YXIgTGF5b3V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vbGF5b3V0X3Byb3BlcnRpZXMnKTtcbnZhciBQYWludFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3BhaW50X3Byb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZUxheWVyO1xuXG5mdW5jdGlvbiBTdHlsZUxheWVyKGxheWVyLCBjb25zdGFudHMpIHtcbiAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgIHRoaXMuX2NvbnN0YW50cyA9IGNvbnN0YW50cztcblxuICAgIHRoaXMuaWQgPSBsYXllci5pZDtcbiAgICB0aGlzLnJlZiA9IGxheWVyLnJlZjtcblxuICAgIC8vIFJlc29sdmVkIGFuZCBjYXNjYWRlZCBwYWludCBwcm9wZXJ0aWVzLlxuICAgIHRoaXMuX3Jlc29sdmVkID0ge307IC8vIGNsYXNzIG5hbWUgLT4gU3R5bGVEZWNsYXJhdGlvblNldFxuICAgIHRoaXMuX2Nhc2NhZGVkID0ge307IC8vIHByb3BlcnR5IG5hbWUgLT4gU3R5bGVUcmFuc2l0aW9uXG5cbiAgICB0aGlzLmFzc2lnbihsYXllcik7XG59XG5cblN0eWxlTGF5ZXIucHJvdG90eXBlID0ge1xuICAgIHJlc29sdmVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dCA9IG5ldyBMYXlvdXRQcm9wZXJ0aWVzW3RoaXMudHlwZV0oXG4gICAgICAgICAgICAgICAgU3R5bGVDb25zdGFudC5yZXNvbHZlQWxsKHRoaXMuX2xheWVyLmxheW91dCwgdGhpcy5fY29uc3RhbnRzKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0Lmhhc093blByb3BlcnR5KCd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Wyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID0gJ21hcCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQuaGFzT3duUHJvcGVydHkoJ2ljb24tcm90YXRpb24tYWxpZ25tZW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10gPSAnbWFwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sYXlvdXRbbmFtZV0gPSBTdHlsZUNvbnN0YW50LnJlc29sdmUodmFsdWUsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgfSxcblxuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dFtuYW1lXTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZVJlZmVyZW5jZTogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ24obGF5ZXJzW3RoaXMucmVmXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzb2x2ZVBhaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB0aGlzLl9sYXllcikge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcC5tYXRjaCgvXnBhaW50KD86XFwuKC4qKSk/JC8pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkW21hdGNoWzFdIHx8ICcnXSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlRGVjbGFyYXRpb25TZXQoJ3BhaW50JywgdGhpcy50eXBlLCB0aGlzLl9sYXllcltwXSwgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXTtcbiAgICAgICAgaWYgKCFkZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0eWxlRGVjbGFyYXRpb25TZXQoJ3BhaW50JywgdGhpcy50eXBlLCB7fSwgdGhpcy5fY29uc3RhbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNsYXJhdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzIHx8ICcnXTtcbiAgICAgICAgaWYgKCFkZWNsYXJhdGlvbnMpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25zW25hbWVdO1xuICAgIH0sXG5cbiAgICBjYXNjYWRlOiBmdW5jdGlvbihjbGFzc2VzLCBvcHRpb25zLCBnbG9iYWxUcmFucywgYW5pbWF0aW9uTG9vcCkge1xuICAgICAgICBmb3IgKHZhciBrbGFzcyBpbiB0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKGtsYXNzICE9PSBcIlwiICYmICFjbGFzc2VzW2tsYXNzXSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHRoaXMuX3Jlc29sdmVkW2tsYXNzXSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBkZWNsYXJhdGlvbnMudmFsdWVzKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RlY2xhcmF0aW9uID0gdmFsdWVzW2tdO1xuICAgICAgICAgICAgICAgIHZhciBvbGRUcmFuc2l0aW9uID0gb3B0aW9ucy50cmFuc2l0aW9uID8gdGhpcy5fY2FzY2FkZWRba10gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIG5ldyB0cmFuc2l0aW9uIGlmIHRoZSBkZWNsYXJhdGlvbiBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRUcmFuc2l0aW9uIHx8IG9sZFRyYW5zaXRpb24uZGVjbGFyYXRpb24uanNvbiAhPT0gbmV3RGVjbGFyYXRpb24uanNvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3R5bGVUcmFucyA9IGRlY2xhcmF0aW9ucy50cmFuc2l0aW9uKGssIGdsb2JhbFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RyYW5zaXRpb24gPSB0aGlzLl9jYXNjYWRlZFtrXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3R5bGVUcmFuc2l0aW9uKG5ld0RlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCBuZXdTdHlsZVRyYW5zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIGFuaW1hdGlvbiBsb29wIHVudGlsIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdUcmFuc2l0aW9uLmluc3RhbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHJhbnNpdGlvbi5sb29wSUQgPSBhbmltYXRpb25Mb29wLnNldChuZXdUcmFuc2l0aW9uLmVuZFRpbWUgLSAobmV3IERhdGUoKSkuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Mb29wLmNhbmNlbChvbGRUcmFuc2l0aW9uLmxvb3BJRCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVjYWxjdWxhdGU6IGZ1bmN0aW9uKHosIHpvb21IaXN0b3J5KSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgICAgICAgY2FsY3VsYXRlZCA9IHRoaXMucGFpbnQgPSBuZXcgUGFpbnRQcm9wZXJ0aWVzW3R5cGVdKCk7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jYXNjYWRlZCkge1xuICAgICAgICAgICAgY2FsY3VsYXRlZFtrXSA9IHRoaXMuX2Nhc2NhZGVkW2tdLmF0KHosIHpvb21IaXN0b3J5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGlkZGVuID0gKHRoaXMubWluem9vbSAmJiB6IDwgdGhpcy5taW56b29tKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1heHpvb20gJiYgeiA+PSB0aGlzLm1heHpvb20pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSB2aXNpYmlsaXR5IGNoZWNrIGZvciBub24tYnVja2V0ZWQgYmFja2dyb3VuZCBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAodGhpcy5sYXlvdXQudmlzaWJpbGl0eSA9PT0gJ25vbmUnKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGlmICgoY2FsY3VsYXRlZFsndGV4dC1vcGFjaXR5J10gPT09IDAgfHwgIXRoaXMubGF5b3V0Wyd0ZXh0LWZpZWxkJ10pICYmXG4gICAgICAgICAgICAgICAgKGNhbGN1bGF0ZWRbJ2ljb24tb3BhY2l0eSddID09PSAwIHx8ICF0aGlzLmxheW91dFsnaWNvbi1pbWFnZSddKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbHlMYXllcihjYWxjdWxhdGVkLCAndGV4dCcpO1xuICAgICAgICAgICAgICAgIHByZW11bHRpcGx5TGF5ZXIoY2FsY3VsYXRlZCwgJ2ljb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGNhbGN1bGF0ZWRbdHlwZSArICctb3BhY2l0eSddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVtdWx0aXBseUxheWVyKGNhbGN1bGF0ZWQsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2Nhc2NhZGVkWydsaW5lLWRhc2hhcnJheSddKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbGluZSBpcyBkYXNoZWQsIHNjYWxlIHRoZSBkYXNoIGxlbmd0aHMgYnkgdGhlIGxpbmVcbiAgICAgICAgICAgIC8vIHdpZHRoIGF0IHRoZSBwcmV2aW91cyByb3VuZCB6b29tIGxldmVsLlxuICAgICAgICAgICAgdmFyIGRhc2hBcnJheSA9IGNhbGN1bGF0ZWRbJ2xpbmUtZGFzaGFycmF5J107XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5fY2FzY2FkZWRbJ2xpbmUtd2lkdGgnXSA/XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FzY2FkZWRbJ2xpbmUtd2lkdGgnXS5hdChNYXRoLmZsb29yKHopLCBJbmZpbml0eSkgOlxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRbJ2xpbmUtd2lkdGgnXTtcblxuICAgICAgICAgICAgZGFzaEFycmF5LmZyb21TY2FsZSAqPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICBkYXNoQXJyYXkudG9TY2FsZSAqPSBsaW5lV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXRoaXMuaGlkZGVuO1xuICAgIH0sXG5cbiAgICBhc3NpZ246IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhsYXllcixcbiAgICAgICAgICAgIFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJyxcbiAgICAgICAgICAgICdtaW56b29tJywgJ21heHpvb20nLCAnZmlsdGVyJyxcbiAgICAgICAgICAgICdsYXlvdXQnXSkpO1xuICAgIH0sXG5cbiAgICBqc29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHt9LFxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIsXG4gICAgICAgICAgICB1dGlsLnBpY2sodGhpcyxcbiAgICAgICAgICAgICAgICBbJ3R5cGUnLCAnc291cmNlJywgJ3NvdXJjZS1sYXllcicsXG4gICAgICAgICAgICAgICAgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLFxuICAgICAgICAgICAgICAgICdsYXlvdXQnLCAncGFpbnQnXSkpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHByZW11bHRpcGx5TGF5ZXIobGF5ZXIsIHR5cGUpIHtcbiAgICB2YXIgY29sb3JQcm9wID0gdHlwZSArICctY29sb3InLFxuICAgICAgICBoYWxvUHJvcCA9IHR5cGUgKyAnLWhhbG8tY29sb3InLFxuICAgICAgICBvdXRsaW5lUHJvcCA9IHR5cGUgKyAnLW91dGxpbmUtY29sb3InLFxuICAgICAgICBjb2xvciA9IGxheWVyW2NvbG9yUHJvcF0sXG4gICAgICAgIGhhbG9Db2xvciA9IGxheWVyW2hhbG9Qcm9wXSxcbiAgICAgICAgb3V0bGluZUNvbG9yID0gbGF5ZXJbb3V0bGluZVByb3BdLFxuICAgICAgICBvcGFjaXR5ID0gbGF5ZXJbdHlwZSArICctb3BhY2l0eSddO1xuXG4gICAgdmFyIGNvbG9yT3BhY2l0eSA9IGNvbG9yICYmIChvcGFjaXR5ICogY29sb3JbM10pO1xuICAgIHZhciBoYWxvT3BhY2l0eSA9IGhhbG9Db2xvciAmJiAob3BhY2l0eSAqIGhhbG9Db2xvclszXSk7XG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gb3V0bGluZUNvbG9yICYmIChvcGFjaXR5ICogb3V0bGluZUNvbG9yWzNdKTtcblxuICAgIGlmIChjb2xvck9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBjb2xvck9wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW2NvbG9yUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBjb2xvck9wYWNpdHldKTtcbiAgICB9XG4gICAgaWYgKGhhbG9PcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgaGFsb09wYWNpdHkgPCAxKSB7XG4gICAgICAgIGxheWVyW2hhbG9Qcm9wXSA9IHV0aWwucHJlbXVsdGlwbHkoW2hhbG9Db2xvclswXSwgaGFsb0NvbG9yWzFdLCBoYWxvQ29sb3JbMl0sIGhhbG9PcGFjaXR5XSk7XG4gICAgfVxuICAgIGlmIChvdXRsaW5lT3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG91dGxpbmVPcGFjaXR5IDwgMSkge1xuICAgICAgICBsYXllcltvdXRsaW5lUHJvcF0gPSB1dGlsLnByZW11bHRpcGx5KFtvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eV0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZVRyYW5zaXRpb247XG5cbi8qXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNpdGlvbiBiZXR3ZWVuIHR3byBkZWNsYXJhdGlvbnNcbiAqL1xuZnVuY3Rpb24gU3R5bGVUcmFuc2l0aW9uKGRlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCB2YWx1ZSkge1xuXG4gICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5lbmRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIHZhciB0eXBlID0gZGVjbGFyYXRpb24udHlwZTtcbiAgICBpZiAoKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdhcnJheScpICYmIGRlY2xhcmF0aW9uLnRyYW5zaXRpb25hYmxlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwWm9vbVRyYW5zaXRpb25lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycG9sYXRlW3R5cGVdO1xuICAgIH1cblxuICAgIHRoaXMub2xkVHJhbnNpdGlvbiA9IG9sZFRyYW5zaXRpb247XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZhbHVlLmR1cmF0aW9uIHx8IDA7XG4gICAgdGhpcy5kZWxheSA9IHZhbHVlLmRlbGF5IHx8IDA7XG5cbiAgICBpZiAoIXRoaXMuaW5zdGFudCgpKSB7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lICsgdGhpcy5kdXJhdGlvbiArIHRoaXMuZGVsYXk7XG4gICAgICAgIHRoaXMuZWFzZSA9IHV0aWwuZWFzZUN1YmljSW5PdXQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFRyYW5zaXRpb24gJiYgb2xkVHJhbnNpdGlvbi5lbmRUaW1lIDw9IHRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE9sZCB0cmFuc2l0aW9uIGlzIGRvbmUgcnVubmluZywgc28gd2UgY2FuXG4gICAgICAgIC8vIGRlbGV0ZSBpdHMgcmVmZXJlbmNlIHRvIGl0cyBvbGQgdHJhbnNpdGlvbi5cblxuICAgICAgICBkZWxldGUgb2xkVHJhbnNpdGlvbi5vbGRUcmFuc2l0aW9uO1xuICAgIH1cbn1cblxuU3R5bGVUcmFuc2l0aW9uLnByb3RvdHlwZS5pbnN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLm9sZFRyYW5zaXRpb24gfHwgIXRoaXMuaW50ZXJwIHx8ICh0aGlzLmR1cmF0aW9uID09PSAwICYmIHRoaXMuZGVsYXkgPT09IDApO1xufTtcblxuLypcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHRyYW5zaXRpb25pbmcgcHJvcGVydHkgYXQgem9vbSBsZXZlbCBgemAgYW5kIG9wdGlvbmFsIHRpbWUgYHRgXG4gKi9cblN0eWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbih6LCB6b29tSGlzdG9yeSwgdCkge1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5kZWNsYXJhdGlvbi5jYWxjdWxhdGUoeiwgem9vbUhpc3RvcnksIHRoaXMuZHVyYXRpb24pO1xuXG4gICAgaWYgKHRoaXMuaW5zdGFudCgpKSByZXR1cm4gdmFsdWU7XG5cbiAgICB0ID0gdCB8fCBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHQgPCB0aGlzLmVuZFRpbWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5vbGRUcmFuc2l0aW9uLmF0KHosIHpvb21IaXN0b3J5LCB0aGlzLnN0YXJ0VGltZSk7XG4gICAgICAgIHZhciBlYXNlZCA9IHRoaXMuZWFzZSgodCAtIHRoaXMuc3RhcnRUaW1lIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmludGVycChvbGRWYWx1ZSwgdmFsdWUsIGVhc2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG5cbn07XG5cbmZ1bmN0aW9uIGludGVycFpvb21UcmFuc2l0aW9uZWQoZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmcm9tLnRvLFxuICAgICAgICBmcm9tU2NhbGU6IGZyb20udG9TY2FsZSxcbiAgICAgICAgdG86IHRvLnRvLFxuICAgICAgICB0b1NjYWxlOiB0by50b1NjYWxlLFxuICAgICAgICB0OiB0XG4gICAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmNob3I7XG5cbmZ1bmN0aW9uIEFuY2hvcih4LCB5LCBhbmdsZSwgc2VnbWVudCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGU7XG5cbiAgICBpZiAoc2VnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxufVxuXG5BbmNob3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb2ludC5wcm90b3R5cGUpO1xuXG5BbmNob3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBBbmNob3IodGhpcy54LCB0aGlzLnksIHRoaXMuYW5nbGUsIHRoaXMuc2VnbWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJpblBhY2s7XG5mdW5jdGlvbiBCaW5QYWNrKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5mcmVlID0gW3sgeDogMCwgeTogMCwgdzogd2lkdGgsIGg6IGhlaWdodCB9XTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgYWxnb3JpdGhtIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBuZXdseSByZWxlYXNlZCBjZWxsIHdpdGggaXRzXG4gKiBuZWlnaGJvci4gVGhpcyBkb2Vzbid0IG1lcmdlIG1vcmUgdGhhbiB0d28gY2VsbHMgYXQgYSB0aW1lLCBhbmQgZmFpbHNcbiAqIGZvciBjb21wbGljYXRlZCBtZXJnZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5CaW5QYWNrLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmcmVlID0gdGhpcy5mcmVlW2ldO1xuXG4gICAgICAgIGlmIChmcmVlLnkgPT09IHJlY3QueSAmJiBmcmVlLmggPT09IHJlY3QuaCAmJiBmcmVlLnggKyBmcmVlLncgPT09IHJlY3QueCkge1xuICAgICAgICAgICAgZnJlZS53ICs9IHJlY3QudztcblxuICAgICAgICB9IGVsc2UgaWYgKGZyZWUueCA9PT0gcmVjdC54ICYmIGZyZWUudyA9PT0gcmVjdC53ICYmIGZyZWUueSArIGZyZWUuaCA9PT0gcmVjdC55KSB7XG4gICAgICAgICAgICBmcmVlLmggKz0gcmVjdC5oO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjdC55ID09PSBmcmVlLnkgJiYgcmVjdC5oID09PSBmcmVlLmggJiYgcmVjdC54ICsgcmVjdC53ID09PSBmcmVlLngpIHtcbiAgICAgICAgICAgIGZyZWUueCA9IHJlY3QueDtcbiAgICAgICAgICAgIGZyZWUudyArPSByZWN0Lnc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWN0LnggPT09IGZyZWUueCAmJiByZWN0LncgPT09IGZyZWUudyAmJiByZWN0LnkgKyByZWN0LmggPT09IGZyZWUueSkge1xuICAgICAgICAgICAgZnJlZS55ID0gcmVjdC55O1xuICAgICAgICAgICAgZnJlZS5oICs9IHJlY3QuaDtcblxuICAgICAgICB9IGVsc2UgY29udGludWU7XG5cbiAgICAgICAgdGhpcy5mcmVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5yZWxlYXNlKGZyZWUpO1xuICAgICAgICByZXR1cm47XG5cbiAgICB9XG4gICAgdGhpcy5mcmVlLnB1c2gocmVjdCk7XG59O1xuXG5CaW5QYWNrLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBmcmVlIHJlY3QgYW5nbGVcbiAgICB2YXIgcmVjdCA9IHsgeDogSW5maW5pdHksIHk6IEluZmluaXR5LCB3OiBJbmZpbml0eSwgaDogSW5maW5pdHkgfTtcbiAgICB2YXIgc21hbGxlc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5mcmVlW2ldO1xuICAgICAgICBpZiAod2lkdGggPD0gcmVmLncgJiYgaGVpZ2h0IDw9IHJlZi5oICYmIHJlZi55IDw9IHJlY3QueSAmJiByZWYueCA8PSByZWN0LngpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWY7XG4gICAgICAgICAgICBzbWFsbGVzdCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc21hbGxlc3QgPCAwKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gc3BhY2UgbGVmdCBmb3IgdGhpcyBjaGFyLlxuICAgICAgICByZXR1cm4geyB4OiAtMSwgeTogLTEgfTtcbiAgICB9XG5cbiAgICB0aGlzLmZyZWUuc3BsaWNlKHNtYWxsZXN0LCAxKTtcblxuICAgIC8vIFNob3J0ZXIvTG9uZ2VyIEF4aXMgU3BsaXQgUnVsZSAoU0FTKVxuICAgIC8vIGh0dHA6Ly9jbGIuZGVtb24uZmkvZmlsZXMvUmVjdGFuZ2xlQmluUGFjay5wZGYgcC4gMTVcbiAgICAvLyBJZ25vcmUgdGhlIGRpbWVuc2lvbiBvZiBSIGFuZCBqdXN0IHNwbGl0IGxvbmcgdGhlIHNob3J0ZXIgZGltZW5zaW9uXG4gICAgLy8gU2VlIEFsc286IGh0dHA6Ly93d3cuY3MucHJpbmNldG9uLmVkdS9+Y2hhemVsbGUvcHVicy9ibGJpbnBhY2tpbmcucGRmXG4gICAgaWYgKHJlY3QudyA8IHJlY3QuaCkge1xuICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHlcbiAgICAgICAgLy8gKy0tKy0tLStcbiAgICAgICAgLy8gfF9ffF9fX3wgIDwtLSBiMVxuICAgICAgICAvLyArLS0tLS0tKyAgPC0tIGIyXG4gICAgICAgIGlmIChyZWN0LncgPiB3aWR0aCkgdGhpcy5mcmVlLnB1c2goeyB4OiByZWN0LnggKyB3aWR0aCwgeTogcmVjdC55LCB3OiByZWN0LncgLSB3aWR0aCwgaDogaGVpZ2h0IH0pO1xuICAgICAgICBpZiAocmVjdC5oID4gaGVpZ2h0KSB0aGlzLmZyZWUucHVzaCh7IHg6IHJlY3QueCwgeTogcmVjdC55ICsgaGVpZ2h0LCB3OiByZWN0LncsIGg6IHJlY3QuaCAtIGhlaWdodCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzcGxpdCB2ZXJ0aWNhbGx5XG4gICAgICAgIC8vICstLSstLS0rXG4gICAgICAgIC8vIHxfX3wgICB8IDwtLSBiMVxuICAgICAgICAvLyArLS18LS0tKyA8LS0gYjJcbiAgICAgICAgaWYgKHJlY3QudyA+IHdpZHRoKSB0aGlzLmZyZWUucHVzaCh7IHg6IHJlY3QueCArIHdpZHRoLCB5OiByZWN0LnksIHc6IHJlY3QudyAtIHdpZHRoLCBoOiByZWN0LmggfSk7XG4gICAgICAgIGlmIChyZWN0LmggPiBoZWlnaHQpIHRoaXMuZnJlZS5wdXNoKHsgeDogcmVjdC54LCB5OiByZWN0LnkgKyBoZWlnaHQsIHc6IHdpZHRoLCBoOiByZWN0LmggLSBoZWlnaHQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgeDogcmVjdC54LCB5OiByZWN0LnksIHc6IHdpZHRoLCBoOiBoZWlnaHQgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tNYXhBbmdsZTtcblxuZnVuY3Rpb24gY2hlY2tNYXhBbmdsZShsaW5lLCBhbmNob3IsIGxhYmVsTGVuZ3RoLCB3aW5kb3dTaXplLCBtYXhBbmdsZSkge1xuXG4gICAgLy8gaG9yaXpvbnRhbCBsYWJlbHMgYWx3YXlzIHBhc3NcbiAgICBpZiAoYW5jaG9yLnNlZ21lbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgcCA9IGFuY2hvcjtcbiAgICB2YXIgaW5kZXggPSBhbmNob3Iuc2VnbWVudCArIDE7XG4gICAgdmFyIGFuY2hvckRpc3RhbmNlID0gMDtcblxuICAgIC8vIG1vdmUgYmFja3dhcmRzIGFsb25nIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBzZWdtZW50IHRoZSBsYWJlbCBhcHBlYXJzIG9uXG4gICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlID4gLWxhYmVsTGVuZ3RoIC8gMikge1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYWZ0ZXIgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgYW5jaG9yRGlzdGFuY2UgLT0gbGluZVtpbmRleF0uZGlzdChwKTtcbiAgICAgICAgcCA9IGxpbmVbaW5kZXhdO1xuICAgIH1cblxuICAgIGFuY2hvckRpc3RhbmNlICs9IGxpbmVbaW5kZXhdLmRpc3QobGluZVtpbmRleCArIDFdKTtcbiAgICBpbmRleCsrO1xuXG4gICAgLy8gc3RvcmUgcmVjZW50IGNvcm5lcnMgYW5kIHRoZWlyIHRvdGFsIGFuZ2xlIGRpZmZlcmVuY2VcbiAgICB2YXIgcmVjZW50Q29ybmVycyA9IFtdO1xuICAgIHZhciByZWNlbnRBbmdsZURlbHRhID0gMDtcblxuICAgIC8vIG1vdmUgZm9yd2FyZHMgYnkgdGhlIGxlbmd0aCBvZiB0aGUgbGFiZWwgYW5kIGNoZWNrIGFuZ2xlcyBhbG9uZyB0aGUgd2F5XG4gICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIDwgbGFiZWxMZW5ndGggLyAyKSB7XG4gICAgICAgIHZhciBwcmV2ID0gbGluZVtpbmRleCAtIDFdO1xuICAgICAgICB2YXIgY3VycmVudCA9IGxpbmVbaW5kZXhdO1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVbaW5kZXggKyAxXTtcblxuICAgICAgICAvLyB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgdGhlIGxhYmVsIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmICghbmV4dCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBhbmdsZURlbHRhID0gcHJldi5hbmdsZVRvKGN1cnJlbnQpIC0gY3VycmVudC5hbmdsZVRvKG5leHQpO1xuICAgICAgICAvLyByZXN0cmljdCBhbmdsZSB0byAtcGkuLnBpIHJhbmdlXG4gICAgICAgIGFuZ2xlRGVsdGEgPSAoKGFuZ2xlRGVsdGEgKyAzICogTWF0aC5QSSkgJSAoTWF0aC5QSSAqIDIpKSAtIE1hdGguUEk7XG5cbiAgICAgICAgcmVjZW50Q29ybmVycy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3RhbmNlOiBhbmNob3JEaXN0YW5jZSxcbiAgICAgICAgICAgIGFuZ2xlRGVsdGE6IGFuZ2xlRGVsdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgKz0gYW5nbGVEZWx0YTtcblxuICAgICAgICAvLyByZW1vdmUgY29ybmVycyB0aGF0IGFyZSBmYXIgZW5vdWdoIGF3YXkgZnJvbSB0aGUgbGlzdCBvZiByZWNlbnQgYW5jaG9yc1xuICAgICAgICB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgLSByZWNlbnRDb3JuZXJzWzBdLmRpc3RhbmNlID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgcmVjZW50QW5nbGVEZWx0YSAtPSByZWNlbnRDb3JuZXJzLnNoaWZ0KCkuYW5nbGVEZWx0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBzdW0gb2YgYW5nbGVzIHdpdGhpbiB0aGUgd2luZG93IGFyZWEgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLiBjaGVjayBmYWlscy5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJlY2VudEFuZ2xlRGVsdGEpID4gbWF4QW5nbGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBhbmNob3JEaXN0YW5jZSArPSBjdXJyZW50LmRpc3QobmV4dCk7XG4gICAgfVxuXG4gICAgLy8gbm8gcGFydCBvZiB0aGUgbGluZSBoYWQgYW4gYW5nbGUgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQuIGNoZWNrIHBhc3Nlcy5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwTGluZTtcblxuZnVuY3Rpb24gY2xpcExpbmUobGluZXMsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGNsaXBwZWRMaW5lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgICB2YXIgY2xpcHBlZExpbmU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAwID0gbGluZVtpXTtcbiAgICAgICAgICAgIHZhciBwMSA9IGxpbmVbaSArIDFdO1xuXG5cbiAgICAgICAgICAgIGlmIChwMC54IDwgeDEgJiYgcDEueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHgxLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDEgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueCA8IHgxKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQoeDEsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MSAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueSA8IHkxICYmIHAxLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTEgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnkgPCB5MSkge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHAwLnggKyAocDEueCAtIHAwLngpICogKCh5MSAtIHAwLnkpIC8gKHAxLnkgLSBwMC55KSksIHkxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnggPj0geDIgJiYgcDEueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQoeDIsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MiAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS54ID49IHgyKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQoeDIsIHAwLnkgKyAocDEueSAtIHAwLnkpICogKCh4MiAtIHAwLngpIC8gKHAxLnggLSBwMC54KSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocDAueSA+PSB5MiAmJiBwMS55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAwLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTIgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5Mik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnkgPj0geTIpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTIgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5Mik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2xpcHBlZExpbmUgfHwgIXAwLmVxdWFscyhjbGlwcGVkTGluZVtjbGlwcGVkTGluZS5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgICAgICBjbGlwcGVkTGluZSA9IFtwMF07XG4gICAgICAgICAgICAgICAgY2xpcHBlZExpbmVzLnB1c2goY2xpcHBlZExpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGlwcGVkTGluZS5wdXNoKHAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGlwcGVkTGluZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uQm94O1xuXG5mdW5jdGlvbiBDb2xsaXNpb25Cb3goYW5jaG9yLCB4MSwgeTEsIHgyLCB5MiwgbWF4U2NhbGUpIHtcbiAgICAvLyB0aGUgYm94IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG5cbiAgICAvLyBkaXN0YW5jZXMgdG8gdGhlIGVkZ2VzIGZyb20gdGhlIGFuY2hvclxuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy54MiA9IHgyO1xuICAgIHRoaXMueTIgPSB5MjtcblxuICAgIC8vIHRoZSBib3ggaXMgb25seSB2YWxpZCBmb3Igc2NhbGVzIDwgbWF4U2NhbGUuXG4gICAgLy8gVGhlIGJveCBkb2VzIG5vdCBibG9jayBvdGhlciBib3hlcyBhdCBzY2FsZXMgPj0gbWF4U2NhbGU7XG4gICAgdGhpcy5tYXhTY2FsZSA9IG1heFNjYWxlO1xuXG4gICAgLy8gdGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBsYWJlbCBjYW4gZmlyc3QgYmUgc2hvd25cbiAgICB0aGlzLnBsYWNlbWVudFNjYWxlID0gMDtcblxuICAgIC8vIHJvdGF0ZWQgYW5kIHNjYWxlZCBiYm94IHVzZWQgZm9yIGluZGV4aW5nXG4gICAgdGhpc1swXSA9IHRoaXNbMV0gPSB0aGlzWzJdID0gdGhpc1szXSA9IDA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb2xsaXNpb25Cb3ggPSByZXF1aXJlKCcuL2NvbGxpc2lvbl9ib3gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25GZWF0dXJlO1xuXG5mdW5jdGlvbiBDb2xsaXNpb25GZWF0dXJlKGxpbmUsIGFuY2hvciwgc2hhcGVkLCBib3hTY2FsZSwgcGFkZGluZywgYWxpZ25MaW5lKSB7XG5cbiAgICB2YXIgeTEgPSBzaGFwZWQudG9wICogYm94U2NhbGUgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHNoYXBlZC5ib3R0b20gKiBib3hTY2FsZSArIHBhZGRpbmc7XG4gICAgdmFyIHgxID0gc2hhcGVkLmxlZnQgKiBib3hTY2FsZSAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gc2hhcGVkLnJpZ2h0ICogYm94U2NhbGUgKyBwYWRkaW5nO1xuXG4gICAgdGhpcy5ib3hlcyA9IFtdO1xuXG4gICAgaWYgKGFsaWduTGluZSkge1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgbGVuZ3RoID0geDIgLSB4MTtcblxuICAgICAgICBpZiAoaGVpZ2h0IDw9IDApIHJldHVybjtcblxuICAgICAgICAvLyBzZXQgbWluaW11bSBib3ggaGVpZ2h0IHRvIGF2b2lkIHZlcnkgbWFueSBzbWFsbCBsYWJlbHNcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMTAgKiBib3hTY2FsZSwgaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLmJib3hpZnlMYWJlbChsaW5lLCBhbmNob3IsIGxlbmd0aCwgaGVpZ2h0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm94ZXMucHVzaChuZXcgQ29sbGlzaW9uQm94KGFuY2hvciwgeDEsIHkxLCB4MiwgeTIsIEluZmluaXR5KSk7XG4gICAgfVxufVxuXG5Db2xsaXNpb25GZWF0dXJlLnByb3RvdHlwZS5iYm94aWZ5TGFiZWwgPSBmdW5jdGlvbihsaW5lLCBhbmNob3IsIGxhYmVsTGVuZ3RoLCBib3hTaXplKSB7XG4gICAgdmFyIHN0ZXAgPSBib3hTaXplIC8gMjtcbiAgICB2YXIgbkJveGVzID0gTWF0aC5mbG9vcihsYWJlbExlbmd0aCAvIHN0ZXApO1xuXG4gICAgLy8gb2Zmc2V0IHRoZSBjZW50ZXIgb2YgdGhlIGZpcnN0IGJveCBieSBoYWxmIGEgYm94IHNvIHRoYXQgdGhlIGVkZ2Ugb2YgdGhlXG4gICAgLy8gYm94IGlzIGF0IHRoZSBlZGdlIG9mIHRoZSBsYWJlbC5cbiAgICB2YXIgZmlyc3RCb3hPZmZzZXQgPSAtYm94U2l6ZSAvIDI7XG5cbiAgICB2YXIgYmJveGVzID0gdGhpcy5ib3hlcztcblxuICAgIHZhciBwID0gYW5jaG9yO1xuICAgIHZhciBpbmRleCA9IGFuY2hvci5zZWdtZW50ICsgMTtcbiAgICB2YXIgYW5jaG9yRGlzdGFuY2UgPSBmaXJzdEJveE9mZnNldDtcblxuICAgIC8vIG1vdmUgYmFja3dhcmRzIGFsb25nIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBzZWdtZW50IHRoZSBsYWJlbCBhcHBlYXJzIG9uXG4gICAgZG8ge1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYWZ0ZXIgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgICAvLyBjaGVja01heEFuZ2xlIHNob3VsZCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoaXNcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIGJib3hlcztcblxuICAgICAgICBhbmNob3JEaXN0YW5jZSAtPSBsaW5lW2luZGV4XS5kaXN0KHApO1xuICAgICAgICBwID0gbGluZVtpbmRleF07XG4gICAgfSB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPiAtbGFiZWxMZW5ndGggLyAyKTtcblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQm94ZXM7IGkrKykge1xuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhlIGJveCB3aWxsIGJlIGZyb20gdGhlIGFuY2hvclxuICAgICAgICB2YXIgYm94RGlzdGFuY2VUb0FuY2hvciA9IC1sYWJlbExlbmd0aCAvIDIgKyBpICogc3RlcDtcblxuICAgICAgICAvLyB0aGUgYm94IGlzIG5vdCBvbiB0aGUgY3VycmVudCBzZWdtZW50LiBNb3ZlIHRvIHRoZSBuZXh0IHNlZ21lbnQuXG4gICAgICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSArIHNlZ21lbnRMZW5ndGggPCBib3hEaXN0YW5jZVRvQW5jaG9yKSB7XG4gICAgICAgICAgICBhbmNob3JEaXN0YW5jZSArPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgICAgLy8gVGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gYmVmb3JlIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IGxpbmUubGVuZ3RoKSByZXR1cm4gYmJveGVzO1xuXG4gICAgICAgICAgICBzZWdtZW50TGVuZ3RoID0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGRpc3RhbmNlIHRoZSBib3ggd2lsbCBiZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgdmFyIHNlZ21lbnRCb3hEaXN0YW5jZSA9IGJveERpc3RhbmNlVG9BbmNob3IgLSBhbmNob3JEaXN0YW5jZTtcblxuICAgICAgICB2YXIgcDAgPSBsaW5lW2luZGV4XTtcbiAgICAgICAgdmFyIHAxID0gbGluZVtpbmRleCArIDFdO1xuICAgICAgICB2YXIgYm94QW5jaG9yID0gcDEuc3ViKHAwKS5fdW5pdCgpLl9tdWx0KHNlZ21lbnRCb3hEaXN0YW5jZSkuX2FkZChwMCk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Jbm5lckVkZ2UgPSBNYXRoLm1heChNYXRoLmFicyhib3hEaXN0YW5jZVRvQW5jaG9yIC0gZmlyc3RCb3hPZmZzZXQpIC0gc3RlcCAvIDIsIDApO1xuICAgICAgICB2YXIgbWF4U2NhbGUgPSBsYWJlbExlbmd0aCAvIDIgLyBkaXN0YW5jZVRvSW5uZXJFZGdlO1xuXG4gICAgICAgIGJib3hlcy5wdXNoKG5ldyBDb2xsaXNpb25Cb3goYm94QW5jaG9yLCAtYm94U2l6ZSAvIDIsIC1ib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBtYXhTY2FsZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94ZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmJ1c2ggPSByZXF1aXJlKCdyYnVzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvblRpbGU7XG5cbmZ1bmN0aW9uIENvbGxpc2lvblRpbGUoem9vbSwgdGlsZUV4dGVudCwgdGlsZVNpemUpIHtcbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIHRoaXMudGlsZVBpeGVsUmF0aW8gPSB0aWxlRXh0ZW50IC8gdGlsZVNpemU7XG59XG5cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLm1pblNjYWxlID0gMC4yNTtcbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLm1heFNjYWxlID0gMjtcblxuQ29sbGlzaW9uVGlsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihhbmdsZSwgcGl0Y2gpIHtcbiAgICB0aGlzLnRyZWUgPSByYnVzaCgpO1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcblxuICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgLy8gU3RyZXRjaCBib3hlcyBpbiB5IGRpcmVjdGlvbiB0byBhY2NvdW50IGZvciB0aGUgbWFwIHRpbHQuXG4gICAgdGhpcy55U3RyZXRjaCA9IDEgLyBNYXRoLmNvcyhwaXRjaCAvIDE4MCAqIE1hdGguUEkpO1xuXG4gICAgLy8gVGhlIGFtb3VudCB0aGUgbWFwIGlzIHNxdWlzaGVkIGRlcGVuZHMgb24gdGhlIHkgcG9zaXRpb24uXG4gICAgLy8gU29ydCBvZiBhY2NvdW50IGZvciB0aGlzIGJ5IG1ha2luZyBhbGwgYm94ZXMgYSBiaXQgYmlnZ2VyLlxuICAgIHRoaXMueVN0cmV0Y2ggPSBNYXRoLnBvdyh0aGlzLnlTdHJldGNoLCAxLjMpO1xufTtcblxuQ29sbGlzaW9uVGlsZS5wcm90b3R5cGUucGxhY2VGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuXG4gICAgdmFyIG1pblBsYWNlbWVudFNjYWxlID0gdGhpcy5taW5TY2FsZTtcbiAgICB2YXIgcm90YXRpb25NYXRyaXggPSB0aGlzLnJvdGF0aW9uTWF0cml4O1xuICAgIHZhciB5U3RyZXRjaCA9IHRoaXMueVN0cmV0Y2g7XG5cbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGZlYXR1cmUuYm94ZXMubGVuZ3RoOyBiKyspIHtcblxuICAgICAgICB2YXIgYm94ID0gZmVhdHVyZS5ib3hlc1tiXTtcblxuICAgICAgICB2YXIgYW5jaG9yID0gYm94LmFuY2hvci5tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcbiAgICAgICAgdmFyIHggPSBhbmNob3IueDtcbiAgICAgICAgdmFyIHkgPSBhbmNob3IueTtcblxuICAgICAgICBib3hbMF0gPSB4ICsgYm94LngxO1xuICAgICAgICBib3hbMV0gPSB5ICsgYm94LnkxICogeVN0cmV0Y2g7XG4gICAgICAgIGJveFsyXSA9IHggKyBib3gueDI7XG4gICAgICAgIGJveFszXSA9IHkgKyBib3gueTIgKiB5U3RyZXRjaDtcblxuICAgICAgICB2YXIgYmxvY2tpbmdCb3hlcyA9IHRoaXMudHJlZS5zZWFyY2goYm94KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NraW5nQm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBibG9ja2luZyA9IGJsb2NraW5nQm94ZXNbaV07XG4gICAgICAgICAgICB2YXIgYmxvY2tpbmdBbmNob3IgPSBibG9ja2luZy5hbmNob3IubWF0TXVsdChyb3RhdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxvd2VzdCBzY2FsZSBhdCB3aGljaCB0aGUgdHdvIGJveGVzIGNhbiBmaXQgc2lkZSBieSBzaWRlIHdpdGhvdXQgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBhbGdvcml0aG06XG4gICAgICAgICAgICB2YXIgczEgPSAoYmxvY2tpbmcueDEgLSBib3gueDIpIC8gKHggLSBibG9ja2luZ0FuY2hvci54KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgbGVmdCBvZiBvbGQgYm94XG4gICAgICAgICAgICB2YXIgczIgPSAoYmxvY2tpbmcueDIgLSBib3gueDEpIC8gKHggLSBibG9ja2luZ0FuY2hvci54KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgcmlnaHQgb2Ygb2xkIGJveFxuICAgICAgICAgICAgdmFyIHMzID0gKGJsb2NraW5nLnkxIC0gYm94LnkyKSAqIHlTdHJldGNoIC8gKHkgLSBibG9ja2luZ0FuY2hvci55KTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgdG9wIG9mIG9sZCBib3hcbiAgICAgICAgICAgIHZhciBzNCA9IChibG9ja2luZy55MiAtIGJveC55MSkgKiB5U3RyZXRjaCAvICh5IC0gYmxvY2tpbmdBbmNob3IueSk7IC8vIHNjYWxlIGF0IHdoaWNoIG5ldyBib3ggaXMgdG8gdGhlIGJvdHRvbSBvZiBvbGQgYm94XG5cbiAgICAgICAgICAgIGlmIChpc05hTihzMSkgfHwgaXNOYU4oczIpKSBzMSA9IHMyID0gMTtcbiAgICAgICAgICAgIGlmIChpc05hTihzMykgfHwgaXNOYU4oczQpKSBzMyA9IHM0ID0gMTtcblxuICAgICAgICAgICAgdmFyIGNvbGxpc2lvbkZyZWVTY2FsZSA9IE1hdGgubWluKE1hdGgubWF4KHMxLCBzMiksIE1hdGgubWF4KHMzLCBzNCkpO1xuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gYmxvY2tpbmcubWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciBhIGJveCdzIG1heFNjYWxlIHRoZSBsYWJlbCBoYXMgc2hydW5rIGVub3VnaCB0aGF0IHRoZSBib3ggaXMgbm8gbG9uZ2VyIG5lZWRlZCB0byBjb3ZlciBpdCxcbiAgICAgICAgICAgICAgICAvLyBzbyB1bmJsb2NrIHRoZSBuZXcgYm94IGF0IHRoZSBzY2FsZSB0aGF0IHRoZSBvbGQgYm94IGRpc2FwcGVhcnMuXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlID0gYmxvY2tpbmcubWF4U2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2xsaXNpb25GcmVlU2NhbGUgPiBib3gubWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYm94IGNhbiBvbmx5IGJlIHNob3duIGFmdGVyIGl0IGlzIHZpc2libGUsIHRoZW4gdGhlIGJveCBjYW4gbmV2ZXIgYmUgc2hvd24uXG4gICAgICAgICAgICAgICAgLy8gQnV0IHRoZSBsYWJlbCBjYW4gYmUgc2hvd24gYWZ0ZXIgdGhpcyBib3ggaXMgbm90IHZpc2libGUuXG4gICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlID0gYm94Lm1heFNjYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uRnJlZVNjYWxlID4gbWluUGxhY2VtZW50U2NhbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlID49IGJsb2NraW5nLnBsYWNlbWVudFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBjb2xsaXNpb24gb2NjdXJzIGF0IGEgbG93ZXIgc2NhbGUgdGhhbiBwcmV2aW91c2x5IGZvdW5kIGNvbGxpc2lvbnNcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGNvbGxpc2lvbiBvY2N1cnMgd2hpbGUgdGhlIG90aGVyIGxhYmVsIGlzIHZpc2libGVcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdGhpcyBpcyB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSBsYWJlbCB3b24ndCBjb2xsaWRlIHdpdGggYW55dGhpbmdcbiAgICAgICAgICAgICAgICBtaW5QbGFjZW1lbnRTY2FsZSA9IGNvbGxpc2lvbkZyZWVTY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pblBsYWNlbWVudFNjYWxlID49IHRoaXMubWF4U2NhbGUpIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbn07XG5cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLmluc2VydEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBtaW5QbGFjZW1lbnRTY2FsZSkge1xuXG4gICAgdmFyIGJveGVzID0gZmVhdHVyZS5ib3hlcztcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJveGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGJveGVzW2tdLnBsYWNlbWVudFNjYWxlID0gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKG1pblBsYWNlbWVudFNjYWxlIDwgdGhpcy5tYXhTY2FsZSkge1xuICAgICAgICB0aGlzLnRyZWUubG9hZChib3hlcyk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGludGVycG9sYXRlID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnBvbGF0ZScpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBjaGVja01heEFuZ2xlID0gcmVxdWlyZSgnLi9jaGVja19tYXhfYW5nbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbmNob3JzO1xuXG5mdW5jdGlvbiBnZXRBbmNob3JzKGxpbmUsIHNwYWNpbmcsIG1heEFuZ2xlLCBzaGFwZWRUZXh0LCBnbHlwaFNpemUsIGJveFNjYWxlLCBvdmVyc2NhbGluZykge1xuXG4gICAgLy8gUmVzYW1wbGUgYSBsaW5lIHRvIGdldCBhbmNob3IgcG9pbnRzIGZvciBsYWJlbHMgYW5kIGNoZWNrIHRoYXQgZWFjaFxuICAgIC8vIHBvdGVudGlhbCBsYWJlbCBwYXNzZXMgdGV4dC1tYXgtYW5nbGUgY2hlY2sgYW5kIGhhcyBlbm91Z2ggZnJvb20gdG8gZml0XG4gICAgLy8gb24gdGhlIGxpbmUuXG5cbiAgICB2YXIgYW5nbGVXaW5kb3dTaXplID0gc2hhcGVkVGV4dCA/XG4gICAgICAgIDMgLyA1ICogZ2x5cGhTaXplICogYm94U2NhbGUgOlxuICAgICAgICAwO1xuXG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBhbmNob3IgYnkgaGFsZiB0aGUgbGFiZWwgbGVuZ3RoIChvciBoYWxmIHRoZSBzcGFjaW5nIGRpc3RhbmNlIGZvciBpY29ucykuXG4gICAgLy8gQWRkIGEgYml0IG9mIGV4dHJhIG9mZnNldCB0byBhdm9pZCBjb2xsaXNpb25zIGF0IFQgaW50ZXJzZWN0aW9ucy5cbiAgICB2YXIgbGFiZWxMZW5ndGggPSBzaGFwZWRUZXh0ID8gc2hhcGVkVGV4dC5yaWdodCAtIHNoYXBlZFRleHQubGVmdCA6IHNwYWNpbmc7XG4gICAgdmFyIGV4dHJhT2Zmc2V0ID0gZ2x5cGhTaXplICogMjtcbiAgICB2YXIgb2Zmc2V0ID0gKChsYWJlbExlbmd0aCAvIDIgKyBleHRyYU9mZnNldCkgKiBib3hTY2FsZSAqIG92ZXJzY2FsaW5nKSAlIHNwYWNpbmc7XG5cbiAgICByZXR1cm4gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCAqIGJveFNjYWxlLCBmYWxzZSk7XG59XG5cblxuZnVuY3Rpb24gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCwgcGxhY2VBdE1pZGRsZSkge1xuXG4gICAgdmFyIGRpc3RhbmNlID0gMCxcbiAgICAgICAgbWFya2VkRGlzdGFuY2UgPSBvZmZzZXQgPyBvZmZzZXQgLSBzcGFjaW5nIDogMDtcblxuICAgIHZhciBhbmNob3JzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGEgPSBsaW5lW2ldLFxuICAgICAgICAgICAgYiA9IGxpbmVbaSArIDFdO1xuXG4gICAgICAgIHZhciBzZWdtZW50RGlzdCA9IGEuZGlzdChiKSxcbiAgICAgICAgICAgIGFuZ2xlID0gYi5hbmdsZVRvKGEpO1xuXG4gICAgICAgIHdoaWxlIChtYXJrZWREaXN0YW5jZSArIHNwYWNpbmcgPCBkaXN0YW5jZSArIHNlZ21lbnREaXN0KSB7XG4gICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArPSBzcGFjaW5nO1xuXG4gICAgICAgICAgICB2YXIgdCA9IChtYXJrZWREaXN0YW5jZSAtIGRpc3RhbmNlKSAvIHNlZ21lbnREaXN0LFxuICAgICAgICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZShhLngsIGIueCwgdCksXG4gICAgICAgICAgICAgICAgeSA9IGludGVycG9sYXRlKGEueSwgYi55LCB0KTtcblxuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgNDA5NiAmJiB5ID49IDAgJiYgeSA8IDQwOTYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlV2luZG93U2l6ZSB8fCBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChhbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlICs9IHNlZ21lbnREaXN0O1xuICAgIH1cblxuICAgIGlmICghcGxhY2VBdE1pZGRsZSAmJiAhYW5jaG9ycy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGF0dGVtcHQgYXQgZmluZGluZyBhbmNob3JzIGF0IHdoaWNoIGxhYmVscyBjYW4gYmUgcGxhY2VkIGZhaWxlZC5cbiAgICAgICAgLy8gVHJ5IGFnYWluLCBidXQgdGhpcyB0aW1lIGp1c3QgdHJ5IHBsYWNpbmcgb25lIGFuY2hvciBhdCB0aGUgbWlkZGxlIG9mIHRoZSBsaW5lLlxuICAgICAgICAvLyBUaGlzIGhhcyB0aGUgbW9zdCBlZmZlY3QgZm9yIHNob3J0IGxpbmVzIGluIG92ZXJzY2FsZWQgdGlsZXMsIHNpbmNlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIG9mZnNldCB1c2VkIGluIG92ZXJzY2FsZWQgdGlsZXMgaXMgY2FsY3VsYXRlZCB0byBhbGlnbiBsYWJlbHMgd2l0aCBwb3NpdGlvbnMgaW5cbiAgICAgICAgLy8gcGFyZW50IHRpbGVzIGluc3RlYWQgb2YgcGxhY2luZyB0aGUgbGFiZWwgYXMgY2xvc2UgdG8gdGhlIGJlZ2lubmluZyBhcyBwb3NzaWJsZS5cbiAgICAgICAgYW5jaG9ycyA9IHJlc2FtcGxlKGxpbmUsIGRpc3RhbmNlIC8gMiwgc3BhY2luZywgYW5nbGVXaW5kb3dTaXplLCBtYXhBbmdsZSwgbGFiZWxMZW5ndGgsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNob3JzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmluUGFjayA9IHJlcXVpcmUoJy4vYmluX3BhY2snKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaEF0bGFzO1xuZnVuY3Rpb24gR2x5cGhBdGxhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy5iaW4gPSBuZXcgQmluUGFjayh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmluZGV4ID0ge307XG4gICAgdGhpcy5pZHMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG59XG5cbkdseXBoQXRsYXMucHJvdG90eXBlID0ge1xuICAgIGdldCBkZWJ1ZygpIHtcbiAgICAgICAgcmV0dXJuICdjYW52YXMnIGluIHRoaXM7XG4gICAgfSxcbiAgICBzZXQgZGVidWcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmN0eDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmdldEdseXBocyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbHlwaHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIWdseXBoc1tuYW1lXSkgZ2x5cGhzW25hbWVdID0gW107XG4gICAgICAgIGdseXBoc1tuYW1lXS5wdXNoKGlkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0UmVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVjdHMgPSB7fSxcbiAgICAgICAgc3BsaXQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlkO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuaWRzKSB7XG4gICAgICAgIHNwbGl0ID0ga2V5LnNwbGl0KCcjJyk7XG4gICAgICAgIG5hbWUgPSBzcGxpdFswXTtcbiAgICAgICAgaWQgPSBzcGxpdFsxXTtcblxuICAgICAgICBpZiAoIXJlY3RzW25hbWVdKSByZWN0c1tuYW1lXSA9IHt9O1xuICAgICAgICByZWN0c1tuYW1lXVtpZF0gPSB0aGlzLmluZGV4W2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3RzO1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUucmVtb3ZlR2x5cGhzID0gZnVuY3Rpb24oaWQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcblxuICAgICAgICB2YXIgaWRzID0gdGhpcy5pZHNba2V5XTtcblxuICAgICAgICB2YXIgcG9zID0gaWRzLmluZGV4T2YoaWQpO1xuICAgICAgICBpZiAocG9zID49IDApIGlkcy5zcGxpY2UocG9zLCAxKTtcbiAgICAgICAgdGhpcy5pZHNba2V5XSA9IGlkcztcblxuICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5pbmRleFtrZXldO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCByZWN0Lmg7IHkrKykge1xuICAgICAgICAgICAgICAgIHZhciB5MSA9IHRoaXMud2lkdGggKiAocmVjdC55ICsgeSkgKyByZWN0Lng7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByZWN0Lnc7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbeTEgKyB4XSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5iaW4ucmVsZWFzZShyZWN0KTtcblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlkc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUodGhpcy5nbCk7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5hZGRHbHlwaCA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBnbHlwaCwgYnVmZmVyKSB7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ21pc3NpbmcgZ2x5cGgnLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXkgPSBuYW1lICsgXCIjXCIgKyBnbHlwaC5pZDtcblxuICAgIC8vIFRoZSBnbHlwaCBpcyBhbHJlYWR5IGluIHRoaXMgdGV4dHVyZS5cbiAgICBpZiAodGhpcy5pbmRleFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLmlkc1trZXldLmluZGV4T2YoaWQpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5pZHNba2V5XS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFtrZXldO1xuICAgIH1cblxuICAgIC8vIFRoZSBnbHlwaCBiaXRtYXAgaGFzIHplcm8gd2lkdGguXG4gICAgaWYgKCFnbHlwaC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcmVkV2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG4gICAgdmFyIGJ1ZmZlcmVkSGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciBwYWNrV2lkdGggPSBidWZmZXJlZFdpZHRoO1xuICAgIHZhciBwYWNrSGVpZ2h0ID0gYnVmZmVyZWRIZWlnaHQ7XG5cbiAgICAvLyBJbmNyZWFzZSB0byBuZXh0IG51bWJlciBkaXZpc2libGUgYnkgNCwgYnV0IGF0IGxlYXN0IDEuXG4gICAgLy8gVGhpcyBpcyBzbyB3ZSBjYW4gc2NhbGUgZG93biB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgcGFjayB0aGVtXG4gICAgLy8gaW50byAyIGJ5dGVzIHJhdGhlciB0aGFuIDQgYnl0ZXMuXG4gICAgcGFja1dpZHRoICs9ICg0IC0gcGFja1dpZHRoICUgNCk7XG4gICAgcGFja0hlaWdodCArPSAoNCAtIHBhY2tIZWlnaHQgJSA0KTtcblxuICAgIHZhciByZWN0ID0gdGhpcy5iaW4uYWxsb2NhdGUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICBpZiAocmVjdC54IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2dseXBoIGJpdG1hcCBvdmVyZmxvdycpO1xuICAgICAgICByZXR1cm4geyBnbHlwaDogZ2x5cGgsIHJlY3Q6IG51bGwgfTtcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4W2tleV0gPSByZWN0O1xuICAgIHRoaXMuaWRzW2tleV0gPSBbaWRdO1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgc291cmNlID0gZ2x5cGguYml0bWFwO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYnVmZmVyZWRIZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgeTEgPSB0aGlzLndpZHRoICogKHJlY3QueSArIHkpICsgcmVjdC54O1xuICAgICAgICB2YXIgeTIgPSBidWZmZXJlZFdpZHRoICogeTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBidWZmZXJlZFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHRhcmdldFt5MSArIHhdID0gc291cmNlW3kyICsgeF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuQUxQSEEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIH1cbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLnVwZGF0ZVRleHR1cmUgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuYmluZChnbCk7XG4gICAgaWYgKHRoaXMuZGlydHkpIHtcblxuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcblxuICAgICAgICAvLyBERUJVR1xuICAgICAgICBpZiAodGhpcy5jdHgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKywgaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2pdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtqICsgMV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhW2ogKyAyXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkYXRhLmRhdGFbaiArIDNdID0gMjU1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmJpbi5mcmVlLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLmJpbi5mcmVlW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoZnJlZS54LCBmcmVlLnksIGZyZWUudywgZnJlZS5oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgREVCVUdcblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplR2x5cGhzVVJMO1xudmFyIGdldEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4JykuZ2V0QXJyYXlCdWZmZXI7XG52YXIgR2x5cGhzID0gcmVxdWlyZSgnLi4vdXRpbC9nbHlwaHMnKTtcbnZhciBQcm90b2J1ZiA9IHJlcXVpcmUoJ3BiZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoU291cmNlO1xuXG5mdW5jdGlvbiBHbHlwaFNvdXJjZSh1cmwsIGdseXBoQXRsYXMpIHtcbiAgICB0aGlzLnVybCA9IHVybCAmJiBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLmdseXBoQXRsYXMgPSBnbHlwaEF0bGFzO1xuICAgIHRoaXMuc3RhY2tzID0gW107XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRTaW1wbGVHbHlwaHMgPSBmdW5jdGlvbihmb250c3RhY2ssIGdseXBoSURzLCB1aWQsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAodGhpcy5zdGFja3NbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB0aGlzLnN0YWNrc1tmb250c3RhY2tdID0ge307XG5cbiAgICB2YXIgZ2x5cGhzID0ge307XG5cbiAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdO1xuICAgIHZhciBnbHlwaEF0bGFzID0gdGhpcy5nbHlwaEF0bGFzO1xuXG4gICAgLy8gdGhlIG51bWJlciBvZiBwaXhlbHMgdGhlIHNkZiBiaXRtYXBzIGFyZSBwYWRkZWQgYnlcbiAgICB2YXIgYnVmZmVyID0gMztcblxuICAgIHZhciBtaXNzaW5nID0ge307XG4gICAgdmFyIHJlbWFpbmluZyA9IDA7XG4gICAgdmFyIHJhbmdlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGhJRCA9IGdseXBoSURzW2ldO1xuICAgICAgICByYW5nZSA9IE1hdGguZmxvb3IoZ2x5cGhJRCAvIDI1Nik7XG5cbiAgICAgICAgaWYgKHN0YWNrW3JhbmdlXSkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2tbcmFuZ2VdLmdseXBoc1tnbHlwaElEXTtcbiAgICAgICAgICAgIHZhciByZWN0ICA9IGdseXBoQXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdseXBoKSBnbHlwaHNbZ2x5cGhJRF0gPSBuZXcgU2ltcGxlR2x5cGgoZ2x5cGgsIHJlY3QsIGJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1tyYW5nZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdID0gW107XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXNzaW5nW3JhbmdlXS5wdXNoKGdseXBoSUQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZW1haW5pbmcpIGNhbGxiYWNrKHVuZGVmaW5lZCwgZ2x5cGhzKTtcblxuICAgIHZhciBvblJhbmdlTG9hZGVkID0gZnVuY3Rpb24oZXJyLCByYW5nZSwgZGF0YSkge1xuICAgICAgICAvLyBUT0RPIG5vdCBiZSBzaWxlbnQgYWJvdXQgZXJyb3JzXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLnN0YWNrc1tmb250c3RhY2tdW3JhbmdlXSA9IGRhdGEuc3RhY2tzWzBdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXNzaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaElEID0gbWlzc2luZ1tyYW5nZV1baV07XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoID0gc3RhY2suZ2x5cGhzW2dseXBoSURdO1xuICAgICAgICAgICAgICAgIHZhciByZWN0ICA9IGdseXBoQXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaCkgZ2x5cGhzW2dseXBoSURdID0gbmV3IFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCBnbHlwaHMpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGZvciAodmFyIHIgaW4gbWlzc2luZykge1xuICAgICAgICB0aGlzLmxvYWRSYW5nZShmb250c3RhY2ssIHIsIG9uUmFuZ2VMb2FkZWQpO1xuICAgIH1cbn07XG5cbi8vIEEgc2ltcGxpZmllZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2x5cGggY29udGFpbmluZyBvbmx5IHRoZSBwcm9wZXJ0aWVzIG5lZWRlZCBmb3Igc2hhcGluZy5cbmZ1bmN0aW9uIFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpIHtcbiAgICB0aGlzLmFkdmFuY2UgPSBnbHlwaC5hZHZhbmNlO1xuICAgIHRoaXMubGVmdCA9IGdseXBoLmxlZnQgLSBidWZmZXI7XG4gICAgdGhpcy50b3AgPSBnbHlwaC50b3AgKyBidWZmZXI7XG4gICAgdGhpcy5yZWN0ID0gcmVjdDtcbn1cblxuR2x5cGhTb3VyY2UucHJvdG90eXBlLmxvYWRSYW5nZSA9IGZ1bmN0aW9uKGZvbnRzdGFjaywgcmFuZ2UsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAocmFuZ2UgKiAyNTYgPiA2NTUzNSkgcmV0dXJuIGNhbGxiYWNrKCdneXBocyA+IDY1NTM1IG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIGlmICh0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9IHt9O1xuICAgIHZhciBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW2ZvbnRzdGFja107XG5cbiAgICBpZiAobG9hZGluZ1tyYW5nZV0pIHtcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0ucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9hZGluZ1tyYW5nZV0gPSBbY2FsbGJhY2tdO1xuXG4gICAgICAgIHZhciByYW5nZU5hbWUgPSAocmFuZ2UgKiAyNTYpICsgJy0nICsgKHJhbmdlICogMjU2ICsgMjU1KTtcbiAgICAgICAgdmFyIHVybCA9IGdseXBoVXJsKGZvbnRzdGFjaywgcmFuZ2VOYW1lLCB0aGlzLnVybCk7XG5cbiAgICAgICAgZ2V0QXJyYXlCdWZmZXIodXJsLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSAhZXJyICYmIG5ldyBHbHlwaHMobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvYWRpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZ1tyYW5nZV1baV0oZXJyLCByYW5nZSwgZ2x5cGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBsb2FkaW5nW3JhbmdlXTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZSwgdXJsLCBzdWJkb21haW5zKSB7XG4gICAgc3ViZG9tYWlucyA9IHN1YmRvbWFpbnMgfHwgJ2FiYyc7XG5cbiAgICByZXR1cm4gdXJsXG4gICAgICAgIC5yZXBsYWNlKCd7c30nLCBzdWJkb21haW5zW2ZvbnRzdGFjay5sZW5ndGggJSBzdWJkb21haW5zLmxlbmd0aF0pXG4gICAgICAgIC5yZXBsYWNlKCd7Zm9udHN0YWNrfScsIGZvbnRzdGFjaylcbiAgICAgICAgLnJlcGxhY2UoJ3tyYW5nZX0nLCByYW5nZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpIHtcblxuICAgIHZhciBsZWZ0SW5kZXggPSB7fSxcbiAgICAgICAgcmlnaHRJbmRleCA9IHt9LFxuICAgICAgICBtZXJnZWRGZWF0dXJlcyA9IFtdLFxuICAgICAgICBtZXJnZWRHZW9tID0gW10sXG4gICAgICAgIG1lcmdlZFRleHRzID0gW10sXG4gICAgICAgIG1lcmdlZEluZGV4ID0gMCxcbiAgICAgICAgaztcblxuICAgIGZ1bmN0aW9uIGFkZChrKSB7XG4gICAgICAgIG1lcmdlZEZlYXR1cmVzLnB1c2goZmVhdHVyZXNba10pO1xuICAgICAgICBtZXJnZWRHZW9tLnB1c2goZ2VvbWV0cmllc1trXSk7XG4gICAgICAgIG1lcmdlZFRleHRzLnB1c2godGV4dEZlYXR1cmVzW2tdKTtcbiAgICAgICAgbWVyZ2VkSW5kZXgrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSkge1xuICAgICAgICB2YXIgaSA9IHJpZ2h0SW5kZXhbbGVmdEtleV07XG4gICAgICAgIGRlbGV0ZSByaWdodEluZGV4W2xlZnRLZXldO1xuICAgICAgICByaWdodEluZGV4W3JpZ2h0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5wb3AoKTtcbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXSA9IG1lcmdlZEdlb21baV1bMF0uY29uY2F0KGdlb21bMF0pO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21MZWZ0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKSB7XG4gICAgICAgIHZhciBpID0gbGVmdEluZGV4W3JpZ2h0S2V5XTtcbiAgICAgICAgZGVsZXRlIGxlZnRJbmRleFtyaWdodEtleV07XG4gICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5zaGlmdCgpO1xuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdID0gZ2VvbVswXS5jb25jYXQobWVyZ2VkR2VvbVtpXVswXSk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEtleSh0ZXh0LCBnZW9tLCBvblJpZ2h0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG9uUmlnaHQgPyBnZW9tWzBdW2dlb21bMF0ubGVuZ3RoIC0gMV0gOiBnZW9tWzBdWzBdO1xuICAgICAgICByZXR1cm4gdGV4dCArICc6JyArIHBvaW50LnggKyAnOicgKyBwb2ludC55O1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBmZWF0dXJlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZ2VvbSA9IGdlb21ldHJpZXNba10sXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dEZlYXR1cmVzW2tdO1xuXG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgYWRkKGspO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdEtleSA9IGdldEtleSh0ZXh0LCBnZW9tKSxcbiAgICAgICAgICAgIHJpZ2h0S2V5ID0gZ2V0S2V5KHRleHQsIGdlb20sIHRydWUpO1xuXG4gICAgICAgIGlmICgobGVmdEtleSBpbiByaWdodEluZGV4KSAmJiAocmlnaHRLZXkgaW4gbGVmdEluZGV4KSAmJiAocmlnaHRJbmRleFtsZWZ0S2V5XSAhPT0gbGVmdEluZGV4W3JpZ2h0S2V5XSkpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIGxpbmVzIHdpdGggdGhlIHNhbWUgdGV4dCBhZGphY2VudCB0byBib3RoIGVuZHMgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2UgYWxsIHRocmVlXG4gICAgICAgICAgICB2YXIgaiA9IG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuICAgICAgICAgICAgdmFyIGkgPSBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgbWVyZ2VkR2VvbVtqXSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBsZWZ0SW5kZXhbbGVmdEtleV07XG4gICAgICAgICAgICBkZWxldGUgcmlnaHRJbmRleFtyaWdodEtleV07XG5cbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbZ2V0S2V5KHRleHQsIG1lcmdlZEdlb21baV0sIHRydWUpXSA9IGk7XG4gICAgICAgICAgICBtZXJnZWRHZW9tW2pdID0gbnVsbDtcblxuICAgICAgICB9IGVsc2UgaWYgKGxlZnRLZXkgaW4gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgLy8gZm91bmQgbWVyZ2VhYmxlIGxpbmUgYWRqYWNlbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGxpbmUsIG1lcmdlXG4gICAgICAgICAgICBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEtleSBpbiBsZWZ0SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1lcmdlYWJsZSBsaW5lIGFkamFjZW50IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2VcbiAgICAgICAgICAgIG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhZGphY2VudCBsaW5lcywgYWRkIGFzIGEgbmV3IGl0ZW1cbiAgICAgICAgICAgIGFkZChrKTtcbiAgICAgICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IG1lcmdlZEluZGV4IC0gMTtcbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbcmlnaHRLZXldID0gbWVyZ2VkSW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVhdHVyZXM6IG1lcmdlZEZlYXR1cmVzLFxuICAgICAgICB0ZXh0RmVhdHVyZXM6IG1lcmdlZFRleHRzLFxuICAgICAgICBnZW9tZXRyaWVzOiBtZXJnZWRHZW9tXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgQW5jaG9yID0gcmVxdWlyZSgnLi4vc3ltYm9sL2FuY2hvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRJY29uUXVhZHM6IGdldEljb25RdWFkcyxcbiAgICBnZXRHbHlwaFF1YWRzOiBnZXRHbHlwaFF1YWRzXG59O1xuXG52YXIgbWluU2NhbGUgPSAwLjU7IC8vIHVuZGVyc2NhbGUgYnkgMSB6b29tIGxldmVsXG5cbmZ1bmN0aW9uIFN5bWJvbFF1YWQoYW5jaG9yLCB0bCwgdHIsIGJsLCBiciwgdGV4LCBhbmdsZSwgbWluU2NhbGUsIG1heFNjYWxlKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy50bCA9IHRsO1xuICAgIHRoaXMudHIgPSB0cjtcbiAgICB0aGlzLmJsID0gYmw7XG4gICAgdGhpcy5iciA9IGJyO1xuICAgIHRoaXMudGV4ID0gdGV4O1xuICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICB0aGlzLm1pblNjYWxlID0gbWluU2NhbGU7XG4gICAgdGhpcy5tYXhTY2FsZSA9IG1heFNjYWxlO1xufVxuXG5mdW5jdGlvbiBnZXRJY29uUXVhZHMoYW5jaG9yLCBzaGFwZWRJY29uLCBib3hTY2FsZSwgbGluZSwgbGF5b3V0LCBhbG9uZ0xpbmUpIHtcblxuICAgIHZhciB0bCA9IG5ldyBQb2ludChzaGFwZWRJY29uLmxlZnQsIHNoYXBlZEljb24udG9wKTtcbiAgICB2YXIgdHIgPSBuZXcgUG9pbnQoc2hhcGVkSWNvbi5yaWdodCwgc2hhcGVkSWNvbi50b3ApO1xuICAgIHZhciBiciA9IG5ldyBQb2ludChzaGFwZWRJY29uLnJpZ2h0LCBzaGFwZWRJY29uLmJvdHRvbSk7XG4gICAgdmFyIGJsID0gbmV3IFBvaW50KHNoYXBlZEljb24ubGVmdCwgc2hhcGVkSWNvbi5ib3R0b20pO1xuXG4gICAgdmFyIGFuZ2xlID0gbGF5b3V0WydpY29uLXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICBpZiAoYWxvbmdMaW5lKSB7XG4gICAgICAgIHZhciBwcmV2ID0gbGluZVthbmNob3Iuc2VnbWVudF07XG4gICAgICAgIGFuZ2xlICs9IE1hdGguYXRhbjIoYW5jaG9yLnkgLSBwcmV2LnksIGFuY2hvci54IC0gcHJldi54KTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcblxuICAgICAgICB0bCA9IHRsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIGJsID0gYmwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBiciA9IGJyLm1hdE11bHQobWF0cml4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW25ldyBTeW1ib2xRdWFkKGFuY2hvciwgdGwsIHRyLCBibCwgYnIsIHNoYXBlZEljb24uaW1hZ2UucmVjdCwgMCwgbWluU2NhbGUsIEluZmluaXR5KV07XG59XG5cbmZ1bmN0aW9uIGdldEdseXBoUXVhZHMoYW5jaG9yLCBzaGFwaW5nLCBib3hTY2FsZSwgbGluZSwgbGF5b3V0LCBhbG9uZ0xpbmUpIHtcblxuICAgIHZhciB0ZXh0Um90YXRlID0gbGF5b3V0Wyd0ZXh0LXJvdGF0ZSddICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIga2VlcFVwcmlnaHQgPSBsYXlvdXRbJ3RleHQta2VlcC11cHJpZ2h0J107XG5cbiAgICB2YXIgcG9zaXRpb25lZEdseXBocyA9IHNoYXBpbmcucG9zaXRpb25lZEdseXBocztcbiAgICB2YXIgcXVhZHMgPSBbXTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgcG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1trXTtcbiAgICAgICAgdmFyIGdseXBoID0gcG9zaXRpb25lZEdseXBoLmdseXBoO1xuICAgICAgICB2YXIgcmVjdCA9IGdseXBoLnJlY3Q7XG5cbiAgICAgICAgaWYgKCFyZWN0KSBjb250aW51ZTtcblxuICAgICAgICB2YXIgY2VudGVyWCA9IChwb3NpdGlvbmVkR2x5cGgueCArIGdseXBoLmFkdmFuY2UgLyAyKSAqIGJveFNjYWxlO1xuXG4gICAgICAgIHZhciBnbHlwaEluc3RhbmNlcztcbiAgICAgICAgdmFyIGxhYmVsTWluU2NhbGUgPSBtaW5TY2FsZTtcbiAgICAgICAgaWYgKGFsb25nTGluZSkge1xuICAgICAgICAgICAgZ2x5cGhJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGxhYmVsTWluU2NhbGUgPSBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIGNlbnRlclgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCAxKTtcbiAgICAgICAgICAgIGlmIChrZWVwVXByaWdodCkge1xuICAgICAgICAgICAgICAgIGxhYmVsTWluU2NhbGUgPSBNYXRoLm1pbihsYWJlbE1pblNjYWxlLCBnZXRTZWdtZW50R2x5cGhzKGdseXBoSW5zdGFuY2VzLCBhbmNob3IsIGNlbnRlclgsIGxpbmUsIGFuY2hvci5zZWdtZW50LCAtMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaEluc3RhbmNlcyA9IFt7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICAgIG1heFNjYWxlOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBtaW5TY2FsZTogbWluU2NhbGVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgxID0gcG9zaXRpb25lZEdseXBoLnggKyBnbHlwaC5sZWZ0LFxuICAgICAgICAgICAgeTEgPSBwb3NpdGlvbmVkR2x5cGgueSAtIGdseXBoLnRvcCxcbiAgICAgICAgICAgIHgyID0geDEgKyByZWN0LncsXG4gICAgICAgICAgICB5MiA9IHkxICsgcmVjdC5oLFxuXG4gICAgICAgICAgICBvdGwgPSBuZXcgUG9pbnQoeDEsIHkxKSxcbiAgICAgICAgICAgIG90ciA9IG5ldyBQb2ludCh4MiwgeTEpLFxuICAgICAgICAgICAgb2JsID0gbmV3IFBvaW50KHgxLCB5MiksXG4gICAgICAgICAgICBvYnIgPSBuZXcgUG9pbnQoeDIsIHkyKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGdseXBoSW5zdGFuY2VzW2ldLFxuICAgICAgICAgICAgICAgIHRsID0gb3RsLFxuICAgICAgICAgICAgICAgIHRyID0gb3RyLFxuICAgICAgICAgICAgICAgIGJsID0gb2JsLFxuICAgICAgICAgICAgICAgIGJyID0gb2JyLFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gaW5zdGFuY2UuYW5nbGUgKyB0ZXh0Um90YXRlO1xuXG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCA9IFtjb3MsIC1zaW4sIHNpbiwgY29zXTtcblxuICAgICAgICAgICAgICAgIHRsID0gdGwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJsID0gYmwubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJyID0gYnIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGxhYmVsIGZyb20gZXh0ZW5kaW5nIHBhc3QgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgdmFyIGdseXBoTWluU2NhbGUgPSBNYXRoLm1heChpbnN0YW5jZS5taW5TY2FsZSwgbGFiZWxNaW5TY2FsZSk7XG5cbiAgICAgICAgICAgIHZhciBnbHlwaEFuZ2xlID0gKGFuY2hvci5hbmdsZSArIHRleHRSb3RhdGUgKyBpbnN0YW5jZS5vZmZzZXQgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgcXVhZHMucHVzaChuZXcgU3ltYm9sUXVhZChpbnN0YW5jZS5hbmNob3IsIHRsLCB0ciwgYmwsIGJyLCByZWN0LCBnbHlwaEFuZ2xlLCBnbHlwaE1pblNjYWxlLCBpbnN0YW5jZS5tYXhTY2FsZSkpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVhZHM7XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnRHbHlwaHMoZ2x5cGhzLCBhbmNob3IsIG9mZnNldCwgbGluZSwgc2VnbWVudCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHVwc2lkZURvd24gPSBkaXJlY3Rpb24gPCAwO1xuXG4gICAgaWYgKG9mZnNldCA8IDApIGRpcmVjdGlvbiAqPSAtMTtcblxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSBzZWdtZW50Kys7XG5cbiAgICB2YXIgbmV3QW5jaG9yID0gYW5jaG9yO1xuICAgIHZhciBlbmQgPSBsaW5lW3NlZ21lbnRdO1xuICAgIHZhciBwcmV2U2NhbGUgPSBJbmZpbml0eTtcblxuICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG5cbiAgICB2YXIgcGxhY2VtZW50U2NhbGUgPSBtaW5TY2FsZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IG5ld0FuY2hvci5kaXN0KGVuZCk7XG4gICAgICAgIHZhciBzY2FsZSA9IG9mZnNldCAvIGRpc3RhbmNlO1xuXG4gICAgICAgIC8vIEdldCB0aGUgYW5nbGUgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGVuZC55IC0gbmV3QW5jaG9yLnksIGVuZC54IC0gbmV3QW5jaG9yLngpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uIDwgMCkgYW5nbGUgKz0gTWF0aC5QSTtcbiAgICAgICAgaWYgKHVwc2lkZURvd24pIGFuZ2xlICs9IE1hdGguUEk7XG5cbiAgICAgICAgZ2x5cGhzLnB1c2goe1xuICAgICAgICAgICAgYW5jaG9yOiBuZXcgQW5jaG9yKG5ld0FuY2hvci54LCBuZXdBbmNob3IueSwgYW5jaG9yLmFuZ2xlKSxcbiAgICAgICAgICAgIG9mZnNldDogdXBzaWRlRG93biA/IE1hdGguUEkgOiAwLFxuICAgICAgICAgICAgbWluU2NhbGU6IHNjYWxlLFxuICAgICAgICAgICAgbWF4U2NhbGU6IHByZXZTY2FsZSxcbiAgICAgICAgICAgIGFuZ2xlOiAoYW5nbGUgKyAyICogTWF0aC5QSSkgJSAoMiAqIE1hdGguUEkpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzY2FsZSA8PSBwbGFjZW1lbnRTY2FsZSkgYnJlYWs7XG5cbiAgICAgICAgbmV3QW5jaG9yID0gZW5kO1xuXG4gICAgICAgIC8vIHNraXAgZHVwbGljYXRlIG5vZGVzXG4gICAgICAgIHdoaWxlIChuZXdBbmNob3IuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgKz0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgZW5kID0gbGluZVtzZWdtZW50XTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXQgPSBlbmQuc3ViKG5ld0FuY2hvcikuX3VuaXQoKTtcbiAgICAgICAgbmV3QW5jaG9yID0gbmV3QW5jaG9yLnN1Yih1bml0Ll9tdWx0KGRpc3RhbmNlKSk7XG5cbiAgICAgICAgcHJldlNjYWxlID0gc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbWVudFNjYWxlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlSWNvbnM7XG5cbi8vIEZvciBhbiBhcnJheSBvZiBmZWF0dXJlcyBkZXRlcm1pbmUgd2hhdCBpY29ucyBuZWVkIHRvIGJlIGxvYWRlZC5cbmZ1bmN0aW9uIHJlc29sdmVJY29ucyhmZWF0dXJlcywgbGF5b3V0UHJvcGVydGllcykge1xuICAgIHZhciBpY29ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZsID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgZmw7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgbGF5b3V0UHJvcGVydGllc1snaWNvbi1pbWFnZSddKTtcbiAgICAgICAgaWYgKCF0ZXh0KSBjb250aW51ZTtcblxuICAgICAgICBpZiAoaWNvbnMuaW5kZXhPZih0ZXh0KSA8IDApIHtcbiAgICAgICAgICAgIGljb25zLnB1c2godGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWNvbnM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXNvbHZlVG9rZW5zID0gcmVxdWlyZSgnLi4vdXRpbC90b2tlbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVUZXh0O1xuXG4vKipcbiAqIEZvciBhbiBhcnJheSBvZiBmZWF0dXJlcyBkZXRlcm1pbmUgd2hhdCBnbHlwaCByYW5nZXMgbmVlZCB0byBiZSBsb2FkZWRcbiAqIGFuZCBhcHBseSBhbnkgdGV4dCBwcmVwcm9jZXNzaW5nLiBUaGUgcmVtYWluaW5nIHVzZXJzIG9mIHRleHQgc2hvdWxkXG4gKiB1c2UgdGhlIGB0ZXh0RmVhdHVyZXNgIGtleSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIGFjY2Vzc2luZ1xuICogZmVhdHVyZSB0ZXh0IGRpcmVjdGx5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRleHQoZmVhdHVyZXMsIGxheW91dFByb3BlcnRpZXMsIGdseXBocykge1xuICAgIHZhciB0ZXh0RmVhdHVyZXMgPSBbXTtcbiAgICB2YXIgY29kZXBvaW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZsID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgZmw7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgbGF5b3V0UHJvcGVydGllc1sndGV4dC1maWVsZCddKTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbGF5b3V0UHJvcGVydGllc1sndGV4dC10cmFuc2Zvcm0nXTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAnbG93ZXJjYXNlJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IHRleHQubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgY29kZXBvaW50cy5wdXNoKHRleHQuY2hhckNvZGVBdChqKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjayBpbmRleGVzIG9mIGZlYXR1cmVzIHdpdGggdGV4dC5cbiAgICAgICAgdGV4dEZlYXR1cmVzW2ldID0gdGV4dDtcbiAgICB9XG5cbiAgICAvLyBnZXQgYSBsaXN0IG9mIHVuaXF1ZSBjb2RlcG9pbnRzIHdlIGFyZSBtaXNzaW5nXG4gICAgY29kZXBvaW50cyA9IHVuaXEoY29kZXBvaW50cywgZ2x5cGhzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRleHRGZWF0dXJlczogdGV4dEZlYXR1cmVzLFxuICAgICAgICBjb2RlcG9pbnRzOiBjb2RlcG9pbnRzXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdW5pcShpZHMsIGFscmVhZHlIYXZlKSB7XG4gICAgdmFyIHUgPSBbXTtcbiAgICB2YXIgbGFzdDtcbiAgICBpZHMuc29ydChzb3J0TnVtYmVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlkc1tpXSAhPT0gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGlmICghYWxyZWFkeUhhdmVbbGFzdF0pIHUucHVzaChpZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuXG5mdW5jdGlvbiBzb3J0TnVtYmVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaGFwZVRleHQ6IHNoYXBlVGV4dCxcbiAgICBzaGFwZUljb246IHNoYXBlSWNvblxufTtcblxuXG4vLyBUaGUgcG9zaXRpb24gb2YgYSBnbHlwaCByZWxhdGl2ZSB0byB0aGUgdGV4dCdzIGFuY2hvciBwb2ludC5cbmZ1bmN0aW9uIFBvc2l0aW9uZWRHbHlwaChjb2RlUG9pbnQsIHgsIHksIGdseXBoKSB7XG4gICAgdGhpcy5jb2RlUG9pbnQgPSBjb2RlUG9pbnQ7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZ2x5cGggPSBnbHlwaDtcbn1cblxuLy8gQSBjb2xsZWN0aW9uIG9mIHBvc2l0aW9uZWQgZ2x5cGhzIGFuZCBzb21lIG1ldGFkYXRhXG5mdW5jdGlvbiBTaGFwaW5nKHBvc2l0aW9uZWRHbHlwaHMsIHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCkge1xuICAgIHRoaXMucG9zaXRpb25lZEdseXBocyA9IHBvc2l0aW9uZWRHbHlwaHM7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59XG5cbmZ1bmN0aW9uIHNoYXBlVGV4dCh0ZXh0LCBnbHlwaHMsIG1heFdpZHRoLCBsaW5lSGVpZ2h0LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnksIHNwYWNpbmcsIHRyYW5zbGF0ZSkge1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBbXTtcbiAgICB2YXIgc2hhcGluZyA9IG5ldyBTaGFwaW5nKHBvc2l0aW9uZWRHbHlwaHMsIHRyYW5zbGF0ZVsxXSwgdHJhbnNsYXRlWzFdLCB0cmFuc2xhdGVbMF0sIHRyYW5zbGF0ZVswXSk7XG5cbiAgICAvLyB0aGUgeSBvZmZzZXQgKnNob3VsZCogYmUgcGFydCBvZiB0aGUgZm9udCBtZXRhZGF0YVxuICAgIHZhciB5T2Zmc2V0ID0gLTE3O1xuXG4gICAgdmFyIHggPSB0cmFuc2xhdGVbMF07XG4gICAgdmFyIHkgPSB0cmFuc2xhdGVbMV0gKyB5T2Zmc2V0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tjb2RlUG9pbnRdO1xuXG4gICAgICAgIGlmICghZ2x5cGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHMucHVzaChuZXcgUG9zaXRpb25lZEdseXBoKGNvZGVQb2ludCwgeCwgeSwgZ2x5cGgpKTtcbiAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlICsgc3BhY2luZztcbiAgICB9XG5cbiAgICBpZiAoIXBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnkpO1xuXG4gICAgcmV0dXJuIHNoYXBpbmc7XG59XG5cbnZhciBicmVha2FibGUgPSB7IDMyOiB0cnVlIH07IC8vIEN1cnJlbnRseSBvbmx5IGJyZWFrcyBhdCByZWd1bGFyIHNwYWNlc1xuXG5mdW5jdGlvbiBsaW5ld3JhcChzaGFwaW5nLCBnbHlwaHMsIGxpbmVIZWlnaHQsIG1heFdpZHRoLCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIGp1c3RpZnkpIHtcbiAgICB2YXIgbGFzdFNhZmVCcmVhayA9IG51bGw7XG5cbiAgICB2YXIgbGVuZ3RoQmVmb3JlQ3VycmVudExpbmUgPSAwO1xuICAgIHZhciBsaW5lU3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmUgPSAwO1xuXG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBzaGFwaW5nLnBvc2l0aW9uZWRHbHlwaHM7XG5cbiAgICBpZiAobWF4V2lkdGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1tpXTtcblxuICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoLnggLT0gbGVuZ3RoQmVmb3JlQ3VycmVudExpbmU7XG4gICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGgueSArPSBsaW5lSGVpZ2h0ICogbGluZTtcblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uZWRHbHlwaC54ID4gbWF4V2lkdGggJiYgbGFzdFNhZmVCcmVhayAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBwb3NpdGlvbmVkR2x5cGhzW2xhc3RTYWZlQnJlYWsgKyAxXS54O1xuICAgICAgICAgICAgICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChsaW5lTGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBsYXN0U2FmZUJyZWFrICsgMTsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoc1trXS55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHNba10ueCAtPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgbGluZVN0YXJ0SW5kZXgsIGxhc3RTYWZlQnJlYWsgLSAxLCBqdXN0aWZ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRJbmRleCA9IGxhc3RTYWZlQnJlYWsgKyAxO1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lICs9IGxpbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnJlYWthYmxlW3Bvc2l0aW9uZWRHbHlwaC5jb2RlUG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNhZmVCcmVhayA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFzdFBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNbcG9zaXRpb25lZEdseXBocy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGFzdExpbmVMZW5ndGggPSBsYXN0UG9zaXRpb25lZEdseXBoLnggKyBnbHlwaHNbbGFzdFBvc2l0aW9uZWRHbHlwaC5jb2RlUG9pbnRdLmFkdmFuY2U7XG4gICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KG1heExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoKTtcblxuICAgIHZhciBoZWlnaHQgPSAobGluZSArIDEpICogbGluZUhlaWdodDtcblxuICAgIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgbGluZVN0YXJ0SW5kZXgsIHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoIC0gMSwganVzdGlmeSk7XG4gICAgYWxpZ24ocG9zaXRpb25lZEdseXBocywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94XG4gICAgc2hhcGluZy50b3AgKz0gLXZlcnRpY2FsQWxpZ24gKiBoZWlnaHQ7XG4gICAgc2hhcGluZy5ib3R0b20gPSBzaGFwaW5nLnRvcCArIGhlaWdodDtcbiAgICBzaGFwaW5nLmxlZnQgKz0gLWhvcml6b250YWxBbGlnbiAqIG1heExpbmVMZW5ndGg7XG4gICAgc2hhcGluZy5yaWdodCA9IHNoYXBpbmcubGVmdCArIG1heExpbmVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgc3RhcnQsIGVuZCwganVzdGlmeSkge1xuICAgIHZhciBsYXN0QWR2YW5jZSA9IGdseXBoc1twb3NpdGlvbmVkR2x5cGhzW2VuZF0uY29kZVBvaW50XS5hZHZhbmNlO1xuICAgIHZhciBsaW5lSW5kZW50ID0gKHBvc2l0aW9uZWRHbHlwaHNbZW5kXS54ICsgbGFzdEFkdmFuY2UpICoganVzdGlmeTtcblxuICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnggLT0gbGluZUluZGVudDtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYWxpZ24ocG9zaXRpb25lZEdseXBocywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lKSB7XG4gICAgdmFyIHNoaWZ0WCA9IChqdXN0aWZ5IC0gaG9yaXpvbnRhbEFsaWduKSAqIG1heExpbmVMZW5ndGg7XG4gICAgdmFyIHNoaWZ0WSA9ICgtdmVydGljYWxBbGlnbiAqIChsaW5lICsgMSkgKyAwLjUpICogbGluZUhlaWdodDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zaXRpb25lZEdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnggKz0gc2hpZnRYO1xuICAgICAgICBwb3NpdGlvbmVkR2x5cGhzW2pdLnkgKz0gc2hpZnRZO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBzaGFwZUljb24oaW1hZ2UsIGxheW91dCkge1xuICAgIGlmICghaW1hZ2UgfHwgIWltYWdlLnJlY3QpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGR4ID0gbGF5b3V0WydpY29uLW9mZnNldCddWzBdO1xuICAgIHZhciBkeSA9IGxheW91dFsnaWNvbi1vZmZzZXQnXVsxXTtcbiAgICB2YXIgeDEgPSBkeCAtIGltYWdlLndpZHRoIC8gMjtcbiAgICB2YXIgeDIgPSB4MSArIGltYWdlLnJlY3QudztcbiAgICB2YXIgeTEgPSBkeSAtIGltYWdlLmhlaWdodCAvIDI7XG4gICAgdmFyIHkyID0geTEgKyBpbWFnZS5yZWN0Lmg7XG5cbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uZWRJY29uKGltYWdlLCB5MSwgeTIsIHgxLCB4Mik7XG59XG5cbmZ1bmN0aW9uIFBvc2l0aW9uZWRJY29uKGltYWdlLCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCaW5QYWNrID0gcmVxdWlyZSgnLi9iaW5fcGFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUF0bGFzO1xuZnVuY3Rpb24gU3ByaXRlQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHRoaXMuYmluID0gbmV3IEJpblBhY2sod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnRleHR1cmUgPSAwOyAvLyBXZWJHTCBJRFxuICAgIHRoaXMuZmlsdGVyID0gMDsgLy8gV2ViR0wgSURcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufVxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0IGRlYnVnKCkge1xuICAgICAgICByZXR1cm4gJ2NhbnZhcycgaW4gdGhpcztcbiAgICB9LFxuICAgIHNldCBkZWJ1Zyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jdHg7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24obmV3UmF0aW8pIHtcbiAgICBpZiAodGhpcy5waXhlbFJhdGlvID09PSBuZXdSYXRpbykgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG9sZFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IG5ld1JhdGlvO1xuXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgb2xkRGF0YSA9IHRoaXMuZGF0YTtcblxuICAgICAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZSgpO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgb2xkV2lkdGggPSB0aGlzLndpZHRoICogb2xkUmF0aW87XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCAqIG9sZFJhdGlvO1xuICAgICAgICB2YXIgbmV3V2lkdGggPSB0aGlzLndpZHRoICogbmV3UmF0aW87XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodCAqIG5ld1JhdGlvO1xuXG4gICAgICAgIC8vIEJhc2ljIGltYWdlIHNjYWxpbmcuIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGJldHRlciBpbWFnZSBzY2FsaW5nLlxuICAgICAgICB2YXIgbmV3SW1hZ2UgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBvbGRJbWFnZSA9IG9sZERhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBuZXdIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFyIG9sZFlPZmZzZXQgPSBNYXRoLmZsb29yKCh5ICogb2xkSGVpZ2h0KSAvIG5ld0hlaWdodCkgKiBvbGRXaWR0aDtcbiAgICAgICAgICAgIHZhciBuZXdZT2Zmc2V0ID0geSAqIG5ld1dpZHRoO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBuZXdXaWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFggPSBNYXRoLmZsb29yKCh4ICogb2xkV2lkdGgpIC8gbmV3V2lkdGgpO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlW25ld1lPZmZzZXQgKyB4XSA9IG9sZEltYWdlW29sZFlPZmZzZXQgKyBvbGRYXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9sZERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kaXJ0eTtcbn07XG5cbmZ1bmN0aW9uIGNvcHlCaXRtYXAoc3JjLCBzcmNTdHJpZGUsIHNyY1gsIHNyY1ksIGRzdCwgZHN0U3RyaWRlLCBkc3RYLCBkc3RZLCB3aWR0aCwgaGVpZ2h0LCB3cmFwKSB7XG4gICAgdmFyIHNyY0kgPSBzcmNZICogc3JjU3RyaWRlICsgc3JjWDtcbiAgICB2YXIgZHN0SSA9IGRzdFkgKiBkc3RTdHJpZGUgKyBkc3RYO1xuICAgIHZhciB4LCB5O1xuXG4gICAgaWYgKHdyYXApIHtcbiAgICAgICAgLy8gYWRkIDEgcGl4ZWwgd3JhcHBlZCBwYWRkaW5nIG9uIGVhY2ggc2lkZSBvZiB0aGUgaW1hZ2VcbiAgICAgICAgZHN0SSAtPSBkc3RTdHJpZGU7XG4gICAgICAgIGZvciAoeSA9IC0xOyB5IDw9IGhlaWdodDsgeSsrLCBzcmNJID0gKCh5ICsgaGVpZ2h0KSAlIGhlaWdodCArIHNyY1kpICogc3JjU3RyaWRlICsgc3JjWCwgZHN0SSArPSBkc3RTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IC0xOyB4IDw9IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBkc3RbZHN0SSArIHhdID0gc3JjW3NyY0kgKyAoKHggKyB3aWR0aCkgJSB3aWR0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyssIHNyY0kgKz0gc3JjU3RyaWRlLCBkc3RJICs9IGRzdFN0cmlkZSkge1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBkc3RbZHN0SSArIHhdID0gc3JjW3NyY0kgKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFsbG9jYXRlSW1hZ2UgPSBmdW5jdGlvbihwaXhlbFdpZHRoLCBwaXhlbEhlaWdodCkge1xuXG4gICAgLy8gSW5jcmVhc2UgdG8gbmV4dCBudW1iZXIgZGl2aXNpYmxlIGJ5IDQsIGJ1dCBhdCBsZWFzdCAxLlxuICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIHNjYWxlIGRvd24gdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHBhY2sgdGhlbVxuICAgIC8vIGludG8gMiBieXRlcyByYXRoZXIgdGhhbiA0IGJ5dGVzLlxuICAgIC8vIFBhZCBpY29ucyB0byBwcmV2ZW50IHRoZW0gZnJvbSBwb2xsdXRpbmcgbmVpZ2hib3VycyBkdXJpbmcgbGluZWFyIGludGVycG9sYXRpb25cbiAgICB2YXIgcGFkZGluZyA9IDI7XG4gICAgdmFyIHBhY2tXaWR0aCA9IHBpeGVsV2lkdGggKyBwYWRkaW5nICsgKDQgLSAocGl4ZWxXaWR0aCArIHBhZGRpbmcpICUgNCk7XG4gICAgdmFyIHBhY2tIZWlnaHQgPSBwaXhlbEhlaWdodCArIHBhZGRpbmcgKyAoNCAtIChwaXhlbEhlaWdodCArIHBhZGRpbmcpICUgNCk7Ly8gKyA0O1xuXG4gICAgLy8gV2UgaGF2ZSB0byBhbGxvY2F0ZSBhIG5ldyBhcmVhIGluIHRoZSBiaW4sIGFuZCBzdG9yZSBhbiBlbXB0eSBpbWFnZSBpbiBpdC5cbiAgICAvLyBBZGQgYSAxcHggYm9yZGVyIGFyb3VuZCBldmVyeSBpbWFnZS5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYmluLmFsbG9jYXRlKHBhY2tXaWR0aCwgcGFja0hlaWdodCk7XG4gICAgaWYgKHJlY3QudyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICByZWN0Lm9yaWdpbmFsV2lkdGggPSBwaXhlbFdpZHRoO1xuICAgIHJlY3Qub3JpZ2luYWxIZWlnaHQgPSBwaXhlbEhlaWdodDtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24obmFtZSwgd3JhcCkge1xuICAgIGlmICh0aGlzLmltYWdlc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbbmFtZV07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNwcml0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gdGhpcy5zcHJpdGUuZ2V0U3ByaXRlUG9zaXRpb24obmFtZSk7XG4gICAgaWYgKCFwb3Mud2lkdGggfHwgIXBvcy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gcG9zLndpZHRoIC8gcG9zLnBpeGVsUmF0aW87XG4gICAgdmFyIGhlaWdodCA9IHBvcy5oZWlnaHQgLyBwb3MucGl4ZWxSYXRpbztcbiAgICB2YXIgcmVjdCA9IHRoaXMuYWxsb2NhdGVJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAocmVjdC53ID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IG5ldyBBdGxhc0ltYWdlKHJlY3QsIHdpZHRoLCBoZWlnaHQsIHBvcy5zZGYpO1xuICAgIHRoaXMuaW1hZ2VzW25hbWVdID0gaW1hZ2U7XG5cbiAgICB0aGlzLmNvcHkocmVjdCwgcG9zLCB3cmFwKTtcblxuICAgIHJldHVybiBpbWFnZTtcbn07XG5cblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24obmFtZSwgcmVwZWF0aW5nKSB7XG4gICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZShuYW1lLCByZXBlYXRpbmcpO1xuICAgIHZhciByZWN0ID0gaW1hZ2UgJiYgaW1hZ2UucmVjdDtcblxuICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBpbWFnZSBpcyByZXBlYXRpbmcsIGdldCB0aGUgY29ycmVjdCBwb3NpdGlvbiBvZiB0aGUgaW1hZ2UsIHJhdGhlciB0aGFuIHRoZVxuICAgIC8vIG9uZSByb3VuZGVkIHVwIHRvIDQgcGl4ZWxzLlxuICAgIHZhciB3aWR0aCA9IHJlcGVhdGluZyA/IGltYWdlLndpZHRoIDogcmVjdC53O1xuICAgIHZhciBoZWlnaHQgPSByZXBlYXRpbmcgPyBpbWFnZS5oZWlnaHQgOiByZWN0Lmg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICAgIHRsOiBbKHJlY3QueCkgICAgICAgICAvIHRoaXMud2lkdGgsIChyZWN0LnkpICAgICAgICAgIC8gdGhpcy5oZWlnaHRdLFxuICAgICAgICBicjogWyhyZWN0LnggKyB3aWR0aCkgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgaGVpZ2h0KSAvIHRoaXMuaGVpZ2h0XVxuICAgIH07XG59O1xuXG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5hbGxvY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICAgIHZhciB3ID0gTWF0aC5mbG9vcih0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdmFyIGggPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IFVpbnQzMkFycmF5KHcgKiBoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oZHN0LCBzcmMsIHdyYXApIHtcbiAgICAvLyBpZiAoIXNwcml0ZS0+cmFzdGVyKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnNwcml0ZS5pbWcuZGF0YSkgcmV0dXJuO1xuICAgIHZhciBzcmNJbWcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5zcHJpdGUuaW1nLmRhdGEuYnVmZmVyKTtcblxuICAgIHRoaXMuYWxsb2NhdGUoKTtcbiAgICB2YXIgZHN0SW1nID0gdGhpcy5kYXRhO1xuXG4gICAgY29weUJpdG1hcChcbiAgICAgICAgLyogc291cmNlIGJ1ZmZlciAqLyAgc3JjSW1nLFxuICAgICAgICAvKiBzb3VyY2Ugc3RyaWRlICovICB0aGlzLnNwcml0ZS5pbWcud2lkdGgsXG4gICAgICAgIC8qIHNvdXJjZSB4ICovICAgICAgIHNyYy54LFxuICAgICAgICAvKiBzb3VyY2UgeSAqLyAgICAgICBzcmMueSxcbiAgICAgICAgLyogZGVzdCBidWZmZXIgKi8gICAgZHN0SW1nLFxuICAgICAgICAvKiBkZXN0IHN0cmlkZSAqLyAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAvKiBkZXN0IHggKi8gICAgICAgICBkc3QueCAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgLyogZGVzdCB5ICovICAgICAgICAgZHN0LnkgKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIC8qIGljb24gZGltZW5zaW9uICovIHNyYy53aWR0aCxcbiAgICAgICAgLyogaWNvbiBkaW1lbnNpb24gKi8gc3JjLmhlaWdodCxcbiAgICAgICAgLyogd3JhcCAqLyB3cmFwXG4gICAgKTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLmFkZEljb25zID0gZnVuY3Rpb24oaWNvbnMsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpY29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmdldEltYWdlKGljb25zW2ldKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCB0aGlzLmltYWdlcyk7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGdsLCBsaW5lYXIpIHtcbiAgICB2YXIgZmlyc3QgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlclZhbCA9IGxpbmVhciA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgaWYgKGZpbHRlclZhbCAhPT0gdGhpcy5maWx0ZXIpIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclZhbCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJWYWwpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlclZhbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICB0aGlzLmFsbG9jYXRlKCk7XG5cbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIC8vIGVudW0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW5kIGxldmVsXG4gICAgICAgICAgICAgICAgZ2wuUkdCQSwgLy8gaW5kIGludGVybmFsZm9ybWF0XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgLy8gR0xzaXplaSB3aWR0aFxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvLCAvLyBHTHNpemVpIGhlaWdodFxuICAgICAgICAgICAgICAgIDAsIC8vIGluZCBib3JkZXJcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBlbnVtIGZvcm1hdFxuICAgICAgICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsIC8vIGVudW0gdHlwZVxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpIC8vIE9iamVjdCBkYXRhXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELCAvLyBlbnVtIHRhcmdldFxuICAgICAgICAgICAgICAgIDAsIC8vIGludCBsZXZlbFxuICAgICAgICAgICAgICAgIDAsIC8vIGludCB4b2Zmc2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IHlvZmZzZXRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCAvLyBsb25nIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8sIC8vIGxvbmcgaGVpZ2h0XG4gICAgICAgICAgICAgICAgZ2wuUkdCQSwgLy8gZW51bSBmb3JtYXRcbiAgICAgICAgICAgICAgICBnbC5VTlNJR05FRF9CWVRFLCAvLyBlbnVtIHR5cGVcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKSAvLyBPYmplY3QgcGl4ZWxzXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIERFQlVHXG4gICAgICAgIGlmICh0aGlzLmN0eCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgZGF0YS5kYXRhLnNldChuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy5kYXRhLmJ1ZmZlcikpO1xuICAgICAgICAgICAgdGhpcy5jdHgucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmJpbi5mcmVlLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyZWUgPSB0aGlzLmJpbi5mcmVlW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZVJlY3QoZnJlZS54ICogdGhpcy5waXhlbFJhdGlvLCBmcmVlLnkgKiB0aGlzLnBpeGVsUmF0aW8sIGZyZWUudyAqIHRoaXMucGl4ZWxSYXRpbywgZnJlZS5oICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFTkQgREVCVUdcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBBdGxhc0ltYWdlKHJlY3QsIHdpZHRoLCBoZWlnaHQsIHNkZikge1xuICAgIHRoaXMucmVjdCA9IHJlY3Q7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2RmID0gc2RmO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0aW9uO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXR0cmlidXRpb24gY29udHJvbFxuICogQGNsYXNzIEF0dHJpYnV0aW9uXG4gKiBAZXhhbXBsZVxuICogbWFwLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uKCkpO1xuICovXG5mdW5jdGlvbiBBdHRyaWJ1dGlvbigpIHt9XG5cbkF0dHJpYnV0aW9uLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChDb250cm9sLCB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbS1yaWdodCdcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwtYXR0cmliJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgbWFwLmdldENvbnRhaW5lcigpKTtcblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UubG9hZCcsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdzb3VyY2UuY2hhbmdlJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5yZW1vdmUnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZUVkaXRMaW5rLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXR0cmlidXRpb25zID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcC5zdHlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fbWFwLnN0eWxlLnNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fbWFwLnN0eWxlLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuYXR0cmlidXRpb24gJiYgYXR0cmlidXRpb25zLmluZGV4T2Yoc291cmNlLmF0dHJpYnV0aW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRpb25zLnB1c2goc291cmNlLmF0dHJpYnV0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250YWluZXIuaW5uZXJIVE1MID0gYXR0cmlidXRpb25zLmpvaW4oJyB8ICcpO1xuICAgICAgICB0aGlzLl9lZGl0TGluayA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYXBib3gtaW1wcm92ZS1tYXAnKVswXTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRWRpdExpbmsoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVkaXRMaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRMaW5rKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdExpbmsuaHJlZiA9ICdodHRwczovL3d3dy5tYXBib3guY29tL21hcC1mZWVkYmFjay8jLycgK1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXIubG5nICsgJy8nICsgY2VudGVyLmxhdCArICcvJyArIE1hdGgucm91bmQodGhpcy5fbWFwLmdldFpvb20oKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbDtcblxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIG1hcC1yZWxhdGVkIGludGVyZmFjZSBlbGVtZW50cy5cbiAqXG4gKiBAY2xhc3MgQ29udHJvbFxuICovXG5mdW5jdGlvbiBDb250cm9sKCkge31cblxuQ29udHJvbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIHRoaXMgY29udHJvbCB0byB0aGUgbWFwLCByZXR1cm5pbmcgdGhlIGNvbnRyb2wgaXRzZWxmXG4gICAgICogZm9yIGNoYWluaW5nLiBUaGlzIHdpbGwgaW5zZXJ0IHRoZSBjb250cm9sJ3MgRE9NIGVsZW1lbnQgaW50b1xuICAgICAqIHRoZSBtYXAncyBET00gZWxlbWVudCBpZiB0aGUgY29udHJvbCBoYXMgYSBgcG9zaXRpb25gIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7Q29udHJvbH0gdGhpc1xuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHZhciBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lICs9ICcgbWFwYm94Z2wtY3RybCc7XG4gICAgICAgICAgICBpZiAocG9zLmluZGV4T2YoJ2JvdHRvbScpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcm5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIGNvbnRyb2wgZnJvbSB0aGUgbWFwIGl0IGhhcyBiZWVuIGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NvbnRyb2x9IHRoaXNcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBpZiAodGhpcy5vblJlbW92ZSkgdGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xuICAgICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb247XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5hdmlnYXRpb24gY29udHJvbCB3aXRoIHpvb20gYnV0dG9ucyBhbmQgYSBjb21wYXNzXG4gKiBAY2xhc3MgTmF2aWdhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBvc2l0aW9uPXRvcC1yaWdodF0gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGB0b3AtcmlnaHRgLCBgdG9wLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCwgYGJvdHRvbS1sZWZ0YFxuICogQGV4YW1wbGVcbiAqIG1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5OYXZpZ2F0aW9uKHtwb3NpdGlvbjogJ3RvcC1sZWZ0J30pKTsgLy8gcG9zaXRpb24gaXMgb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gTmF2aWdhdGlvbihvcHRpb25zKSB7XG4gICAgdXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5OYXZpZ2F0aW9uLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChDb250cm9sLCB7XG4gICAgb3B0aW9uczoge1xuICAgICAgICBwb3NpdGlvbjogJ3RvcC1yaWdodCdcbiAgICB9LFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ21hcGJveGdsLWN0cmwnO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWdyb3VwJywgbWFwLmdldENvbnRhaW5lcigpKTtcblxuICAgICAgICB0aGlzLl96b29tSW5CdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1pY29uICcgKyBjbGFzc05hbWUgKyAnLXpvb20taW4nLCBtYXAuem9vbUluLmJpbmQobWFwKSk7XG4gICAgICAgIHRoaXMuX3pvb21PdXRCdXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oY2xhc3NOYW1lICsgJy1pY29uICcgKyBjbGFzc05hbWUgKyAnLXpvb20tb3V0JywgbWFwLnpvb21PdXQuYmluZChtYXApKTtcbiAgICAgICAgdGhpcy5fY29tcGFzcyA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLWNvbXBhc3MnLCBtYXAucmVzZXROb3J0aC5iaW5kKG1hcCkpO1xuXG4gICAgICAgIHZhciBjb21wYXNzQ2FudmFzID0gdGhpcy5fY29tcGFzc0NhbnZhcyA9IERPTS5jcmVhdGUoJ2NhbnZhcycsIGNsYXNzTmFtZSArICctY29tcGFzcy1jYW52YXMnLCB0aGlzLl9jb21wYXNzKTtcbiAgICAgICAgY29tcGFzc0NhbnZhcy5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjI2cHg7IGhlaWdodDoyNnB4Oyc7XG4gICAgICAgIGNvbXBhc3NDYW52YXMud2lkdGggPSAyNiAqIDI7XG4gICAgICAgIGNvbXBhc3NDYW52YXMuaGVpZ2h0ID0gMjYgKiAyO1xuXG4gICAgICAgIHRoaXMuX2NvbXBhc3MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Db21wYXNzRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb25Db21wYXNzTW92ZSA9IHRoaXMuX29uQ29tcGFzc01vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25Db21wYXNzVXAgPSB0aGlzLl9vbkNvbXBhc3NVcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2NvbXBhc3NDdHggPSBjb21wYXNzQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgbWFwLm9uKCdyb3RhdGUnLCB0aGlzLl9kcmF3Tm9ydGguYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RyYXdOb3J0aCgpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF9vbkNvbXBhc3NEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIERPTS5kaXNhYmxlRHJhZygpO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQ29tcGFzc01vdmUpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Db21wYXNzVXApO1xuICAgICAgICB0aGlzLl9wcmV2WCA9IGUuc2NyZWVuWDtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzTW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgeCA9IGUuc2NyZWVuWCxcbiAgICAgICAgICAgIGQgPSB4IDwgMiA/IC01IDogLy8gbGVmdCBlZGdlIG9mIHRoZSBzY3JlZW4sIGNvbnRpbnVlIHJvdGF0aW5nXG4gICAgICAgICAgICAgICAgeCA+IHdpbmRvdy5zY3JlZW4ud2lkdGggLSAyID8gNSA6IC8vIHJpZ2h0IGVkZ2VcbiAgICAgICAgICAgICAgICAoeCAtIHRoaXMuX3ByZXZYKSAvIDQ7XG5cbiAgICAgICAgdGhpcy5fbWFwLnNldEJlYXJpbmcodGhpcy5fbWFwLmdldEJlYXJpbmcoKSAtIGQpO1xuICAgICAgICB0aGlzLl9wcmV2WCA9IGUuc2NyZWVuWDtcbiAgICAgICAgdGhpcy5fbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uQ29tcGFzc1VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Db21wYXNzTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNvbXBhc3NVcCk7XG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgRE9NLnN1cHByZXNzQ2xpY2soKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY3JlYXRlQnV0dG9uOiBmdW5jdGlvbihjbGFzc05hbWUsIGZuKSB7XG4gICAgICAgIHZhciBhID0gRE9NLmNyZWF0ZSgnYnV0dG9uJywgY2xhc3NOYW1lLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGZuKCk7IH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgX2RyYXdOb3J0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYWQgPSAyMCxcbiAgICAgICAgICAgIHdpZHRoID0gOCxcbiAgICAgICAgICAgIGNlbnRlciA9IDI2LFxuICAgICAgICAgICAgYW5nbGUgPSB0aGlzLl9tYXAudHJhbnNmb3JtLmFuZ2xlICsgKE1hdGguUEkgLyAyKSxcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2NvbXBhc3NDdHg7XG5cbiAgICAgICAgdGhpcy5fY29tcGFzc0NhbnZhcy53aWR0aCA9IHRoaXMuX2NvbXBhc3NDYW52YXMud2lkdGg7XG5cbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgY3R4LmxpbmVUbygwLCAtd2lkdGgpO1xuICAgICAgICBjdHgubGluZVRvKC1yYWQsIDApO1xuICAgICAgICBjdHgubGluZVRvKDAsIHdpZHRoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2JiYic7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgd2lkdGgpO1xuICAgICAgICBjdHgubGluZVRvKHJhZCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZmZmJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDQ7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgLXdpZHRoKTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB3aWR0aCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdF9sbmcnKTtcbnZhciBMYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbGF0X2xuZ19ib3VuZHMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gW2FuaW1PcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFthbmltT3B0aW9ucy5kdXJhdGlvbj01MDBdIE51bWJlciBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFuaW1PcHRpb25zLmVhc2luZ1xuICogQHBhcmFtIHtBcnJheX0gW2FuaW1PcHRpb25zLm9mZnNldD1bMCwwXV0gcG9pbnQsIG9yaWdpbiBvZiBtb3ZlbWVudCByZWxhdGl2ZSB0byBtYXAgY2VudGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthbmltT3B0aW9ucy5hbmltYXRlPXRydWVdIFdoZW4gc2V0IHRvIGZhbHNlLCBubyBhbmltYXRpb24gaGFwcGVuc1xuICovXG51dGlsLmV4dGVuZChleHBvcnRzLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG4gICAgaXNFYXNpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hYm9ydEZuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Fib3J0Rm4pIHtcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0Rm4uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hYm9ydEZuO1xuXG4gICAgICAgICAgICB0aGlzLl9maW5pc2hGbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZpbmlzaEZuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZWFzZTogZnVuY3Rpb24oZnJhbWUsIGZpbmlzaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9maW5pc2hGbiA9IGZpbmlzaDtcbiAgICAgICAgdGhpcy5fYWJvcnRGbiA9IGJyb3dzZXIudGltZWQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZyYW1lLmNhbGwodGhpcywgb3B0aW9ucy5lYXNpbmcodCkpO1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYWJvcnRGbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hGbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9maW5pc2hGbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSA/IDAgOiBvcHRpb25zLmR1cmF0aW9uLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIGJ5IGEgY2VydGFpbiBudW1iZXIgb2YgcGl4ZWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvZmZzZXQgW3gsIHldXG4gICAgICogQHBhcmFtIHthbmltT3B0aW9uc31cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBwYW5CeTogZnVuY3Rpb24ob2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLCB1dGlsLmV4dGVuZCh7b2Zmc2V0OiBQb2ludC5jb252ZXJ0KG9mZnNldCkubXVsdCgtMSl9LCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdG8gYSBjZXJ0YWluIGxvY2F0aW9uIHdpdGggZWFzaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF0bG5nIGEgYExhdExuZ2Agb2JqZWN0XG4gICAgICogQHBhcmFtIHthbmltT3B0aW9uc31cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBwYW5UbzogZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIGxhdGxuZyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZSxcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDBdXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCkucm90YXRlKC10ci5hbmdsZSksXG4gICAgICAgICAgICBmcm9tID0gdHIucG9pbnQsXG4gICAgICAgICAgICB0byA9IHRyLnByb2plY3QobGF0bG5nKS5zdWIob2Zmc2V0KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMubm9Nb3ZlU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lYXNlKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdChrKSkpO1xuICAgICAgICAgICAgdGhpcy5fbW92ZSgpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbXMgdG8gYSBjZXJ0YWluIHpvb20gbGV2ZWwgd2l0aCBlYXNpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gem9vbVxuICAgICAqIEBwYXJhbSB7YW5pbU9wdGlvbnN9XG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgem9vbVRvOiBmdW5jdGlvbih6b29tLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIG9wdGlvbnMuZWFzaW5nID0gdGhpcy5fdXBkYXRlRWFzaW5nKG9wdGlvbnMuZHVyYXRpb24sIHpvb20sIG9wdGlvbnMuZWFzaW5nKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLmNlbnRlcixcbiAgICAgICAgICAgIHN0YXJ0Wm9vbSA9IHRyLnpvb207XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXJvdW5kKSB7XG4gICAgICAgICAgICBhcm91bmQgPSBMYXRMbmcuY29udmVydChvcHRpb25zLmFyb3VuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgICAgICAgIGFyb3VuZCA9IHRyLnBvaW50TG9jYXRpb24odHIuY2VudGVyUG9pbnQuYWRkKFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkgb3B0aW9ucy5kdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKCF0aGlzLnpvb21pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZWFzZShmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICB0ci5zZXRab29tQXJvdW5kKGludGVycG9sYXRlKHN0YXJ0Wm9vbSwgem9vbSwgayksIGFyb3VuZCk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3Auc2V0KDMwMCk7IC8vIHRleHQgZmFkaW5nXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKHRydWUpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZWFzZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA+PSAyMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPCAyMDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vblpvb21FbmQpO1xuICAgICAgICAgICAgdGhpcy5fb25ab29tRW5kID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFpvb20gaW4gYnkgMSBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHthbmltT3B0aW9uc31cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICB6b29tSW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgKyAxLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSBvdXQgYnkgMSBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHthbmltT3B0aW9uc31cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICB6b29tT3V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuem9vbVRvKHRoaXMuZ2V0Wm9vbSgpIC0gMSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZSBiZWFyaW5nIGJ5IGEgY2VydGFpbiBudW1iZXIgb2YgZGVncmVlcyB3aXRoIGVhc2luZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJlYXJpbmdcbiAgICAgKiBAcGFyYW0ge2FuaW1PcHRpb25zfVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbihiZWFyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgYXJvdW5kID0gdHIuY2VudGVyO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFyb3VuZCkge1xuICAgICAgICAgICAgYXJvdW5kID0gTGF0TG5nLmNvbnZlcnQob3B0aW9ucy5hcm91bmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgICAgICBhcm91bmQgPSB0ci5wb2ludExvY2F0aW9uKHRyLmNlbnRlclBvaW50LmFkZChQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVhcmluZyA9IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcoYmVhcmluZywgc3RhcnQpO1xuXG4gICAgICAgIHRoaXMucm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgdHIuc2V0QmVhcmluZ0Fyb3VuZChpbnRlcnBvbGF0ZShzdGFydCwgYmVhcmluZywgayksIGFyb3VuZCk7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgbWFwIGJlYXJpbmcgdG8gMCAobm9ydGgpIHdpdGggZWFzaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FuaW1PcHRpb25zfVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHt0aGlzfVxuICAgICAqL1xuICAgIHJlc2V0Tm9ydGg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRlVG8oMCwgdXRpbC5leHRlbmQoe2R1cmF0aW9uOiAxMDAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tIHRvIGNvbnRhaW4gY2VydGFpbiBnZW9ncmFwaGljYWwgYm91bmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBib3VuZHMgW1ttaW5MYXQsIG1pbkxuZ10sIFttYXhMYXQsIG1heExuZ11dXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3BlZWQ9MS4yXSBIb3cgZmFzdCBhbmltYXRpb24gb2NjdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmN1cnZlPTEuNDJdIEhvdyBtdWNoIHpvb21pbmcgb3V0IG9jY3VycyBkdXJpbmcgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lYXNpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYWRkaW5nIGhvdyBtdWNoIHBhZGRpbmcgdGhlcmUgaXMgYXJvdW5kIHRoZSBnaXZlbiBib3VuZHMgb24gZWFjaCBzaWRlIGluIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heFpvb21cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBmaXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBtYXhab29tOiBJbmZpbml0eVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICBib3VuZHMgPSBMYXRMbmdCb3VuZHMuY29udmVydChib3VuZHMpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSxcbiAgICAgICAgICAgIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBudyA9IHRyLnByb2plY3QoYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcbiAgICAgICAgICAgIHNlID0gdHIucHJvamVjdChib3VuZHMuZ2V0U291dGhFYXN0KCkpLFxuICAgICAgICAgICAgc2l6ZSA9IHNlLnN1YihudyksXG4gICAgICAgICAgICBjZW50ZXIgPSB0ci51bnByb2plY3QobncuYWRkKHNlKS5kaXYoMikpLFxuXG4gICAgICAgICAgICBzY2FsZVggPSAodHIud2lkdGggLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LngpICogMikgLyBzaXplLngsXG4gICAgICAgICAgICBzY2FsZVkgPSAodHIuaGVpZ2h0IC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC55KSAqIDIpIC8gc2l6ZS55LFxuXG4gICAgICAgICAgICB6b29tID0gTWF0aC5taW4odHIuc2NhbGVab29tKHRyLnNjYWxlICogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSwgb3B0aW9ucy5tYXhab29tKTtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5saW5lYXIgP1xuICAgICAgICAgICAgdGhpcy5lYXNlVG8oY2VudGVyLCB6b29tLCAwLCBvcHRpb25zKSA6XG4gICAgICAgICAgICB0aGlzLmZseVRvKGNlbnRlciwgem9vbSwgMCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVhc2luZyBhbmltYXRpb24gdG8gYSBzcGVjaWZpZWQgbG9jYXRpb24vem9vbS9iZWFyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF0bG5nIGEgYExhdExuZ2Agb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHpvb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYmVhcmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwaXRjaFxuICAgICAqIEBwYXJhbSB7YW5pbU9wdGlvbnN9XG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgZWFzZVRvOiBmdW5jdGlvbihsYXRsbmcsIHpvb20sIGJlYXJpbmcsIHBpdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgICAgICBlYXNpbmc6IHV0aWwuZWFzZVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLnJvdGF0ZSgtdHIuYW5nbGUpLFxuICAgICAgICAgICAgc3RhcnRab29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHN0YXJ0UGl0Y2ggPSB0aGlzLmdldFBpdGNoKCk7XG5cbiAgICAgICAgbGF0bG5nID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcbiAgICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHpvb207XG4gICAgICAgIGJlYXJpbmcgPSBiZWFyaW5nID09PSB1bmRlZmluZWQgPyBzdGFydEJlYXJpbmcgOiB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKGJlYXJpbmcsIHN0YXJ0QmVhcmluZyk7XG4gICAgICAgIHBpdGNoID0gcGl0Y2ggPT09IHVuZGVmaW5lZCA/IHN0YXJ0UGl0Y2ggOiBwaXRjaDtcblxuICAgICAgICB2YXIgc2NhbGUgPSB0ci56b29tU2NhbGUoem9vbSAtIHN0YXJ0Wm9vbSksXG4gICAgICAgICAgICBmcm9tID0gdHIucG9pbnQsXG4gICAgICAgICAgICB0byA9IGxhdGxuZyA/IHRyLnByb2plY3QobGF0bG5nKS5zdWIob2Zmc2V0LmRpdihzY2FsZSkpIDogdHIucG9pbnQsXG4gICAgICAgICAgICBhcm91bmQ7XG5cbiAgICAgICAgaWYgKHpvb20gIT09IHN0YXJ0Wm9vbSkge1xuICAgICAgICAgICAgYXJvdW5kID0gdHIucG9pbnRMb2NhdGlvbih0ci5jZW50ZXJQb2ludC5hZGQodG8uc3ViKGZyb20pLmRpdigxIC0gMSAvIHNjYWxlKSkpO1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKSB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICh6b29tICE9PSBzdGFydFpvb20pIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRab29tQXJvdW5kKGludGVycG9sYXRlKHN0YXJ0Wm9vbSwgem9vbSwgayksIGFyb3VuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdChrKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmVhcmluZyAhPT0gc3RhcnRCZWFyaW5nKSB7XG4gICAgICAgICAgICAgICAgdHIuYmVhcmluZyA9IGludGVycG9sYXRlKHN0YXJ0QmVhcmluZywgYmVhcmluZywgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwaXRjaCAhPT0gc3RhcnRQaXRjaCkge1xuICAgICAgICAgICAgICAgIHRyLnBpdGNoID0gaW50ZXJwb2xhdGUoc3RhcnRQaXRjaCwgcGl0Y2gsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3Auc2V0KDMwMCk7IC8vIHRleHQgZmFkaW5nXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKHpvb20gIT09IHN0YXJ0Wm9vbSwgYmVhcmluZyAhPT0gc3RhcnRCZWFyaW5nKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmx5aW5nIGFuaW1hdGlvbiB0byBhIHNwZWNpZmllZCBsb2NhdGlvbi96b29tL2JlYXJpbmcgd2l0aCBhdXRvbWF0aWMgY3VydmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXRsbmcgYSBgTGF0TG5nYCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gem9vbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiZWFyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3BlZWQ9MS4yXSBIb3cgZmFzdCBhbmltYXRpb24gb2NjdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmN1cnZlPTEuNDJdIEhvdyBtdWNoIHpvb21pbmcgb3V0IG9jY3VycyBkdXJpbmcgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5lYXNpbmdcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBmbHlUbzogZnVuY3Rpb24obGF0bG5nLCB6b29tLCBiZWFyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIHNwZWVkOiAxLjIsXG4gICAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIGxhdGxuZyA9IExhdExuZy5jb252ZXJ0KGxhdGxuZyk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucy5vZmZzZXQpLFxuICAgICAgICAgICAgdHIgPSB0aGlzLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgc3RhcnRCZWFyaW5nID0gdGhpcy5nZXRCZWFyaW5nKCk7XG5cbiAgICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHN0YXJ0Wm9vbSA6IHpvb207XG4gICAgICAgIGJlYXJpbmcgPSBiZWFyaW5nID09PSB1bmRlZmluZWQgPyBzdGFydEJlYXJpbmcgOiB0aGlzLl9ub3JtYWxpemVCZWFyaW5nKGJlYXJpbmcsIHN0YXJ0QmVhcmluZyk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdHIuem9vbVNjYWxlKHpvb20gLSBzdGFydFpvb20pLFxuICAgICAgICAgICAgZnJvbSA9IHRyLnBvaW50LFxuICAgICAgICAgICAgdG8gPSB0ci5wcm9qZWN0KGxhdGxuZykuc3ViKG9mZnNldC5kaXYoc2NhbGUpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0VmlldyhsYXRsbmcsIHpvb20sIGJlYXJpbmcsIHRoaXMuZ2V0UGl0Y2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRXb3JsZFNpemUgPSB0ci53b3JsZFNpemUsXG4gICAgICAgICAgICByaG8gPSBvcHRpb25zLmN1cnZlLFxuICAgICAgICAgICAgViA9IG9wdGlvbnMuc3BlZWQsXG5cbiAgICAgICAgICAgIHcwID0gTWF0aC5tYXgodHIud2lkdGgsIHRyLmhlaWdodCksXG4gICAgICAgICAgICB3MSA9IHcwIC8gc2NhbGUsXG4gICAgICAgICAgICB1MSA9IHRvLnN1Yihmcm9tKS5tYWcoKSxcbiAgICAgICAgICAgIHJobzIgPSByaG8gKiByaG87XG5cbiAgICAgICAgZnVuY3Rpb24gcihpKSB7XG4gICAgICAgICAgICB2YXIgYiA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIChpID8gLTEgOiAxKSAqIHJobzIgKiByaG8yICogdTEgKiB1MSkgLyAoMiAqIChpID8gdzEgOiB3MCkgKiByaG8yICogdTEpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKE1hdGguc3FydChiICogYiArIDEpIC0gYik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaW5oKG4pIHsgcmV0dXJuIChNYXRoLmV4cChuKSAtIE1hdGguZXhwKC1uKSkgLyAyOyB9XG4gICAgICAgIGZ1bmN0aW9uIGNvc2gobikgeyByZXR1cm4gKE1hdGguZXhwKG4pICsgTWF0aC5leHAoLW4pKSAvIDI7IH1cbiAgICAgICAgZnVuY3Rpb24gdGFuaChuKSB7IHJldHVybiBzaW5oKG4pIC8gY29zaChuKTsgfVxuXG4gICAgICAgIHZhciByMCA9IHIoMCksXG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIChjb3NoKHIwKSAvIGNvc2gocjAgKyByaG8gKiBzKSk7IH0sXG4gICAgICAgICAgICB1ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHcwICogKChjb3NoKHIwKSAqIHRhbmgocjAgKyByaG8gKiBzKSAtIHNpbmgocjApKSAvIHJobzIpIC8gdTE7IH0sXG4gICAgICAgICAgICBTID0gKHIoMSkgLSByMCkgLyByaG87XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHUxKSA8IDAuMDAwMDAxKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModzAgLSB3MSkgPCAwLjAwMDAwMSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBrID0gdzEgPCB3MCA/IC0xIDogMTtcbiAgICAgICAgICAgIFMgPSBNYXRoLmFicyhNYXRoLmxvZyh3MSAvIHcwKSkgLyByaG87XG5cbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gTWF0aC5leHAoayAqIHJobyAqIHMpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IDEwMDAgKiBTIC8gVjtcblxuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICBpZiAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKSB0aGlzLnJvdGF0aW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gayAqIFMsXG4gICAgICAgICAgICAgICAgdXMgPSB1KHMpO1xuXG4gICAgICAgICAgICB0ci56b29tID0gc3RhcnRab29tICsgdHIuc2NhbGVab29tKDEgLyB3KHMpKTtcbiAgICAgICAgICAgIHRyLmNlbnRlciA9IHRyLnVucHJvamVjdChmcm9tLmFkZCh0by5zdWIoZnJvbSkubXVsdCh1cykpLCBzdGFydFdvcmxkU2l6ZSk7XG5cbiAgICAgICAgICAgIGlmIChiZWFyaW5nICE9PSBzdGFydEJlYXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5iZWFyaW5nID0gaW50ZXJwb2xhdGUoc3RhcnRCZWFyaW5nLCBiZWFyaW5nLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wLnNldCgzMDApOyAvLyB0ZXh0IGZhZGluZ1xuXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKHRydWUsIGJlYXJpbmcgIT09IHN0YXJ0QmVhcmluZyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGNvbnZlcnQgYmVhcmluZyBzbyB0aGF0IGl0J3MgbnVtZXJpY2FsbHkgY2xvc2UgdG8gdGhlIGN1cnJlbnQgb25lIHNvIHRoYXQgaXQgaW50ZXJwb2xhdGVzIHByb3Blcmx5XG4gICAgX25vcm1hbGl6ZUJlYXJpbmc6IGZ1bmN0aW9uKGJlYXJpbmcsIGN1cnJlbnRCZWFyaW5nKSB7XG4gICAgICAgIGJlYXJpbmcgPSB1dGlsLndyYXAoYmVhcmluZywgLTE4MCwgMTgwKTtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhiZWFyaW5nIC0gY3VycmVudEJlYXJpbmcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyAtIDM2MCAtIGN1cnJlbnRCZWFyaW5nKSA8IGRpZmYpIGJlYXJpbmcgLT0gMzYwO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyArIDM2MCAtIGN1cnJlbnRCZWFyaW5nKSA8IGRpZmYpIGJlYXJpbmcgKz0gMzYwO1xuICAgICAgICByZXR1cm4gYmVhcmluZztcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVhc2luZzogZnVuY3Rpb24oZHVyYXRpb24sIHpvb20sIGJlemllcikge1xuICAgICAgICB2YXIgZWFzaW5nO1xuXG4gICAgICAgIGlmICh0aGlzLmVhc2UpIHtcbiAgICAgICAgICAgIHZhciBlYXNlID0gdGhpcy5lYXNlLFxuICAgICAgICAgICAgICAgIHQgPSAoRGF0ZS5ub3coKSAtIGVhc2Uuc3RhcnQpIC8gZWFzZS5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGVhc2UuZWFzaW5nKHQgKyAwLjAxKSAtIGVhc2UuZWFzaW5nKHQpLFxuXG4gICAgICAgICAgICAgICAgLy8gUXVpY2sgaGFjayB0byBtYWtlIG5ldyBiZXppZXIgdGhhdCBpcyBjb250aW51b3VzIHdpdGggbGFzdFxuICAgICAgICAgICAgICAgIHggPSAwLjI3IC8gTWF0aC5zcXJ0KHNwZWVkICogc3BlZWQgKyAwLjAwMDEpICogMC4wMSxcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KDAuMjcgKiAwLjI3IC0geCAqIHgpO1xuXG4gICAgICAgICAgICBlYXNpbmcgPSB1dGlsLmJlemllcih4LCB5LCAwLjI1LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGJlemllciA/IHV0aWwuYmV6aWVyLmFwcGx5KHV0aWwsIGJlemllcikgOiB1dGlsLmVhc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IGVhc2luZ1xuICAgICAgICB0aGlzLmVhc2UgPSB7XG4gICAgICAgICAgICBzdGFydDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHRvOiBNYXRoLnBvdygyLCB6b29tKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGVhc2luZztcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEludGVyYWN0aW9uID0gcmVxdWlyZSgnLi9pbnRlcmFjdGlvbicpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcbnZhciBMYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbGF0X2xuZ19ib3VuZHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGVycztcblxuZnVuY3Rpb24gSGFuZGxlcnMobWFwKSB7XG5cbiAgICB2YXIgcm90YXRlRW5kO1xuXG4gICAgdmFyIGJveDtcblxuICAgIHZhciBpbmVydGlhTGluZWFyaXR5ID0gMC4yLFxuICAgICAgICBpbmVydGlhRWFzaW5nID0gdXRpbC5iZXppZXIoMCwgMCwgaW5lcnRpYUxpbmVhcml0eSwgMSk7XG5cbiAgICBmdW5jdGlvbiBib3h6b29tRmluaXNoKCkge1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib3gpO1xuICAgICAgICAgICAgbWFwLmdldENvbnRhaW5lcigpLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLWNyb3NzaGFpcicpO1xuICAgICAgICAgICAgYm94ID0gZmFsc2U7XG4gICAgICAgICAgICBET00uZW5hYmxlRHJhZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBJbnRlcmFjdGlvbihtYXAuZ2V0Q2FudmFzKCkpXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLmxhdExuZyA9IG1hcC51bnByb2plY3QoZS5wb2ludCk7XG4gICAgICAgICAgICBtYXAuZmlyZSgnY2xpY2snLCBlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLmxhdExuZyA9IG1hcC51bnByb2plY3QoZS5wb2ludCk7XG4gICAgICAgICAgICBtYXAuZmlyZSgnbW91c2Vtb3ZlJywgZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWFwLmZpcmUoJ21vdmVzdGFydCcpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgICAgIG1hcC5yZXNpemUoKTtcbiAgICAgICAgICAgIG1hcC51cGRhdGUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIHBhbiA9IDgwO1xuICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IDI7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHpvb21CeSh6KSB7XG4gICAgICAgICAgICAgICAgbWFwLnpvb21UbyhNYXRoLnJvdW5kKG1hcC5nZXRab29tKCkpICsgKGUuc2hpZnRLZXkgPyAyIDogMSkgKiB6KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcGFuQnkodikge1xuICAgICAgICAgICAgICAgIG1hcC5wYW5CeSh2KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcm90YXRlQnkodikge1xuICAgICAgICAgICAgICAgIG1hcC5zZXRCZWFyaW5nKG1hcC5nZXRCZWFyaW5nKCkgKyB2KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgICAgICAgIGNhc2UgMTcxOlxuICAgICAgICAgICAgICAgIGNhc2UgMTg3OlxuICAgICAgICAgICAgICAgICAgICB6b29tQnkoMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg5OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgIGNhc2UgMTczOlxuICAgICAgICAgICAgICAgICAgICB6b29tQnkoLTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQnkoLXJvdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5CeShbLXBhbiwgMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVCeShyb3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFuQnkoW3BhbiwgMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgIHBhbkJ5KFswLCAtcGFuXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgIHBhbkJ5KFswLCBwYW5dKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ3BhbicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgbW91c2VMb2NhdGlvbiA9IG1hcC50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihlLnBvaW50LmFkZChlLm9mZnNldCkpO1xuICAgICAgICAgICAgbWFwLnRyYW5zZm9ybS5zZXRMb2NhdGlvbkF0UG9pbnQobW91c2VMb2NhdGlvbiwgZS5wb2ludCk7XG4gICAgICAgICAgICBtYXAuX21vdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdwYW5lbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIWUuaW5lcnRpYSkge1xuICAgICAgICAgICAgICAgIG1hcC5maXJlKCdtb3ZlZW5kJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdmVsb2NpdHkgdG8gcHgvcyAmIGFkanVzdCBmb3IgaW5jcmVhc2VkIGluaXRpYWwgYW5pbWF0aW9uIHNwZWVkIHdoZW4gZWFzaW5nIG91dFxuICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IGUuaW5lcnRpYS5tdWx0KDEwMDAgKiBpbmVydGlhTGluZWFyaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgc3BlZWQgPSB2ZWxvY2l0eS5tYWcoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXhTcGVlZCA9IDQwMDA7IC8vIHB4L3NcblxuICAgICAgICAgICAgICAgIGlmIChzcGVlZCA+PSBtYXhTcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICBzcGVlZCA9IG1heFNwZWVkO1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eS5fdW5pdCgpLl9tdWx0KG1heFNwZWVkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVjZWxlcmF0aW9uID0gODAwMCwgLy8gcHgvc14yXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3BlZWQgLyAoZGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHZlbG9jaXR5Lm11bHQoLWR1cmF0aW9uIC8gMikucm91bmQoKTtcblxuICAgICAgICAgICAgICAgIG1hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ3pvb20nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBTY2FsZSBieSBzaWdtb2lkIG9mIHNjcm9sbCB3aGVlbCBkZWx0YS5cbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDIgLyAoMSArIE1hdGguZXhwKC1NYXRoLmFicyhlLmRlbHRhIC8gMTAwKSkpO1xuICAgICAgICAgICAgaWYgKGUuZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSBzY2FsZSA9IDEgLyBzY2FsZTtcblxuICAgICAgICAgICAgdmFyIGZyb21TY2FsZSA9IG1hcC5lYXNlICYmIGlzRmluaXRlKGUuZGVsdGEpID8gbWFwLmVhc2UudG8gOiBtYXAudHJhbnNmb3JtLnNjYWxlLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gIWlzRmluaXRlKGUuZGVsdGEpID8gODAwIDogMDtcblxuICAgICAgICAgICAgbWFwLnpvb21UbyhtYXAudHJhbnNmb3JtLnNjYWxlWm9vbShmcm9tU2NhbGUgKiBzY2FsZSksIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgYXJvdW5kOiBtYXAudW5wcm9qZWN0KGUucG9pbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdyb3RhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gbWFwLnRyYW5zZm9ybS5jZW50ZXJQb2ludCwgLy8gQ2VudGVyIG9mIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgc3RhcnRUb0NlbnRlciA9IGUuc3RhcnQuc3ViKGNlbnRlciksXG4gICAgICAgICAgICAgICAgc3RhcnRUb0NlbnRlckRpc3QgPSBzdGFydFRvQ2VudGVyLm1hZygpO1xuXG4gICAgICAgICAgICBtYXAucm90YXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2xpY2sgd2FzIHRvbyBjbG9zZSB0byB0aGUgY2VudGVyLCBtb3ZlIHRoZSBjZW50ZXIgb2Ygcm90YXRpb24gYnkgMjAwIHBpeGVsc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgY2xpY2suXG4gICAgICAgICAgICBpZiAoc3RhcnRUb0NlbnRlckRpc3QgPCAyMDApIHtcbiAgICAgICAgICAgICAgICBjZW50ZXIgPSBlLnN0YXJ0LmFkZChuZXcgUG9pbnQoLTIwMCwgMCkuX3JvdGF0ZShzdGFydFRvQ2VudGVyLmFuZ2xlKCkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJlYXJpbmdEaWZmID0gZS5wcmV2LnN1YihjZW50ZXIpLmFuZ2xlV2l0aChlLmN1cnJlbnQuc3ViKGNlbnRlcikpIC8gTWF0aC5QSSAqIDE4MDtcbiAgICAgICAgICAgIG1hcC50cmFuc2Zvcm0uYmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCkgLSBiZWFyaW5nRGlmZjtcblxuICAgICAgICAgICAgbWFwLl9tb3ZlKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChyb3RhdGVFbmQpO1xuICAgICAgICAgICAgcm90YXRlRW5kID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbWFwLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWFwLl9yZXJlbmRlcigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdib3h6b29tc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIWJveCkge1xuICAgICAgICAgICAgICAgIGJveCA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1ib3h6b29tJywgbWFwLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgICAgICAgICBtYXAuZ2V0Q29udGFpbmVyKCkuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY3Jvc3NoYWlyJyk7XG4gICAgICAgICAgICAgICAgbWFwLmZpcmUoJ2JveHpvb21zdGFydCcpO1xuICAgICAgICAgICAgICAgIERPTS5kaXNhYmxlRHJhZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWluWCA9IE1hdGgubWluKGUuc3RhcnQueCwgZS5jdXJyZW50LngpO1xuICAgICAgICAgICAgdmFyIG1heFggPSBNYXRoLm1heChlLnN0YXJ0LngsIGUuY3VycmVudC54KTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gTWF0aC5taW4oZS5zdGFydC55LCBlLmN1cnJlbnQueSk7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IE1hdGgubWF4KGUuc3RhcnQueSwgZS5jdXJyZW50LnkpO1xuXG4gICAgICAgICAgICBET00uc2V0VHJhbnNmb3JtKGJveCwgJ3RyYW5zbGF0ZSgnICsgbWluWCArICdweCwnICsgbWluWSArICdweCknKTtcbiAgICAgICAgICAgIGJveC5zdHlsZS53aWR0aCA9IChtYXhYIC0gbWluWCkgKyAncHgnO1xuICAgICAgICAgICAgYm94LnN0eWxlLmhlaWdodCA9IChtYXhZIC0gbWluWSkgKyAncHgnO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2JveHpvb21lbmQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBib3h6b29tRmluaXNoKCk7XG5cbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTGF0TG5nQm91bmRzKFxuICAgICAgICAgICAgICAgIG1hcC51bnByb2plY3QoZS5zdGFydCksXG4gICAgICAgICAgICAgICAgbWFwLnVucHJvamVjdChlLmN1cnJlbnQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKGJvdW5kcywgeyBsaW5lYXI6IHRydWUgfSkuZmlyZSgnYm94em9vbWVuZCcsIHtcbiAgICAgICAgICAgICAgICBib3hab29tQm91bmRzOiBib3VuZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2JveHpvb21jYW5jZWwnLCBib3h6b29tRmluaXNoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIEFkZHMgcG9zaXRpb25hbCBjb29yZGluYXRlcyB0byBVUkwgaGFzaGVzLiBQYXNzZWQgYXMgYW4gb3B0aW9uIHRvIHRoZSBtYXAgb2JqZWN0XG4gKlxuICogQGNsYXNzIG1hcGJveGdsLkhhc2hcbiAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5mdW5jdGlvbiBIYXNoKCkge1xuICAgIHV0aWwuYmluZEFsbChbXG4gICAgICAgICdfb25IYXNoQ2hhbmdlJyxcbiAgICAgICAgJ191cGRhdGVIYXNoJ1xuICAgIF0sIHRoaXMpO1xufVxuXG5IYXNoLnByb3RvdHlwZSA9IHtcbiAgICAvKiBNYXAgZWxlbWVudCB0byBsaXN0ZW4gZm9yIGNvb3JkaW5hdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiBSZW1vdmVzIGhhc2hcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZUhhc2gpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uSGFzaENoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsb2MgPSBsb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgaWYgKGxvYy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldFZpZXcoWytsb2NbMV0sICtsb2NbMl1dLCArbG9jWzBdLCArKGxvY1szXSB8fCAwKSwgdGhpcy5fbWFwLmdldFBpdGNoKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlSGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9tYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgIGJlYXJpbmcgPSB0aGlzLl9tYXAuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKE1hdGgubG9nKHpvb20pIC8gTWF0aC5MTjIpKSxcblxuICAgICAgICAgICAgaGFzaCA9ICcjJyArIChNYXRoLnJvdW5kKHpvb20gKiAxMDApIC8gMTAwKSArXG4gICAgICAgICAgICAgICAgJy8nICsgY2VudGVyLmxhdC50b0ZpeGVkKHByZWNpc2lvbikgK1xuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sbmcudG9GaXhlZChwcmVjaXNpb24pICtcbiAgICAgICAgICAgICAgICAoYmVhcmluZyA/ICcvJyArIChNYXRoLnJvdW5kKGJlYXJpbmcgKiAxMCkgLyAxMCkgOiAnJyk7XG5cbiAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCcnLCAnJywgaGFzaCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uO1xuXG5mdW5jdGlvbiBJbnRlcmFjdGlvbihlbCkge1xuICAgIHZhciBpbnRlcmFjdGlvbiA9IHRoaXM7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gICAgdmFyIHJvdGF0aW5nID0gZmFsc2UsXG4gICAgICAgIHBhbm5lZCA9IGZhbHNlLFxuICAgICAgICBib3h6b29tID0gZmFsc2UsXG4gICAgICAgIGZpcnN0UG9zID0gbnVsbCxcbiAgICAgICAgcG9zID0gbnVsbCxcbiAgICAgICAgaW5lcnRpYSA9IG51bGwsXG4gICAgICAgIG5vdztcblxuICAgIGZ1bmN0aW9uIG1vdXNlUG9zKGUpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIGUuY2xpZW50WCAtIHJlY3QubGVmdCAtIGVsLmNsaWVudExlZnQsXG4gICAgICAgICAgICBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcCk7XG4gICAgfVxuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihldikge1xuICAgICAgICByb3RhdGluZyA9IHRydWU7XG4gICAgICAgIGZpcnN0UG9zID0gcG9zID0gbW91c2VQb3MoZXYpO1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbm1vdXNlZG93biwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbm1vdXNldXAsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbm1vdXNlbW92ZSwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25jbGljaywgZmFsc2UpO1xuICAgIHNjcm9sbHdoZWVsKHpvb20pO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgb25kb3VibGVjbGljaywgZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUsIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gem9vbSh0eXBlLCBkZWx0YSwgcG9pbnQpIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnem9vbScsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdHlwZSxcbiAgICAgICAgICAgIGRlbHRhOiBkZWx0YSxcbiAgICAgICAgICAgIHBvaW50OiBwb2ludFxuICAgICAgICB9KTtcbiAgICAgICAgaW5lcnRpYSA9IG51bGw7XG4gICAgICAgIG5vdyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xpY2socG9pbnQsIGV2KSB7XG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ2NsaWNrJywge3BvaW50OiBwb2ludCwgb3JpZ2luYWxFdmVudDogZXZ9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUocG9pbnQsIGV2KSB7XG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ21vdXNlbW92ZScsIHtwb2ludDogcG9pbnQsIG9yaWdpbmFsRXZlbnQ6IGV2fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFuKHBvaW50KSB7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBwb3Muc3ViKHBvaW50KTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3BhbicsIHtvZmZzZXQ6IG9mZnNldCwgcG9pbnQ6IHBvaW50fSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBhbiBhdmVyYWdlZCB2ZXJzaW9uIG9mIHRoaXMgbW92ZW1lbnQgdG8gdGhlIGluZXJ0aWEgdmVjdG9yXG4gICAgICAgICAgICBpZiAoaW5lcnRpYSkge1xuICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgICAgICAgICAgLy8gc29tZXRpbWVzIGl0J3MgMCBhZnRlciBzb21lIGVycmF0aWMgcGFuaW5nXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gZHVyYXRpb24gKyBub3c7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWEucHVzaChbdGltZSwgcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMiAmJiB0aW1lIC0gaW5lcnRpYVswXVswXSA+IDEwMCkgaW5lcnRpYS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmVydGlhID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcG9zID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3Jlc2l6ZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleWRvd24oZXYpIHtcbiAgICAgICAgaWYgKGJveHpvb20gJiYgZXYua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ2JveHpvb21jYW5jZWwnKTtcbiAgICAgICAgICAgIGJveHpvb20gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ2tleWRvd24nLCBldik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlKHBvaW50KSB7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ3JvdGF0ZScsIHtcbiAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RQb3MsXG4gICAgICAgICAgICAgICAgcHJldjogcG9zLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHBvaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG91YmxlY2xpY2socG9pbnQpIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnZGJsY2xpY2snLCB7cG9pbnQ6IHBvaW50fSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25tb3VzZWRvd24oZXYpIHtcbiAgICAgICAgZmlyc3RQb3MgPSBwb3MgPSBtb3VzZVBvcyhldik7XG4gICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ2Rvd24nKTtcbiAgICAgICAgaWYgKGV2LnNoaWZ0S2V5IHx8ICgoZXYud2hpY2ggPT09IDEpICYmIChldi5idXR0b24gPT09IDEpKSkge1xuICAgICAgICAgIGJveHpvb20gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25tb3VzZXVwKGV2KSB7XG4gICAgICAgIHBhbm5lZCA9IHBvcyAmJiBmaXJzdFBvcyAmJiAocG9zLnggIT09IGZpcnN0UG9zLnggfHwgcG9zLnkgIT09IGZpcnN0UG9zLnkpO1xuXG4gICAgICAgIHJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHBvcyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGJveHpvb20pIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmZpcmUoJ2JveHpvb21lbmQnLCB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0UG9zLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IG1vdXNlUG9zKGV2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib3h6b29tID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpbmVydGlhICYmIGluZXJ0aWEubGVuZ3RoID49IDIgJiYgbm93ID4gRGF0ZS5ub3coKSAtIDEwMCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBpbmVydGlhW2luZXJ0aWEubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBpbmVydGlhWzBdLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gbGFzdFsxXS5zdWIoZmlyc3RbMV0pLmRpdihsYXN0WzBdIC0gZmlyc3RbMF0pO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgncGFuZW5kJywge2luZXJ0aWE6IHZlbG9jaXR5fSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5maXJlKCdwYW5lbmQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZXJ0aWEgPSBudWxsO1xuICAgICAgICBub3cgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ubW91c2Vtb3ZlKGV2KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG1vdXNlUG9zKGV2KTtcblxuICAgICAgICBpZiAoYm94em9vbSkge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uZmlyZSgnYm94em9vbXN0YXJ0Jywge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFBvcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBwb2ludFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyb3RhdGluZykge1xuICAgICAgICAgICAgcm90YXRlKHBvaW50KTtcblxuICAgICAgICB9IGVsc2UgaWYgKHBvcykge1xuICAgICAgICAgICAgcGFuKHBvaW50KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRvRWxlbWVudCB8fCBldi50YXJnZXQ7XG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gZWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUpIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmUocG9pbnQsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uY2xpY2soZXYpIHtcbiAgICAgICAgaWYgKCFwYW5uZWQpIGNsaWNrKG1vdXNlUG9zKGV2KSwgZXYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uZG91YmxlY2xpY2soZXYpIHtcbiAgICAgICAgZG91YmxlY2xpY2sobW91c2VQb3MoZXYpKTtcbiAgICAgICAgem9vbSgnd2hlZWwnLCBJbmZpbml0eSAqIChldi5zaGlmdEtleSA/IC0xIDogMSksIG1vdXNlUG9zKGV2KSk7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsd2hlZWwoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZpcmVmb3ggPSAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHZhciBzYWZhcmkgPSAvU2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL0Nocm9tKGl1bXxlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIHZhciB0aW1lID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IERhdGU7XG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB3aGVlbCwgZmFsc2UpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgbW91c2V3aGVlbCwgZmFsc2UpO1xuXG4gICAgICAgIHZhciBsYXN0RXZlbnQgPSAwO1xuXG4gICAgICAgIHZhciB0eXBlID0gbnVsbDtcbiAgICAgICAgdmFyIHR5cGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgZnVuY3Rpb24gc2Nyb2xsKHZhbHVlLCBldikge1xuICAgICAgICAgICAgdmFyIHN0YW1wID0gdGltZS5ub3coKTtcbiAgICAgICAgICAgIHZhciB0aW1lRGVsdGEgPSBzdGFtcCAtIGxhc3RFdmVudDtcbiAgICAgICAgICAgIGxhc3RFdmVudCA9IHN0YW1wO1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBtb3VzZVBvcyhldik7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiAodmFsdWUgJSA0LjAwMDI0NDE0MDYyNSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICAgICAgICAgICAgdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRoaXMgdmFsdWUgdG8gbWF0Y2ggdHJhY2twYWQuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gNCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwICYmIE1hdGguYWJzKHZhbHVlKSA8IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgdHJhY2twYWQgZXZlbnQgYmVjYXVzZSBpdCBpcyBzbyBzbWFsbC5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RyYWNrcGFkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZURlbHRhID4gNDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgICAgICAgICAgICB0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBhIHRpbWVvdXQgaW4gY2FzZSB0aGlzIHdhcyBhIHNpbmd1bGFyIGV2ZW50LCBhbmQgZGVseSBpdFxuICAgICAgICAgICAgICAgIC8vIGJ5IHVwIHRvIDQwbXMuXG4gICAgICAgICAgICAgICAgdHlwZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3doZWVsJztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHlwZSwgLWluaXRpYWxWYWx1ZSwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIH0sIDQwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXBlYXRpbmcgZXZlbnQsIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSB0eXBlIG9mIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8ganVzdCB5ZXQuIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYVxuICAgICAgICAgICAgICAgIC8vIGZhc3QgdHJhY2twYWQ7IG90aGVyd2lzZSB3ZSBzd2l0Y2ggaW50byB3aGVlbCBtb2RlLlxuICAgICAgICAgICAgICAgIHR5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIG91ciBkZWxheWVkIGV2ZW50IGlzbid0IGZpcmVkIGFnYWluLCBiZWNhdXNlIHdlXG4gICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSB0aGUgcHJldmlvdXMgZXZlbnQgKHdoaWNoIHdhcyBsZXNzIHRoYW4gNDBtcyBhZ28pIGludG9cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGV2ZW50LlxuICAgICAgICAgICAgICAgIGlmICh0eXBlVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodHlwZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0eXBlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNsb3cgZG93biB6b29tIGlmIHNoaWZ0IGtleSBpcyBoZWxkIGZvciBtb3JlIHByZWNpc2Ugem9vbWluZ1xuICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5ICYmIHZhbHVlKSB2YWx1ZSA9IHZhbHVlIC8gNDtcblxuICAgICAgICAgICAgLy8gT25seSBmaXJlIHRoZSBjYWxsYmFjayBpZiB3ZSBhY3R1YWxseSBrbm93IHdoYXQgdHlwZSBvZiBzY3JvbGxpbmdcbiAgICAgICAgICAgIC8vIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0eXBlLCAtdmFsdWUsIHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHdoZWVsKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVkgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSBkZWx0YVkgLz0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgaWYgKGUuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkgZGVsdGFZICo9IDQwO1xuICAgICAgICAgICAgc2Nyb2xsKGRlbHRhWSwgZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3VzZXdoZWVsKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVkgPSAtZS53aGVlbERlbHRhWTtcbiAgICAgICAgICAgIGlmIChzYWZhcmkpIGRlbHRhWSA9IGRlbHRhWSAvIDM7XG4gICAgICAgICAgICBzY3JvbGwoZGVsdGFZLCBlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuSW50ZXJhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudGVkKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbnZhcyA9IHJlcXVpcmUoJy4uL3V0aWwvY2FudmFzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vdXRpbC9kb20nKTtcblxudmFyIFN0eWxlID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGUnKTtcbnZhciBBbmltYXRpb25Mb29wID0gcmVxdWlyZSgnLi4vc3R5bGUvYW5pbWF0aW9uX2xvb3AnKTtcbnZhciBHTFBhaW50ZXIgPSByZXF1aXJlKCcuLi9yZW5kZXIvcGFpbnRlcicpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vZ2VvL3RyYW5zZm9ybScpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBIYW5kbGVycyA9IHJlcXVpcmUoJy4vaGFuZGxlcnMnKTtcbnZhciBFYXNpbmdzID0gcmVxdWlyZSgnLi9lYXNpbmdzJyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdF9sbmcnKTtcbnZhciBMYXRMbmdCb3VuZHMgPSByZXF1aXJlKCcuLi9nZW8vbGF0X2xuZ19ib3VuZHMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL2NvbnRyb2wvYXR0cmlidXRpb24nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGluc3RhbmNlLlxuICogQGNsYXNzIE1hcFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmNvbnRhaW5lciBIVE1MIGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSB0aGUgbWFwIGluIChvciBlbGVtZW50IGlkIGFzIHN0cmluZylcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5ab29tPTBdIE1pbmltdW0gem9vbSBvZiB0aGUgbWFwXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Wm9vbT0yMF0gTWF4aW11bSB6b29tIG9mIHRoZSBtYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnN0eWxlIE1hcCBzdHlsZSBhbmQgZGF0YSBzb3VyY2UgZGVmaW5pdGlvbiAoZWl0aGVyIGEgSlNPTiBvYmplY3Qgb3IgYSBKU09OIFVSTCksIGRlc2NyaWJlZCBpbiB0aGUgW3N0eWxlIHJlZmVyZW5jZV0oaHR0cHM6Ly9tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaGFzaD1mYWxzZV0gSWYgYHRydWVgLCB0aGUgbWFwIHdpbGwgdHJhY2sgYW5kIHVwZGF0ZSB0aGUgcGFnZSBVUkwgYWNjb3JkaW5nIHRvIG1hcCBwb3NpdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbnRlcmFjdGl2ZT10cnVlXSBJZiBgZmFsc2VgLCBubyBtb3VzZSwgdG91Y2gsIG9yIGtleWJvYXJkIGxpc3RlbmVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIG1hcCwgc28gaXQgd2lsbCBub3QgcmVzcG9uZCB0byBpbnB1dFxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5jbGFzc2VzIFN0eWxlIGNsYXNzIG5hbWVzIHdpdGggd2hpY2ggdG8gaW5pdGlhbGl6ZSB0aGUgbWFwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ9ZmFsc2VdIElmIGB0cnVlYCwgbWFwIGNyZWF0aW9uIHdpbGwgZmFpbCBpZiB0aGUgaW1wbGVtZW50YXRpb24gZGV0ZXJtaW5lcyB0aGF0IHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgY3JlYXRlZCBXZWJHTCBjb250ZXh0IHdvdWxkIGJlIGRyYW1hdGljYWxseSBsb3dlciB0aGFuIGV4cGVjdGVkLlxuICogQGV4YW1wbGVcbiAqIHZhciBtYXAgPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAqICAgY29udGFpbmVyOiAnbWFwJyxcbiAqICAgY2VudGVyOiBbMzcuNzcyNTM3LCAtMTIyLjQyMDY3OV0sXG4gKiAgIHpvb206IDEzLFxuICogICBzdHlsZTogc3R5bGVfb2JqZWN0LFxuICogICBoYXNoOiB0cnVlXG4gKiB9KTtcbiAqL1xudmFyIE1hcCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHV0aWwuaW5oZXJpdCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHZhciBiID0gTGF0TG5nQm91bmRzLmNvbnZlcnQob3B0aW9ucy5tYXhCb3VuZHMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtiLmdldFNvdXRoKCksIGIuZ2V0Tm9ydGgoKV07XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW2IuZ2V0V2VzdCgpLCBiLmdldEVhc3QoKV07XG4gICAgfVxuXG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ19mb3J3YXJkU3R5bGVFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFNvdXJjZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkTGF5ZXJFdmVudCcsXG4gICAgICAgICdfZm9yd2FyZFRpbGVFdmVudCcsXG4gICAgICAgICdfb25TdHlsZUxvYWQnLFxuICAgICAgICAnX29uU3R5bGVDaGFuZ2UnLFxuICAgICAgICAnX29uU291cmNlQWRkJyxcbiAgICAgICAgJ19vblNvdXJjZVJlbW92ZScsXG4gICAgICAgICdfb25Tb3VyY2VVcGRhdGUnLFxuICAgICAgICAndXBkYXRlJyxcbiAgICAgICAgJ3JlbmRlcidcbiAgICBdLCB0aGlzKTtcblxuICAgIHRoaXMuX3NldHVwQ29udGFpbmVyKCk7XG4gICAgdGhpcy5fc2V0dXBDb250cm9sUG9zKCk7XG4gICAgdGhpcy5fc2V0dXBQYWludGVyKCk7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0gb3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBuZXcgSGFuZGxlcnModGhpcyk7XG5cbiAgICB0aGlzLl9oYXNoID0gb3B0aW9ucy5oYXNoICYmIChuZXcgSGFzaCgpKS5hZGRUbyh0aGlzKTtcbiAgICAvLyBkb24ndCBzZXQgcG9zaXRpb24gZnJvbSBvcHRpb25zIGlmIHNldCB0aHJvdWdoIGhhc2hcbiAgICBpZiAoIXRoaXMuX2hhc2ggfHwgIXRoaXMuX2hhc2guX29uSGFzaENoYW5nZSgpKSB7XG4gICAgICAgIHRoaXMuc2V0VmlldyhvcHRpb25zLmNlbnRlciwgb3B0aW9ucy56b29tLCBvcHRpb25zLmJlYXJpbmcsIG9wdGlvbnMucGl0Y2gpO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgdGhpcy5fY2xhc3NlcyA9IHt9O1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHRoaXMuc2V0Q2xhc3NlcyhvcHRpb25zLmNsYXNzZXMpO1xuICAgIGlmIChvcHRpb25zLnN0eWxlKSB0aGlzLnNldFN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkgdGhpcy5hZGRDb250cm9sKG5ldyBBdHRyaWJ1dGlvbigpKTtcbn07XG5cbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIEV2ZW50ZWQpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgRWFzaW5ncyk7XG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgICB6b29tOiAwLFxuICAgICAgICBiZWFyaW5nOiAwLFxuICAgICAgICBwaXRjaDogMCxcblxuICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICBtYXhab29tOiAyMCxcblxuICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgaGFzaDogZmFsc2UsXG5cbiAgICAgICAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlLFxuXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhbHNlXG4gICAgfSxcblxuICAgIGFkZENvbnRyb2w6IGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5hZGRUbyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNlbnRlciBMYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChwYXNzZWQgYXMgYFtsYXQsIGxuZ11gKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIE1hcCB6b29tIGxldmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgTWFwIHJvdGF0aW9uIGJlYXJpbmcgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoIFRoZSBhbmdsZSBhdCB3aGljaCB0aGUgY2FtZXJhIGlzIGxvb2tpbmcgYXQgdGhlIGdyb3VuZFxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFZpZXc6IGZ1bmN0aW9uKGNlbnRlciwgem9vbSwgYmVhcmluZywgcGl0Y2gpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRyLnpvb20gIT09ICt6b29tLFxuICAgICAgICAgICAgYmVhcmluZ0NoYW5nZWQgPSB0ci5iZWFyaW5nICE9PSArYmVhcmluZyxcbiAgICAgICAgICAgIHBpdGNoQ2hhbmdlZCA9IHRyLnBpdGNoICE9PSArcGl0Y2g7XG5cbiAgICAgICAgdHIuY2VudGVyID0gTGF0TG5nLmNvbnZlcnQoY2VudGVyKTtcbiAgICAgICAgdHIuem9vbSA9ICt6b29tO1xuICAgICAgICB0ci5iZWFyaW5nID0gK2JlYXJpbmc7XG4gICAgICAgIHRyLnBpdGNoID0gK3BpdGNoO1xuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAuZmlyZSgnbW92ZXN0YXJ0JylcbiAgICAgICAgICAgIC5fbW92ZSh6b29tQ2hhbmdlZCwgYmVhcmluZ0NoYW5nZWQsIHBpdGNoQ2hhbmdlZClcbiAgICAgICAgICAgIC5maXJlKCdtb3ZlZW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtYXAgbG9jYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNlbnRlciBMYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIChwYXNzZWQgYXMgYFtsYXQsIGxuZ11gKVxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldENlbnRlcjogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICAgIHRoaXMuc2V0VmlldyhjZW50ZXIsIHRoaXMuZ2V0Wm9vbSgpLCB0aGlzLmdldEJlYXJpbmcoKSwgdGhpcy5nZXRQaXRjaCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCB6b29tXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBNYXAgem9vbSBsZXZlbFxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFpvb206IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3KHRoaXMuZ2V0Q2VudGVyKCksIHpvb20sIHRoaXMuZ2V0QmVhcmluZygpLCB0aGlzLmdldFBpdGNoKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWFwIHJvdGF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBNYXAgcm90YXRpb24gYmVhcmluZyBpbiBkZWdyZWVzIGNvdW50ZXItY2xvY2t3aXNlIGZyb20gbm9ydGhcbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRCZWFyaW5nOiBmdW5jdGlvbihiZWFyaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB0aGlzLmdldFpvb20oKSwgYmVhcmluZywgdGhpcy5nZXRQaXRjaCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1hcCBhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoIFRoZSBhbmdsZSBhdCB3aGljaCB0aGUgY2FtZXJhIGlzIGxvb2tpbmcgYXQgdGhlIGdyb3VuZFxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFBpdGNoOiBmdW5jdGlvbihwaXRjaCkge1xuICAgICAgICB0aGlzLnNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSwgdGhpcy5nZXRab29tKCksIHRoaXMuZ2V0QmVhcmluZygpLCBwaXRjaCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB2aWV3IGdlb2dyYXBoaWNhbCBwb2ludFxuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmNlbnRlcjsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB6b29tXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnpvb207IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgYmVhcmluZyBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRCZWFyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmJlYXJpbmc7IH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UGl0Y2g6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl0Y2g7IH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBbc3R5bGVPcHRpb25zXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3N0eWxlT3B0aW9ucy50cmFuc2l0aW9uPXRydWVdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgY2xhc3MgdG8gYSBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrbGFzcyBuYW1lIG9mIHN0eWxlIGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHlsZU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAZmlyZXMgY2hhbmdlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGtsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc2VzW2tsYXNzXSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9jbGFzc2VzW2tsYXNzXSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3R5bGUgY2xhc3MgZnJvbSBhIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIG5hbWUgb2Ygc3R5bGUgY2xhc3NcbiAgICAgKiBAcGFyYW0ge3N0eWxlT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oa2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jbGFzc2VzW2tsYXNzXSkgcmV0dXJuO1xuICAgICAgICBkZWxldGUgdGhpcy5fY2xhc3Nlc1trbGFzc107XG4gICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBtb3JlIHRoYW4gb25lIGNsYXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGtsYXNzZXMgQW4gYXJyYXkgb2YgY2xhc3MgbmFtZXNcbiAgICAgKiBAcGFyYW0ge3N0eWxlT3B0aW9uc30gb3B0aW9uc1xuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRDbGFzc2VzOiBmdW5jdGlvbihrbGFzc2VzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NsYXNzZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc2VzW2tsYXNzZXNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIHN0eWxlIGNsYXNzIGlzIGFjdGl2ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIE5hbWUgb2Ygc3R5bGUgY2xhc3NcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oa2xhc3MpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fY2xhc3Nlc1trbGFzc107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBhY3RpdmUgc3R5bGUgY2xhc3Nlc1xuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jbGFzc2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IHRoZSBtYXAncyBuZXcgd2lkdGggYW5kIGhlaWdodCBhbmQgcmVzaXplIGl0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMCwgaGVpZ2h0ID0gMDtcblxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCA0MDA7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0IHx8IDMwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5fY29uc3RyYWluKCk7XG5cbiAgICAgICAgdGhpcy5wYWludGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgLmZpcmUoJ21vdmVzdGFydCcpXG4gICAgICAgICAgICAuX21vdmUoKVxuICAgICAgICAgICAgLmZpcmUoJ3Jlc2l6ZScpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZWVuZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1hcCdzIGdlb2dyYXBoaWNhbCBib3VuZHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtMYXRMbmdCb3VuZHN9XG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXRMbmdCb3VuZHMoXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCAwKSksXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHRoaXMudHJhbnNmb3JtLnNpemUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBpeGVsIGNvb3JkaW5hdGVzIChyZWxhdGl2ZSB0byBtYXAgY29udGFpbmVyKSBnaXZlbiBhIGdlb2dyYXBoaWNhbCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYXRMbmd9IGxhdGxuZ1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgcHJvamVjdDogZnVuY3Rpb24obGF0bG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhdGlvblBvaW50KExhdExuZy5jb252ZXJ0KGxhdGxuZykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIGdpdmVuIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBvaW50IFt4LCB5XSBwaXhlbCBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHtMYXRMbmd9XG4gICAgICovXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihQb2ludC5jb252ZXJ0KHBvaW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgZmVhdHVyZXMgYXQgYSBwb2ludCAoW3gsIHldKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwb2ludCBbeCwgeV0gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMucmFkaXVzPTBdIE9wdGlvbmFsLiBSYWRpdXMgaW4gcGl4ZWxzIHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubGF5ZXIgT3B0aW9uYWwuIE9ubHkgcmV0dXJuIGZlYXR1cmVzIGZyb20gYSBnaXZlbiBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudHlwZSBPcHRpb25hbC4gRWl0aGVyIGByYXN0ZXJgIG9yIGB2ZWN0b3JgXG4gICAgICogQHBhcmFtIHtmZWF0dXJlc0F0Q2FsbGJhY2t9IGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEBjYWxsYmFjayBmZWF0dXJlc0F0Q2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSBlcnIgRXJyb3IgX0lmIGFueV9cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyBEaXNwbGF5cyBhIEpTT04gYXJyYXkgb2YgZmVhdHVyZXMgZ2l2ZW4gdGhlIHBhc3NlZCBwYXJhbWV0ZXJzIG9mIGBmZWF0dXJlc0F0YFxuICAgICAqXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgZmVhdHVyZXNBdDogZnVuY3Rpb24ocG9pbnQsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvb3JkID0gdGhpcy50cmFuc2Zvcm0ucG9pbnRDb29yZGluYXRlKFBvaW50LmNvbnZlcnQocG9pbnQpKTtcbiAgICAgICAgdGhpcy5zdHlsZS5mZWF0dXJlc0F0KGNvb3JkLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBtYXAncyBzdHlsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBBIHN0eWxlIG9iamVjdCBmb3JtYXR0ZWQgYXMgSlNPTlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZVxuICAgICAgICAgICAgICAgIC5vZmYoJ2xvYWQnLCB0aGlzLl9vblN0eWxlTG9hZClcbiAgICAgICAgICAgICAgICAub2ZmKCdlcnJvcicsIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmFkZCcsIHRoaXMuX29uU291cmNlQWRkKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5yZW1vdmUnLCB0aGlzLl9vblNvdXJjZVJlbW92ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UubG9hZCcsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5lcnJvcicsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UuY2hhbmdlJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZignbGF5ZXIuYWRkJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZignbGF5ZXIucmVtb3ZlJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLmxvYWQnLCB0aGlzLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgICAgICAuX3JlbW92ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLm9mZigncm90YXRlJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG4gICAgICAgICAgICB0aGlzLm9mZigncGl0Y2gnLCB0aGlzLnN0eWxlLl9yZWRvUGxhY2VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGUgaW5zdGFuY2VvZiBTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShzdHlsZSwgdGhpcy5hbmltYXRpb25Mb29wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGVcbiAgICAgICAgICAgIC5vbignbG9hZCcsIHRoaXMuX29uU3R5bGVMb2FkKVxuICAgICAgICAgICAgLm9uKCdlcnJvcicsIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCdjaGFuZ2UnLCB0aGlzLl9vblN0eWxlQ2hhbmdlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UuYWRkJywgdGhpcy5fb25Tb3VyY2VBZGQpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5yZW1vdmUnLCB0aGlzLl9vblNvdXJjZVJlbW92ZSlcbiAgICAgICAgICAgIC5vbignc291cmNlLmxvYWQnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgIC5vbignc291cmNlLmVycm9yJywgdGhpcy5fZm9yd2FyZFNvdXJjZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UuY2hhbmdlJywgdGhpcy5fb25Tb3VyY2VVcGRhdGUpXG4gICAgICAgICAgICAub24oJ2xheWVyLmFkZCcsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCdsYXllci5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUubG9hZCcsIHRoaXMudXBkYXRlKVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5vbigncm90YXRlJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG4gICAgICAgIHRoaXMub24oJ3BpdGNoJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNvdXJjZSB0byB0aGUgbWFwIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBzb3VyY2UuIE11c3Qgbm90IGJlIHVzZWQgYnkgYW55IGV4aXN0aW5nIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIHNvdXJjZSBzcGVjaWZpY2F0aW9uLCBmb2xsb3dpbmcgdGhlXG4gICAgICogW01hcGJveCBHTCBTdHlsZSBSZWZlcmVuY2VdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3NvdXJjZXMpXG4gICAgICogQGZpcmVzIHNvdXJjZS5hZGRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5hZGRTb3VyY2UoaWQsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXhpc3Rpbmcgc291cmNlIGZyb20gdGhlIG1hcCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgc291cmNlIHRvIHJlbW92ZVxuICAgICAqIEBmaXJlcyBzb3VyY2UucmVtb3ZlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlU291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZVNvdXJjZShpZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0eWxlIHNvdXJjZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGlkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBzb3VyY2UgSURcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0U291cmNlKGlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIG1hcCBzdHlsZS4gVGhlIGxheWVyIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBsYXllciB3aXRoXG4gICAgICogSUQgYGJlZm9yZWAsIG9yIGFwcGVuZGVkIGlmIGBiZWZvcmVgIGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtMYXllcn0gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJlZm9yZSAgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IGJlZm9yZVxuICAgICAqIEBmaXJlcyBsYXllci5hZGRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIsIGJlZm9yZSkge1xuICAgICAgICB0aGlzLnN0eWxlLmFkZExheWVyKGxheWVyLCBiZWZvcmUpO1xuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBsYXllciB3aXRoIHRoZSBnaXZlbiBgaWRgIGZyb20gdGhlIG1hcC4gQW55IGxheWVycyB3aGljaCByZWZlciB0byB0aGVcbiAgICAgKiBzcGVjaWZpZWQgbGF5ZXIgdmlhIGEgYHJlZmAgcHJvcGVydHkgYXJlIGFsc28gcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBmaXJlcyBsYXllci5yZW1vdmVcbiAgICAgKiBAcmV0dXJucyB7TWFwfSB0aGlzXG4gICAgICovXG4gICAgcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlTGF5ZXIoaWQpO1xuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmaWx0ZXIgZm9yIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlciBmaWx0ZXIgc3BlY2lmaWNhdGlvbiwgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2ZpbHRlcilcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRGaWx0ZXIobGF5ZXIsIGZpbHRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbHRlciBmb3IgYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHJldHVybnMge0FycmF5fSBmaWx0ZXIgc3BlY2lmaWNhdGlvbiwgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2ZpbHRlcilcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldEZpbHRlcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYSBwYWludCBwcm9wZXJ0eSBpbiBhIGdpdmVuIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIElEIG9mIGEgbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGEgcGFpbnQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIGZvciB0aGUgcGFpbnQgcHJvcGVyeTsgbXVzdCBoYXZlIHRoZSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHkgYXMgZGVmaW5lZCBpbiB0aGUgW1N0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0ga2xhc3Mgb3B0aW9uYWwgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwgdmFsdWUsIGtsYXNzKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0UGFpbnRQcm9wZXJ0eShsYXllciwgbmFtZSwgdmFsdWUsIGtsYXNzKTtcbiAgICAgICAgdGhpcy5zdHlsZS5fY2FzY2FkZSh0aGlzLl9jbGFzc2VzKTtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgcGFpbnQgcHJvcGVydHkgaW4gYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBhIHBhaW50IHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBrbGFzcyBvcHRpb25hbCBjbGFzcyBzcGVjaWZpZXIgZm9yIHRoZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIHsqfSB2YWx1ZSBmb3IgdGhlIHBhaW50IHByb3BlcnlcbiAgICAgKi9cbiAgICBnZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwga2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0UGFpbnRQcm9wZXJ0eShsYXllciwgbmFtZSwga2xhc3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgbGF5b3V0IHByb3BlcnR5IGluIGEgZ2l2ZW4gc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgSUQgb2YgYSBsYXllclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgYSBsYXlvdXQgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIHZhbHVlIGZvciB0aGUgbGF5b3V0IHByb3Blcnk7IG11c3QgaGF2ZSB0aGUgdHlwZSBhcHByb3ByaWF0ZSBmb3IgdGhlIHByb3BlcnR5IGFzIGRlZmluZWQgaW4gdGhlIFtTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLylcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBsYXlvdXQgcHJvcGVydHkgaW4gYSBnaXZlbiBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBJRCBvZiBhIGxheWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBhIGxheW91dCBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0ga2xhc3Mgb3B0aW9uYWwgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7Kn0gdmFsdWUgZm9yIHRoZSBsYXlvdXQgcHJvcGVyeVxuICAgICAqL1xuICAgIGdldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRMYXlvdXRQcm9wZXJ0eShsYXllciwgbmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgTWFwJ3MgY29udGFpbmVyIGFzIGFuIEhUTUwgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAgICovXG4gICAgZ2V0Q29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBNYXAncyBjYW52YXMgYXMgYW4gSFRNTCBjYW52YXNcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IGNhbnZhc1xuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0RWxlbWVudCgpO1xuICAgIH0sXG5cbiAgICBfbW92ZTogZnVuY3Rpb24oem9vbSwgcm90YXRlLCBwaXRjaCkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlKHpvb20pLmZpcmUoJ21vdmUnKTtcblxuICAgICAgICBpZiAoem9vbSkgdGhpcy5maXJlKCd6b29tJyk7XG4gICAgICAgIGlmIChyb3RhdGUpIHRoaXMuZmlyZSgncm90YXRlJyk7XG4gICAgICAgIGlmIChwaXRjaCkgdGhpcy5maXJlKCdwaXRjaCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBtYXAgc2V0dXAgY29kZVxuICAgIF9zZXR1cENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gICAgICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1tYXAnKTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLCBjb250YWluZXIpO1xuICAgIH0sXG5cbiAgICBfc2V0dXBDb250cm9sUG9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9O1xuICAgICAgICB2YXIgcHJlZml4ID0gJ21hcGJveGdsLWN0cmwtJztcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ29ybmVyKHBvcykge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHByZWZpeCArIHBvcztcbiAgICAgICAgICAgIGNvcm5lcnNbcG9zXSA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgY29udGFpbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250YWluZXIgJiYgdHlwZW9mIGRvY3VtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY3JlYXRlQ29ybmVyKCd0b3AtbGVmdCcpO1xuICAgICAgICAgICAgY3JlYXRlQ29ybmVyKCd0b3AtcmlnaHQnKTtcbiAgICAgICAgICAgIGNyZWF0ZUNvcm5lcignYm90dG9tLWxlZnQnKTtcbiAgICAgICAgICAgIGNyZWF0ZUNvcm5lcignYm90dG9tLXJpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NldHVwUGFpbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuX2NhbnZhcy5nZXRXZWJHTENvbnRleHQodGhpcy5vcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpO1xuXG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgR0xQYWludGVyKGdsLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIF9jb250ZXh0TG9zdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgICAgICAgIGJyb3dzZXIuY2FuY2VsRnJhbWUodGhpcy5fZnJhbWVJZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbnRleHRSZXN0b3JlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG1hcCBmdWxseSBsb2FkZWQ/IElmIHRoZSBzdHlsZSBpc24ndCBsb2FkZWRcbiAgICAgKiBvciBpdCBoYXMgYSBjaGFuZ2UgdG8gdGhlIHNvdXJjZXMgb3Igc3R5bGUgdGhhdCBpc24ndFxuICAgICAqIHByb3BhZ2F0ZWQgdG8gaXRzIHN0eWxlLCByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbWFwIGlzIGxvYWRlZFxuICAgICAqL1xuICAgIGxvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZURpcnR5IHx8IHRoaXMuX3NvdXJjZXNEaXJ0eSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgIXRoaXMuc3R5bGUubG9hZGVkKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhpcyBtYXAncyBzdHlsZSBhbmQgcmUtcmVuZGVyIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlU3R5bGUgbmV3IHN0eWxlXG4gICAgICogQHJldHVybnMge01hcH0gdGhpc1xuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24odXBkYXRlU3R5bGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gdGhpcy5fc3R5bGVEaXJ0eSB8fCB1cGRhdGVTdHlsZTtcbiAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHdoZW4gYSAocmUtKXJlbmRlciBvZiB0aGUgbWFwIGlzIHJlcXVpcmVkLCBlLmcuIHdoZW4gdGhlXG4gICAgICogdXNlciBwYW5uZWQgb3Igem9vbWVkLGYgb3IgbmV3IGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiB0aGlzLl9zdHlsZURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLl9yZWNhbGN1bGF0ZSh0aGlzLnRyYW5zZm9ybS56b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuX3NvdXJjZXNEaXJ0eSAmJiAhdGhpcy5fc291cmNlc0RpcnR5VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzRGlydHlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2VzRGlydHlUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgNTApO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5fdXBkYXRlU291cmNlcyh0aGlzLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIucmVuZGVyKHRoaXMuc3R5bGUsIHtcbiAgICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLFxuICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICByb3RhdGluZzogdGhpcy5yb3RhdGluZyxcbiAgICAgICAgICAgIHpvb21pbmc6IHRoaXMuem9vbWluZ1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3JlbmRlcicpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCgpICYmICF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb25Mb29wLnN0b3BwZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc291cmNlc0RpcnR5IHx8IHRoaXMuX3JlcGFpbnQgfHwgIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcmVuZGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIG1hcCdzIHVuZGVybHlpbmcgcmVzb3VyY2VzLCBpbmNsdWRpbmcgd2ViIHdvcmtlcnMuXG4gICAgICogQHJldHVybnMge01hcH0gdGhpc1xuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNoKSB0aGlzLl9oYXNoLnJlbW92ZSgpO1xuICAgICAgICBicm93c2VyLmNhbmNlbEZyYW1lKHRoaXMuX2ZyYW1lSWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc291cmNlc0RpcnR5VGltZW91dCk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUobnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiAhdGhpcy5fZnJhbWVJZCkge1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVJZCA9IGJyb3dzZXIuZnJhbWUodGhpcy5yZW5kZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mb3J3YXJkU3R5bGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoJ3N0eWxlLicgKyBlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkU291cmNlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKGUudHlwZSwgdXRpbC5leHRlbmQoe3N0eWxlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRMYXllckV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkVGlsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9vblN0eWxlTG9hZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnN0eWxlLl9jYXNjYWRlKHRoaXMuX2NsYXNzZXMsIHt0cmFuc2l0aW9uOiBmYWxzZX0pO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU3R5bGVDaGFuZ2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25Tb3VyY2VBZGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGUuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLm9uQWRkKVxuICAgICAgICAgICAgc291cmNlLm9uQWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblNvdXJjZVJlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc291cmNlID0gZS5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2Uub25SZW1vdmUpXG4gICAgICAgICAgICBzb3VyY2Uub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU291cmNlVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudChlKTtcbiAgICB9XG59KTtcblxudXRpbC5leHRlbmRBbGwoTWFwLnByb3RvdHlwZSwge1xuXG4gICAgLy8gZGVidWcgY29kZVxuICAgIF9kZWJ1ZzogZmFsc2UsXG4gICAgZ2V0IGRlYnVnKCkgeyByZXR1cm4gdGhpcy5fZGVidWc7IH0sXG4gICAgc2V0IGRlYnVnKHZhbHVlKSB7IHRoaXMuX2RlYnVnID0gdmFsdWU7IHRoaXMudXBkYXRlKCk7IH0sXG5cbiAgICAvLyBzaG93IGNvbGxpc2lvbiBib3hlc1xuICAgIF9jb2xsaXNpb25EZWJ1ZzogZmFsc2UsXG4gICAgZ2V0IGNvbGxpc2lvbkRlYnVnKCkgeyByZXR1cm4gdGhpcy5fY29sbGlzaW9uRGVidWc7IH0sXG4gICAgc2V0IGNvbGxpc2lvbkRlYnVnKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbGxpc2lvbkRlYnVnID0gdmFsdWU7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5zdHlsZS5zb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnNvdXJjZXNbaV0ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gY29udGludW91cyByZXBhaW50XG4gICAgX3JlcGFpbnQ6IGZhbHNlLFxuICAgIGdldCByZXBhaW50KCkgeyByZXR1cm4gdGhpcy5fcmVwYWludDsgfSxcbiAgICBzZXQgcmVwYWludCh2YWx1ZSkgeyB0aGlzLl9yZXBhaW50ID0gdmFsdWU7IHRoaXMudXBkYXRlKCk7IH0sXG5cbiAgICAvLyBzaG93IHZlcnRpY2VzXG4gICAgX3ZlcnRpY2VzOiBmYWxzZSxcbiAgICBnZXQgdmVydGljZXMoKSB7IHJldHVybiB0aGlzLl92ZXJ0aWNlczsgfSxcbiAgICBzZXQgdmVydGljZXModmFsdWUpIHsgdGhpcy5fdmVydGljZXMgPSB2YWx1ZTsgdGhpcy51cGRhdGUoKTsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9wdXA7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJyk7XG52YXIgTGF0TG5nID0gcmVxdWlyZSgnLi4vZ2VvL2xhdF9sbmcnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcG9wdXAgY29tcG9uZW50XG4gKiBAY2xhc3MgUG9wdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuY2xvc2VCdXR0b25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jbG9zZU9uQ2xpY2tcbiAqIEBleGFtcGxlXG4gKiB2YXIgdG9vbHRpcCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpXG4gKiAgIC5zZXRMYXRMbmcobWFwLnVucHJvamVjdChlLnBvaW50KSlcbiAqICAgLnNldEhUTUwoXCI8aDE+SGVsbG8gV29ybGQhPC9oMT5cIilcbiAqICAgLmFkZFRvKG1hcCk7XG4gKi9cbmZ1bmN0aW9uIFBvcHVwKG9wdGlvbnMpIHtcbiAgICB1dGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ191cGRhdGVQb3NpdGlvbicsXG4gICAgICAgICdfb25DbGlja0Nsb3NlJ10sXG4gICAgICAgIHRoaXMpO1xufVxuXG5Qb3B1cC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBQb3B1cC5wcm90b3R5cGUgKi97XG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBwb3B1cCB0byBhIG1hcFxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZFRvOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAub24oJ21vdmUnLCB0aGlzLl91cGRhdGVQb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fb25DbGlja0Nsb3NlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHBvcHVwIGZyb20gdGhlIG1hcFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKCkuYWRkVG8obWFwKTtcbiAgICAgKiBwb3B1cC5yZW1vdmUoKTtcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlUG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrQ2xvc2UpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX21hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29vcmRpbmF0ZXMgb2YgcG9wdXAgZWxlbWVudCByZWxhdGl2ZSB0byBtYXBcbiAgICAgKiBAcmV0dXJucyB7TGF0TG5nfVxuICAgICAqL1xuICAgIGdldExhdExuZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRMbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb3B1cCBlbGVtZW50IHRvIGEgbWFwXG4gICAgICogQHBhcmFtIHtMYXRMbmd9IGxhdGxuZ1xuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0TGF0TG5nOiBmdW5jdGlvbihsYXRsbmcpIHtcbiAgICAgICAgdGhpcy5fbGF0TG5nID0gTGF0TG5nLmNvbnZlcnQobGF0bG5nKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIGEgcG9wdXAgZWxlbWVudCB3aXRoIHRleHQgb25seSBjb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICB0aGlzLl91cGRhdGVDb250ZW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWxsIGEgcG9wdXAgZWxlbWVudCB3aXRoIEhUTUwgY29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRIVE1MOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5JyksIGNoaWxkO1xuICAgICAgICB0ZW1wLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVDb250ZW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1wb3B1cCcsIHRoaXMuX21hcC5nZXRDb250YWluZXIoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RpcCAgICAgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtcG9wdXAtdGlwJywgICAgIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLXBvcHVwLWNvbnRlbnQnLCB0aGlzLl9jb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24gPSBET00uY3JlYXRlKCdidXR0b24nLCAnbWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uJywgdGhpcy5fd3JhcHBlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24uaW5uZXJIVE1MID0gJyYjMjE1Oyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrQ2xvc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udGVudCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlQ29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29udGVudCB8fCAhdGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fd3JhcHBlcjtcblxuICAgICAgICB3aGlsZSAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fY2xvc2VCdXR0b24pO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xhdExuZyB8fCAhdGhpcy5fY29udGFpbmVyKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sYXRMbmcpLnJvdW5kKCksXG4gICAgICAgICAgICBhbmNob3IgPSB0aGlzLm9wdGlvbnMuYW5jaG9yO1xuXG4gICAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHBvcy55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gWyd0b3AnXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zLnkgPiB0aGlzLl9tYXAudHJhbnNmb3JtLmhlaWdodCAtIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFsnYm90dG9tJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zLnggPCB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgnbGVmdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MueCA+IHRoaXMuX21hcC50cmFuc2Zvcm0ud2lkdGggLSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IucHVzaCgncmlnaHQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuY2hvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSAnYm90dG9tJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gYW5jaG9yLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3JUcmFuc2xhdGUgPSB7XG4gICAgICAgICAgICAndG9wJzogJ3RyYW5zbGF0ZSgtNTAlLDApJyxcbiAgICAgICAgICAgICd0b3AtbGVmdCc6ICd0cmFuc2xhdGUoMCwwKScsXG4gICAgICAgICAgICAndG9wLXJpZ2h0JzogJ3RyYW5zbGF0ZSgtMTAwJSwwKScsXG4gICAgICAgICAgICAnYm90dG9tJzogJ3RyYW5zbGF0ZSgtNTAlLC0xMDAlKScsXG4gICAgICAgICAgICAnYm90dG9tLWxlZnQnOiAndHJhbnNsYXRlKDAsLTEwMCUpJyxcbiAgICAgICAgICAgICdib3R0b20tcmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC0xMDAlKScsXG4gICAgICAgICAgICAnbGVmdCc6ICd0cmFuc2xhdGUoMCwtNTAlKScsXG4gICAgICAgICAgICAncmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLC01MCUpJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYW5jaG9yVHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1wb3B1cC1hbmNob3ItJyArIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtcG9wdXAtYW5jaG9yLScgKyBhbmNob3IpO1xuXG4gICAgICAgIERPTS5zZXRUcmFuc2Zvcm0odGhpcy5fY29udGFpbmVyLCBhbmNob3JUcmFuc2xhdGVbYW5jaG9yXSArICcgdHJhbnNsYXRlKCcgKyBwb3MueCArICdweCwnICsgcG9zLnkgKyAncHgpJyk7XG4gICAgfSxcblxuICAgIF9vbkNsaWNrQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdG9yO1xuXG5mdW5jdGlvbiBBY3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5jYWxsYmFja0lEID0gMDtcbiAgICB0aGlzLnJlY2VpdmUgPSB0aGlzLnJlY2VpdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5yZWNlaXZlLCBmYWxzZSk7XG59XG5cbkFjdG9yLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHZhciBkYXRhID0gbWVzc2FnZS5kYXRhLFxuICAgICAgICBjYWxsYmFjaztcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICc8cmVzcG9uc2U+Jykge1xuICAgICAgICBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2RhdGEuaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGNhbGxiYWNrKGRhdGEuZXJyb3IgfHwgbnVsbCwgZGF0YS5kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLmlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLnBhcmVudFtkYXRhLnR5cGVdKGRhdGEuZGF0YSwgZnVuY3Rpb24oZXJyLCBkYXRhLCBidWZmZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnPHJlc3BvbnNlPicsXG4gICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpZCksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyciA/IFN0cmluZyhlcnIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9LCBidWZmZXJzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudFtkYXRhLnR5cGVdKGRhdGEuZGF0YSk7XG4gICAgfVxufTtcblxuQWN0b3IucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgYnVmZmVycykge1xuICAgIHZhciBpZCA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrKSB0aGlzLmNhbGxiYWNrc1tpZCA9IHRoaXMuY2FsbGJhY2tJRCsrXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMucG9zdE1lc3NhZ2UoeyB0eXBlOiB0eXBlLCBpZDogU3RyaW5nKGlkKSwgZGF0YTogZGF0YSB9LCBidWZmZXJzKTtcbn07XG5cbkFjdG9yLnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRyYW5zZmVyTGlzdCkge1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyTGlzdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZShtZXNzYWdlKTsgLy8gTm8gc3VwcG9ydCBmb3IgdHJhbnNmZXJMaXN0IG9uIElFXG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5nZXRKU09OID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcbn07XG5cbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXIgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjYWxsYmFjayhlKTtcbiAgICB9O1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB4aHIucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcbn07XG5cbmV4cG9ydHMuZ2V0SW1hZ2UgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgaW1nKTtcbiAgICB9O1xuICAgIGltZy5zcmMgPSB1cmw7XG4gICAgaW1nLmdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5kYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGltZztcbn07XG5cbmV4cG9ydHMuZ2V0VmlkZW8gPSBmdW5jdGlvbih1cmxzLCBjYWxsYmFjaykge1xuICAgIHZhciB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgdmlkZW8uY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICB2aWRlby5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB2aWRlbyk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgICAgcy5zcmMgPSB1cmxzW2ldO1xuICAgICAgICB2aWRlby5hcHBlbmRDaGlsZChzKTtcbiAgICB9XG4gICAgdmlkZW8uZ2V0RGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdmlkZW87IH07XG4gICAgcmV0dXJuIHZpZGVvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbnZhcyA9IHJlcXVpcmUoJy4vY2FudmFzJyk7XG5cbnZhciBmcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcblxuZXhwb3J0cy5mcmFtZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZyYW1lKGZuKTtcbn07XG5cbnZhciBjYW5jZWwgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcblxuZXhwb3J0cy5jYW5jZWxGcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgY2FuY2VsKGlkKTtcbn07XG5cbmV4cG9ydHMudGltZWQgPSBmdW5jdGlvbiAoZm4sIGR1ciwgY3R4KSB7XG4gICAgaWYgKCFkdXIpIHtcbiAgICAgICAgZm4uY2FsbChjdHgsIDEpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYWJvcnQgPSBmYWxzZSxcbiAgICAgICAgc3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuXG4gICAgZnVuY3Rpb24gdGljayhub3cpIHtcbiAgICAgICAgaWYgKGFib3J0KSByZXR1cm47XG4gICAgICAgIGlmICghd2luZG93LnBlcmZvcm1hbmNlKSBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIGlmIChub3cgPj0gc3RhcnQgKyBkdXIpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAobm93IC0gc3RhcnQpIC8gZHVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydCA9IHRydWU7IH07XG59O1xuXG4vKipcbiAqIFRlc3Qgd2hldGhlciB0aGUgYmFzaWMgSmF2YVNjcmlwdCBhbmQgRE9NIGZlYXR1cmVzIHJlcXVpcmVkIGZvciBNYXBib3ggR0wgYXJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0PWZhbHNlXSBJZiBgdHJ1ZWAsIG1hcCBjcmVhdGlvbiB3aWxsIGZhaWwgaWYgdGhlIGltcGxlbWVudGF0aW9uIGRldGVybWluZXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGNyZWF0ZWQgV2ViR0wgY29udGV4dCB3b3VsZCBiZSBkcmFtYXRpY2FsbHkgbG93ZXIgdGhhbiBleHBlY3RlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBNYXBib3ggR0wgc2hvdWxkIGJlIGV4cGVjdGVkIHRvIHdvcmssIGFuZCBmYWxzZSBpZiBub3QuXG4gKi9cbmV4cG9ydHMuc3VwcG9ydGVkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgdmFyIHN1cHBvcnRzID0gW1xuXG4gICAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7IH0sXG5cbiAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnOyB9LFxuXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShBcnJheS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZXZlcnkgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyICYmXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc29tZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiZcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIShGdW5jdGlvbi5wcm90b3R5cGUgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpICYmXG4gICAgICAgICAgICAgICAgISEoT2JqZWN0LmtleXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmlzU2VhbGVkICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5pc0Zyb3plbiAmJlxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZWFsICYmXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAnSlNPTicgaW4gd2luZG93ICYmICdwYXJzZScgaW4gSlNPTiAmJiAnc3RyaW5naWZ5JyBpbiBKU09OO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW52YXMoKS5zdXBwb3J0c1dlYkdMQ29udGV4dCgob3B0aW9ucyAmJiBvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQpIHx8IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuICdXb3JrZXInIGluIHdpbmRvdzsgfVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1cHBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc3VwcG9ydHNbaV0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGV2aWNlUGl4ZWxSYXRpbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG5cbmZ1bmN0aW9uIENhbnZhcyhwYXJlbnQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBpZiAocGFyZW50ICYmIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWNhbnZhcycpO1xuICAgICAgICBpZiAocGFyZW50Lm9wdGlvbnMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWludGVyYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHBhcmVudC5fY29udGV4dExvc3QuYmluZChwYXJlbnQpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgcGFyZW50Ll9jb250ZXh0UmVzdG9yZWQuYmluZChwYXJlbnQpLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICB9XG59XG5cbkNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIC8vIFJlcXVlc3QgdGhlIHJlcXVpcmVkIGNhbnZhcyBzaXplIHRha2luZyB0aGUgcGl4ZWxyYXRpbyBpbnRvIGFjY291bnQuXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxSYXRpbyAqIGhlaWdodDtcblxuICAgIC8vIE1haW50YWluIHRoZSBzYW1lIGNhbnZhcyBzaXplLCBwb3RlbnRpYWxseSBkb3duc2NhbGluZyBpdCBmb3IgSGlEUEkgZGlzcGxheXNcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xufTtcblxuQ2FudmFzLnByb3RvdHlwZS5fY29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBzdGVuY2lsOiB0cnVlLFxuICAgIGRlcHRoOiBmYWxzZVxufTtcblxuQ2FudmFzLnByb3RvdHlwZS5nZXRXZWJHTENvbnRleHQgPSBmdW5jdGlvbihmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB1dGlsLmluaGVyaXQodGhpcy5fY29udGV4dEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcyk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLnN1cHBvcnRzV2ViR0xDb250ZXh0ID0gZnVuY3Rpb24oZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gdXRpbC5pbmhlcml0KHRoaXMuX2NvbnRleHRBdHRyaWJ1dGVzLCB7XG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcbiAgICB9KTtcblxuICAgIGlmICgncHJvYmFibHlTdXBwb3J0c0NvbnRleHQnIGluIHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5wcm9iYWJseVN1cHBvcnRzQ29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICAgICAgdGhpcy5jYW52YXMucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSBpZiAoJ3N1cHBvcnRzQ29udGV4dCcgaW4gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3VwcG9ydHNDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmICEhdGhpcy5nZXRXZWJHTENvbnRleHQoZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCk7XG59O1xuXG5DYW52YXMucHJvdG90eXBlLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWN0b3IgPSByZXF1aXJlKCcuLi9hY3RvcicpO1xuXG52YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xudmFyIHdvcmtlckZpbGUgPSAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCB8fCBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0pLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG52YXIgYWJzb2x1dGUgPSB3b3JrZXJGaWxlLmluZGV4T2YoJ2h0dHAnKSAhPT0gLTE7XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2hlcjtcblxuZnVuY3Rpb24gRGlzcGF0Y2hlcihsZW5ndGgsIHBhcmVudCkge1xuICAgIHRoaXMuYWN0b3JzID0gW107XG4gICAgdGhpcy5jdXJyZW50QWN0b3IgPSAwO1xuXG4gICAgdmFyIHVybCwgYmxvYiwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBkdWUgdG8gY3Jvc3MgZG9tYWluIGlzc3VlcyB3ZSBjYW4ndCBsb2FkIGl0IGRpcmVjdGx5IHdpdGggdGhlIHVybCxcbiAgICAgICAgLy8gc28gY3JlYXRlIGEgYmxvYiBhbmQgb2JqZWN0IHVybCBhbmQgbG9hZCB0aGF0XG4gICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFsnaW1wb3J0U2NyaXB0cyhcIicgKyB3b3JrZXJGaWxlICsgJ1wiKTsnXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pO1xuICAgICAgICAgICAgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSB3b3JrZXJGaWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyB3aW5kb3cuV29ya2VyKHVybCk7XG4gICAgICAgIHZhciBhY3RvciA9IG5ldyBBY3Rvcih3b3JrZXIsIHBhcmVudCk7XG4gICAgICAgIGFjdG9yLm5hbWUgPSBcIldvcmtlciBcIiArIGk7XG4gICAgICAgIHRoaXMuYWN0b3JzLnB1c2goYWN0b3IpO1xuICAgIH1cbn1cblxuRGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XG4gICAgYnJvYWRjYXN0OiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLnNlbmQodHlwZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VuZDogZnVuY3Rpb24odHlwZSwgZGF0YSwgY2FsbGJhY2ssIHRhcmdldElELCBidWZmZXJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SUQgIT09ICdudW1iZXInIHx8IGlzTmFOKHRhcmdldElEKSkge1xuICAgICAgICAgICAgLy8gVXNlIHJvdW5kIHJvYmluIHRvIHNlbmQgcmVxdWVzdHMgdG8gd2ViIHdvcmtlcnMuXG4gICAgICAgICAgICB0YXJnZXRJRCA9IHRoaXMuY3VycmVudEFjdG9yID0gKHRoaXMuY3VycmVudEFjdG9yICsgMSkgJSB0aGlzLmFjdG9ycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdG9yc1t0YXJnZXRJRF0uc2VuZCh0eXBlLCBkYXRhLCBjYWxsYmFjaywgYnVmZmVycyk7XG4gICAgICAgIHJldHVybiB0YXJnZXRJRDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hY3RvcnNbaV0udGFyZ2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0b3JzID0gW107XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmIChjbGFzc05hbWUpIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICBpZiAoY29udGFpbmVyKSBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHJldHVybiBlbDtcbn07XG5cbnZhciBkb2NTdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuZnVuY3Rpb24gdGVzdFByb3AocHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcm9wc1tpXSBpbiBkb2NTdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgc2VsZWN0UHJvcCA9IHRlc3RQcm9wKFsndXNlclNlbGVjdCcsICdNb3pVc2VyU2VsZWN0JywgJ1dlYmtpdFVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pLFxuICAgIHVzZXJTZWxlY3Q7XG5leHBvcnRzLmRpc2FibGVEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIHVzZXJTZWxlY3QgPSBkb2NTdHlsZVtzZWxlY3RQcm9wXTtcbiAgICAgICAgZG9jU3R5bGVbc2VsZWN0UHJvcF0gPSAnbm9uZSc7XG4gICAgfVxufTtcbmV4cG9ydHMuZW5hYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBkb2NTdHlsZVtzZWxlY3RQcm9wXSA9IHVzZXJTZWxlY3Q7XG4gICAgfVxufTtcblxudmFyIHRyYW5zZm9ybVByb3AgPSB0ZXN0UHJvcChbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nXSk7XG5leHBvcnRzLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVsLCB2YWx1ZSkge1xuICAgIGVsLnN0eWxlW3RyYW5zZm9ybVByb3BdID0gdmFsdWU7XG59O1xuXG4vLyBTdXBwcmVzcyB0aGUgbmV4dCBjbGljaywgYnV0IG9ubHkgaWYgaXQncyBpbW1lZGlhdGUuXG5mdW5jdGlvbiBzdXBwcmVzc0NsaWNrKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdXBwcmVzc0NsaWNrLCB0cnVlKTtcbn1cbmV4cG9ydHMuc3VwcHJlc3NDbGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHN1cHByZXNzQ2xpY2ssIHRydWUpO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdXBwcmVzc0NsaWNrLCB0cnVlKTtcbiAgICB9LCAwKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEhUVFBfVVJMOiAnaHR0cDovL2EudGlsZXMubWFwYm94LmNvbScsXG4gICAgSFRUUFNfVVJMOiAnaHR0cHM6Ly9hLnRpbGVzLm1hcGJveC5jb20nLFxuICAgIEZPUkNFX0hUVFBTOiB0cnVlLFxuICAgIFJFUVVJUkVfQUNDRVNTX1RPS0VOOiB0cnVlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIE1ldGhvZHMgbWl4ZWQgaW4gdG8gb3RoZXIgY2xhc3NlcyBmb3IgZXZlbnQgY2FwYWJpbGl0aWVzLlxuICogQG1peGluIEV2ZW50ZWRcbiAqL1xudmFyIEV2ZW50ZWQgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYSBzcGVjaWZpZWQgZXZlbnQgd2l0aCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRoZSBsYXR0ZXIgZ2V0cyB0aGUgZGF0YSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIGBmaXJlYCBhbmQgYWRkaXRpb25hbGx5IGB0YXJnZXRgIGFuZCBgdHlwZWAgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2goZm4pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBldmVudCBsaXN0ZW5lclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBFdmVudCB0eXBlLiBJZiBub25lIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGlzdGVuZXJdIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQgYWxsIGxpc3RlbmVycyBhcmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24odHlwZSwgZm4pIHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBhbGwgbGlzdGVuZXJzIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5zKHR5cGUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLl9ldmVudHNbdHlwZV0uaW5kZXhPZihmbik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGEgZnVuY3Rpb24gb25jZSB3aGVuIGFuIGV2ZW50IGhhcyBmaXJlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB3aGVuIHRoZSBldmVudCBpcyBmaXJlZFxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5vZmYodHlwZSwgd3JhcHBlcik7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlIGV2ZW50IG9mIGEgZ2l2ZW4gc3RyaW5nIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBPcHRpb25hbCBkYXRhIHBhc3NlZCBkb3duIHRvIHRoZSBldmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgbGlzdGVucyB0byBhbiBldmVudCBvZiBhIHBhcnRpY3VsYXIgdHlwZVxuICAgICAqL1xuICAgIGZpcmU6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAgIHV0aWwuZXh0ZW5kKGRhdGEsIHt0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXN9KTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgYWRkaW5nL3JlbW92aW5nIGxpc3RlbmVycyBpbnNpZGUgb3RoZXIgbGlzdGVuZXJzIHdvbid0IGNhdXNlIGluZmluaXRlIGxvb3BcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBpcyByZWdpc3RlcmVkIHRvIGEgdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9mIGEgcGFydGljdWxhciB0eXBlXG4gICAgICovXG4gICAgbGlzdGVuczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBocztcblxuZnVuY3Rpb24gR2x5cGhzKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5zdGFja3MgPSBwYmYucmVhZEZpZWxkcyhyZWFkRm9udHN0YWNrcywgW10sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGb250c3RhY2tzKHRhZywgc3RhY2tzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSB7XG4gICAgICAgIHZhciBmb250c3RhY2sgPSBwYmYucmVhZE1lc3NhZ2UocmVhZEZvbnRzdGFjaywge2dseXBoczoge319KTtcbiAgICAgICAgc3RhY2tzLnB1c2goZm9udHN0YWNrKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRGb250c3RhY2sodGFnLCBmb250c3RhY2ssIHBiZikge1xuICAgIGlmICh0YWcgPT09IDEpIGZvbnRzdGFjay5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGZvbnRzdGFjay5yYW5nZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHBiZi5yZWFkTWVzc2FnZShyZWFkR2x5cGgsIHt9KTtcbiAgICAgICAgZm9udHN0YWNrLmdseXBoc1tnbHlwaC5pZF0gPSBnbHlwaDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRHbHlwaCh0YWcsIGdseXBoLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSBnbHlwaC5pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBnbHlwaC5iaXRtYXAgPSBwYmYucmVhZEJ5dGVzKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSBnbHlwaC53aWR0aCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA0KSBnbHlwaC5oZWlnaHQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNSkgZ2x5cGgubGVmdCA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNikgZ2x5cGgudG9wID0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA3KSBnbHlwaC5hZHZhbmNlID0gcGJmLnJlYWRWYXJpbnQoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZTtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoYSwgYiwgdCkge1xuICAgIHJldHVybiAoYSAqICgxIC0gdCkpICsgKGIgKiB0KTtcbn1cblxuaW50ZXJwb2xhdGUubnVtYmVyID0gaW50ZXJwb2xhdGU7XG5cbmludGVycG9sYXRlLnZlYzIgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpXG4gICAgXTtcbn07XG5cbi8qXG4gKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIHR3byBjb2xvcnMgZ2l2ZW4gYXMgNC1lbGVtZW50IGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge0NvbG9yfSBmcm9tXG4gKiBAcGFyYW0ge0NvbG9yfSB0b1xuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBmYWN0b3IgYmV0d2VlbiAwIGFuZCAxXG4gKiBAcmV0dXJucyB7Q29sb3J9IGludGVycG9sYXRlZCBjb2xvclxuICovXG5pbnRlcnBvbGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVswXSwgdG9bMF0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzFdLCB0b1sxXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMl0sIHRvWzJdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVszXSwgdG9bM10sIHQpXG4gICAgXTtcbn07XG5cbmludGVycG9sYXRlLmFycmF5ID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGUoZCwgdG9baV0sIHQpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsLCBwYXRoUHJlZml4LCBhY2Nlc3NUb2tlbikge1xuICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgY29uZmlnLkFDQ0VTU19UT0tFTjtcblxuICAgIGlmICghYWNjZXNzVG9rZW4gJiYgY29uZmlnLlJFUVVJUkVfQUNDRVNTX1RPS0VOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gQVBJIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZCB0byB1c2UgTWFwYm94IEdMLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9kZXZlbG9wZXJzL2FwaS8jYWNjZXNzLXRva2VucycpO1xuICAgIH1cblxuICAgIHZhciBodHRwcyA9IGNvbmZpZy5GT1JDRV9IVFRQUyB8fFxuICAgICAgICAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicpO1xuXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL15tYXBib3g6XFwvXFwvLywgKGh0dHBzID8gY29uZmlnLkhUVFBTX1VSTCA6IGNvbmZpZy5IVFRQX1VSTCkgKyBwYXRoUHJlZml4KTtcbiAgICB1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJmFjY2Vzc190b2tlbj0nIDogJz9hY2Nlc3NfdG9rZW49JztcblxuICAgIGlmIChjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuWzBdID09PSAncycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlIGEgcHVibGljIGFjY2VzcyB0b2tlbiAocGsuKikgd2l0aCBNYXBib3ggR0wgSlMsIG5vdCBhIHNlY3JldCBhY2Nlc3MgdG9rZW4gKHNrLiopLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCArPSBhY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICB2YXIgdXNlciA9IHVybC5tYXRjaCgvXm1hcGJveDpcXC9cXC8oW14uXSspLyk7XG4gICAgaWYgKCF1c2VyKVxuICAgICAgICByZXR1cm4gdXJsO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVVSTCh1cmwsICcvc3R5bGVzL3YxLycgKyB1c2VyWzFdICsgJy8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTb3VyY2VVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsICsgJy5qc29uJywgJy92NC8nLCBhY2Nlc3NUb2tlbik7XG5cbiAgICAvLyBUaWxlSlNPTiByZXF1ZXN0cyBuZWVkIGEgc2VjdXJlIGZsYWcgYXBwZW5kZWQgdG8gdGhlaXIgVVJMcyBzb1xuICAgIC8vIHRoYXQgdGhlIHNlcnZlciBrbm93cyB0byBzZW5kIFNTTC1pZmllZCByZXNvdXJjZSByZWZlcmVuY2VzLlxuICAgIGlmICh1cmwuaW5kZXhPZignaHR0cHMnKSA9PT0gMClcbiAgICAgICAgdXJsICs9ICcmc2VjdXJlJztcblxuICAgIHJldHVybiB1cmw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVHbHlwaHNVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgaWYgKCF1cmwubWF0Y2goL15tYXBib3g6XFwvXFwvLykpXG4gICAgICAgIHJldHVybiB1cmw7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplVVJMKHVybCwgJy92NC8nLCBhY2Nlc3NUb2tlbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVUaWxlVVJMID0gZnVuY3Rpb24odXJsLCBzb3VyY2VVcmwpIHtcbiAgICBpZiAoIXNvdXJjZVVybCB8fCAhc291cmNlVXJsLm1hdGNoKC9ebWFwYm94OlxcL1xcLy8pKVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwuKCg/OnBuZ3xqcGcpXFxkKikoPz0kfFxcPykvLCBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPj0gMiA/ICdAMnguJDEnIDogJy4kMScpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIEEgW21vc3QtcmVjZW50bHktdXNlZCBjYWNoZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9hbGdvcml0aG1zKVxuICogd2l0aCBoYXNoIGxvb2t1cCBtYWRlIHBvc3NpYmxlIGJ5IGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgaW4gcGFyYWxsZWwgdG9cbiAqIGFuIGFycmF5IG9mIGRpY3Rpb25hcnkgb2YgdmFsdWVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTVJVQ2FjaGU7XG5mdW5jdGlvbiBNUlVDYWNoZShsZW5ndGgsIG9uUmVtb3ZlKSB7XG4gICAgdGhpcy5tYXggPSBsZW5ndGg7XG4gICAgdGhpcy5vblJlbW92ZSA9IG9uUmVtb3ZlO1xuICAgIHRoaXMucmVzZXQoKTtcbn1cblxuLypcbiAqIENsZWFycyB0aGUgY2FjaGVcbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMubGlzdCkge1xuICAgICAgICB0aGlzLm9uUmVtb3ZlKHRoaXMubGlzdFtrZXldKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3QgPSB7fTtcbiAgICB0aGlzLm9yZGVyID0gW107XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBBZGQgYSBrZXksIHZhbHVlIGNvbWJpbmF0aW9uIHRvIHRoZSBjYWNoZSwgdHJpbW1pbmcgaXRzIHNpemUgaWYgdGhpcyBwdXNoZXNcbiAqIGl0IG92ZXIgbWF4IGxlbmd0aC5cbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgZGF0YSkge1xuICAgIHRoaXMubGlzdFtrZXldID0gZGF0YTtcbiAgICB0aGlzLm9yZGVyLnB1c2goa2V5KTtcblxuICAgIGlmICh0aGlzLm9yZGVyLmxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgIHZhciByZW1vdmVkRGF0YSA9IHRoaXMuZ2V0KHRoaXMub3JkZXJbMF0pO1xuICAgICAgICBpZiAocmVtb3ZlZERhdGEpIHRoaXMub25SZW1vdmUocmVtb3ZlZERhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSB2YWx1ZSBhdHRhY2hlZCB0byBga2V5YCBpcyBwcmVzZW50XG4gKi9cbk1SVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMubGlzdDtcbn07XG5cbi8qXG4gKiBMaXN0IGFsbCBrZXlzIGluIHRoZSBjYWNoZVxuICovXG5NUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9yZGVyO1xufTtcblxuLypcbiAqIEdldCB0aGUgdmFsdWUgYXR0YWNoZWQgdG8gYSBzcGVjaWZpYyBrZXkuIElmIHRoZSBrZXkgaXMgbm90IGZvdW5kLFxuICogcmV0dXJucyBgbnVsbGBcbiAqL1xuTVJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICghdGhpcy5oYXMoa2V5KSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmxpc3Rba2V5XTtcblxuICAgIGRlbGV0ZSB0aGlzLmxpc3Rba2V5XTtcbiAgICB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2Yoa2V5KSwgMSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVRva2VucztcblxuZnVuY3Rpb24gcmVzb2x2ZVRva2Vucyhwcm9wZXJ0aWVzLCB0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyhbXnt9KClcXFtcXF08PiQ9OjsuLF5dKyl9L2csIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiBwcm9wZXJ0aWVzID8gcHJvcGVydGllc1trZXldIDogJyc7XG4gICAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVbml0QmV6aWVyID0gcmVxdWlyZSgndW5pdGJlemllcicpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgYHRgIHRoYXQgdmFyaWVzIGJldHdlZW4gMCBhbmQgMSwgcmV0dXJuXG4gKiBhbiBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uIHRoYXQgZWFzZXMgYmV0d2VlbiAwIGFuZCAxIGluIGEgcGxlYXNpbmdcbiAqIGN1YmljIGluLW91dCBmYXNoaW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBpbnB1dFxuICovXG5leHBvcnRzLmVhc2VDdWJpY0luT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCxcbiAgICAgICAgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gZ2l2ZW4gKHgsIHkpLCAoeDEsIHkxKSBjb250cm9sIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUsXG4gKiByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGludGVycG9sYXRlcyBhbG9uZyB0aGF0IGN1cnZlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXggY29udHJvbCBwb2ludCAxIHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAxeSBjb250cm9sIHBvaW50IDEgeSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ4IGNvbnRyb2wgcG9pbnQgMiB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMnkgY29udHJvbCBwb2ludCAyIHkgY29vcmRpbmF0ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBpbnRlcnBvbGF0b3I6IHJlY2VpdmVzIG51bWJlciB2YWx1ZSwgcmV0dXJuc1xuICogbnVtYmVyIHZhbHVlLlxuICovXG5leHBvcnRzLmJlemllciA9IGZ1bmN0aW9uKHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgIHZhciBiZXppZXIgPSBuZXcgVW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBiZXppZXIuc29sdmUodCk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBkZWZhdWx0IGJlemllci1jdXJ2ZSBwb3dlcmVkIGVhc2luZyBmdW5jdGlvbiB3aXRoXG4gKiBjb250cm9sIHBvaW50cyAoMC4yNSwgMC4xKSBhbmQgKDAuMjUsIDEpXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG91dHB1dFxuICovXG5leHBvcnRzLmVhc2UgPSBleHBvcnRzLmJlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpO1xuXG4vKipcbiAqIEdpdmVuIGEgZm91ci1lbGVtZW50IGFycmF5IG9mIG51bWJlcnMgdGhhdCByZXByZXNlbnRzIGEgY29sb3IgaW5cbiAqIFJHQkEsIHJldHVybiBhIHZlcnNpb24gZm9yIHdoaWNoIHRoZSBSR0IgY29tcG9uZW50cyBhcmUgbXVsdGlwbGllZFxuICogYnkgdGhlIEEgKGFscGhhKSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge051bWJlcjxBcnJheT59IGMgY29sb3IgYXJyYXlcbiAqIEByZXR1cm5zIHtOdW1iZXI8QXJyYXk+fSBwcmVtdWx0aXBsaWVkIGNvbG9yIGFycmF5XG4gKi9cbmV4cG9ydHMucHJlbXVsdGlwbHkgPSBmdW5jdGlvbiAoYykge1xuICAgIGNbMF0gKj0gY1szXTtcbiAgICBjWzFdICo9IGNbM107XG4gICAgY1syXSAqPSBjWzNdO1xuICAgIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UgdmlhIG1pbiArIG1heFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIHRoZSBtaW5pbXVtIHZhbHVlIHRvIGJlIHJldHVybmVkXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHRoZSBtYXhpbXVtIHZhbHVlIHRvIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgY2xhbXBlZCB2YWx1ZVxuICovXG5leHBvcnRzLmNsYW1wID0gZnVuY3Rpb24gKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCBuKSk7XG59O1xuXG4vKlxuICogY29uc3RyYWluIG4gdG8gdGhlIGdpdmVuIHJhbmdlIHZpYSBtb2R1bGFyIGFyaXRobWV0aWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBjb25zdHJhaW5lZCBudW1iZXJcbiAqL1xuZXhwb3J0cy53cmFwID0gZnVuY3Rpb24gKG4sIG1pbiwgbWF4KSB7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgcmV0dXJuIG4gPT09IG1heCA/IG4gOiAoKG4gLSBtaW4pICUgZCArIGQpICUgZCArIG1pbjtcbn07XG5cbi8qXG4gKiByZXR1cm4gdGhlIGZpcnN0IG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gYXJndW1lbnRcbiAqL1xuZXhwb3J0cy5jb2FsZXNjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGlmIChhcmcgIT09IG51bGwgJiYgYXJnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn07XG5cbi8qXG4gKiBDYWxsIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBvbiBhbiBhcnJheSBvZiBhcmd1bWVudHMsXG4gKiBjYWxsaW5nIGBjYWxsYmFja2Agb25jZSBhbGwgY2FsbHMgY29tcGxldGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyYXkgaW5wdXQgdG8gZWFjaCBjYWxsIG9mIHRoZSBhc3luYyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGFuIGFzeW5jIGZ1bmN0aW9uIHdpdGggc2lnbmF0dXJlIChkYXRhLCBjYWxsYmFjaylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgY2FsbGJhY2sgcnVuIGFmdGVyIGFsbCBhc3luYyB3b3JrIGlzIGRvbmUuXG4gKiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHNcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmV4cG9ydHMuYXN5bmNFYWNoID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHJldHVybiBjYWxsYmFjaygpO1xuICAgIGZ1bmN0aW9uIGNoZWNrKCkgeyBpZiAoLS1yZW1haW5pbmcgPT09IDApIGNhbGxiYWNrKCk7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBmbihhcnJheVtpXSwgY2hlY2spO1xufTtcblxuLypcbiAqIENvbXB1dGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUga2V5cyBpbiBvbmUgb2JqZWN0IGFuZCB0aGUga2V5c1xuICogaW4gYW5vdGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0ga2V5cyBkaWZmZXJlbmNlXG4gKi9cbmV4cG9ydHMua2V5c0RpZmZlcmVuY2UgPSBmdW5jdGlvbiAob2JqLCBvdGhlcikge1xuICAgIHZhciBkaWZmZXJlbmNlID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCEoaSBpbiBvdGhlcikpIHtcbiAgICAgICAgICAgIGRpZmZlcmVuY2UucHVzaChpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZmVyZW5jZTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBkZXN0aW5hdGlvbiBvYmplY3QgYW5kIG9wdGlvbmFsbHkgbWFueSBzb3VyY2Ugb2JqZWN0cyxcbiAqIGNvcHkgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc291cmNlIG9iamVjdHMgaW50byB0aGUgZGVzdGluYXRpb24uXG4gKiBUaGUgbGFzdCBzb3VyY2Ugb2JqZWN0IGdpdmVuIG92ZXJyaWRlcyBwcm9wZXJ0aWVzIGZyb20gcHJldmlvdXNcbiAqIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgZGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBzb3VyY2VzIGZyb20gd2hpY2ggcHJvcGVydGllcyBhcmUgcHVsbGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgZGVzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2YgdGhlIHNyYyBvYmplY3QsXG4gKiB1c2luZyBkZWZpbmVQcm9wZXJ0eSBpbnN0ZWFkIG9mIHNpbXBsZSBhc3NpZ25tZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuZXhwb3J0cy5leHRlbmRBbGwgPSBmdW5jdGlvbiAoZGVzdCwgc3JjKSB7XG4gICAgZm9yICh2YXIgaSBpbiBzcmMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3QsIGksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufTtcblxuLyoqXG4gKiBFeHRlbmQgYSBwYXJlbnQncyBwcm90b3R5cGUgd2l0aCBhbGwgcHJvcGVydGllcyBpbiBhIHByb3BlcnRpZXNcbiAqIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuaW5oZXJpdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHByb3BzKSB7XG4gICAgdmFyIHBhcmVudFByb3RvID0gdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudC5wcm90b3R5cGUgOiBwYXJlbnQsXG4gICAgICAgIHByb3RvID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm90byk7XG4gICAgZXhwb3J0cy5leHRlbmRBbGwocHJvdG8sIHByb3BzKTtcbiAgICByZXR1cm4gcHJvdG87XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIG9iamVjdCBhbmQgYSBudW1iZXIgb2YgcHJvcGVydGllcyBhcyBzdHJpbmdzLCByZXR1cm4gdmVyc2lvblxuICogb2YgdGhhdCBvYmplY3Qgd2l0aCBvbmx5IHRob3NlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNyYyB0aGUgb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHByb3BlcnRpZXMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgY2hvc2VuXG4gKiB0byBhcHBlYXIgb24gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBsaW1pdGVkIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGZvbyA9IHsgbmFtZTogJ0NoYXJsaWUnLCBhZ2U6IDEwIH07XG4gKiB2YXIganVzdE5hbWUgPSBwaWNrKGZvbywgWyduYW1lJ10pO1xuICogLy8ganVzdE5hbWUgPSB7IG5hbWU6ICdDaGFybGllJyB9XG4gKi9cbmV4cG9ydHMucGljayA9IGZ1bmN0aW9uIChzcmMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGsgaW4gc3JjKSB7XG4gICAgICAgICAgICByZXN1bHRba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpZCA9IDE7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIG51bWVyaWMgaWQsIHN0YXJ0aW5nIGF0IDEgYW5kIGluY3JlbWVudGluZyB3aXRoXG4gKiBlYWNoIGNhbGwuXG4gKlxuICogQHJldHVybnMge051bWJlcn0gdW5pcXVlIG51bWVyaWMgaWQuXG4gKi9cbmV4cG9ydHMudW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlkKys7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHZlcnNpb24gb2YgYGZuYCB0aGF0IG9ubHkgZmlyZXMgb25jZSBldmVyeSBgdGltZWAgbWlsbHNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGJlIHRocm90dGxlZFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgbWlsbHNlY29uZHMgcmVxdWlyZWQgYmV0d2VlbiBmdW5jdGlvbiBjYWxsc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSB2YWx1ZSBvZiBgdGhpc2Agd2l0aCB3aGljaCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGRlYm91bmNlZCBmdW5jdGlvblxuICovXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24gKGZuLCB0aW1lLCBjb250ZXh0KSB7XG4gICAgdmFyIGxvY2ssIGFyZ3MsIHdyYXBwZXJGbiwgbGF0ZXI7XG5cbiAgICBsYXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVzZXQgbG9jayBhbmQgY2FsbCBpZiBxdWV1ZWRcbiAgICAgICAgbG9jayA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgd3JhcHBlckZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgYXJncyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdyYXBwZXJGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCB0b28gc29vbiwgcXVldWUgdG8gY2FsbCBsYXRlclxuICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FsbCBhbmQgbG9jayB1bnRpbCBsYXRlclxuICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQobGF0ZXIsIHRpbWUpO1xuICAgICAgICAgICAgbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHdyYXBwZXJGbjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgdmVyc2lvbiBvZiBgZm5gIHRoYXQgaXMgb25seSBjYWxsZWQgYHRpbWVgIG1pbGxpc2Vjb25kc1xuICogYWZ0ZXIgaXRzIGxhc3QgaW52b2NhdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvbiB0byBiZSBkZWJvdW5jZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIG1pbGxzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydHMuZGVib3VuY2UgPSBmdW5jdGlvbihmbiwgdGltZSkge1xuICAgIHZhciB0aW1lciwgYXJncztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgdGltZSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgbWVtYmVyIGZ1bmN0aW9uIG5hbWVzIGFzIHN0cmluZ3MsIHJlcGxhY2UgYWxsIG9mIHRoZW1cbiAqIHdpdGggYm91bmQgdmVyc2lvbnMgdGhhdCB3aWxsIGFsd2F5cyByZWZlciB0byBgY29udGV4dGAgYXMgYHRoaXNgLiBUaGlzXG4gKiBpcyB1c2VmdWwgZm9yIGNsYXNzZXMgd2hlcmUgb3RoZXJ3aXNlIGV2ZW50IGJpbmRpbmdzIHdvdWxkIHJlYXNzaWduXG4gKiBgdGhpc2AgdG8gdGhlIGV2ZW50ZWQgb2JqZWN0IG9yIHNvbWUgb3RoZXIgdmFsdWU6IHRoaXMgbGV0cyB5b3UgZW5zdXJlXG4gKiB0aGUgYHRoaXNgIHZhbHVlIGFsd2F5cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZucyBsaXN0IG9mIG1lbWJlciBmdW5jdGlvbiBuYW1lc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSBjb250ZXh0IHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBjaGFuZ2VzIGZ1bmN0aW9ucyBpbi1wbGFjZVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIE15Q2xhc3MoKSB7XG4gKiAgIGJpbmRBbGwoWydvbnRpbWVyJ10sIHRoaXMpO1xuICogICB0aGlzLm5hbWUgPSAnVG9tJztcbiAqIH1cbiAqIE15Q2xhc3MucHJvdG90eXBlLm9udGltZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgYWxlcnQodGhpcy5uYW1lKTtcbiAqIH07XG4gKiB2YXIgbXlDbGFzcyA9IG5ldyBNeUNsYXNzKCk7XG4gKiBzZXRUaW1lb3V0KG15Q2xhc3Mub250aW1lciwgMTAwKTtcbiAqL1xuZXhwb3J0cy5iaW5kQWxsID0gZnVuY3Rpb24oZm5zLCBjb250ZXh0KSB7XG4gICAgZm5zLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgY29udGV4dFtmbl0gPSBjb250ZXh0W2ZuXS5iaW5kKGNvbnRleHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlICdvcHRpb25zJyBwcm9wZXJ0eSBvbiBgb2JqYCB3aXRoIHByb3BlcnRpZXNcbiAqIGZyb20gdGhlIGBvcHRpb25zYCBhcmd1bWVudC4gUHJvcGVydGllcyBpbiB0aGUgYG9wdGlvbnNgXG4gKiBvYmplY3Qgd2lsbCBvdmVycmlkZSBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogZGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvYmplY3Qgb2Ygb3ZlcnJpZGUgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gZGVyaXZlZCBvcHRpb25zIG9iamVjdC5cbiAqL1xuZXhwb3J0cy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICBvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gT2JqZWN0LmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5vcHRpb25zO1xufTtcbiIsIi8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vY3NzLWNvbG9yLXBhcnNlci1qc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXG4gIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsMjM1LDIxNSwxXSwgXCJhcXVhXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiYXF1YW1hcmluZVwiOiBbMTI3LDI1NSwyMTIsMV0sIFwiYXp1cmVcIjogWzI0MCwyNTUsMjU1LDFdLFxuICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxuICBcImJsYWNrXCI6IFswLDAsMCwxXSwgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LDIzNSwyMDUsMV0sXG4gIFwiYmx1ZVwiOiBbMCwwLDI1NSwxXSwgXCJibHVldmlvbGV0XCI6IFsxMzgsNDMsMjI2LDFdLFxuICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcbiAgXCJjYWRldGJsdWVcIjogWzk1LDE1OCwxNjAsMV0sIFwiY2hhcnRyZXVzZVwiOiBbMTI3LDI1NSwwLDFdLFxuICBcImNob2NvbGF0ZVwiOiBbMjEwLDEwNSwzMCwxXSwgXCJjb3JhbFwiOiBbMjU1LDEyNyw4MCwxXSxcbiAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxuICBcImNyaW1zb25cIjogWzIyMCwyMCw2MCwxXSwgXCJjeWFuXCI6IFswLDI1NSwyNTUsMV0sXG4gIFwiZGFya2JsdWVcIjogWzAsMCwxMzksMV0sIFwiZGFya2N5YW5cIjogWzAsMTM5LDEzOSwxXSxcbiAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcbiAgXCJkYXJrZ3JlZW5cIjogWzAsMTAwLDAsMV0sIFwiZGFya2dyZXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtraGFraVwiOiBbMTg5LDE4MywxMDcsMV0sIFwiZGFya21hZ2VudGFcIjogWzEzOSwwLDEzOSwxXSxcbiAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcbiAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsNTAsMjA0LDFdLCBcImRhcmtyZWRcIjogWzEzOSwwLDAsMV0sXG4gIFwiZGFya3NhbG1vblwiOiBbMjMzLDE1MCwxMjIsMV0sIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsMTg4LDE0MywxXSxcbiAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXG4gIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsNzksNzksMV0sIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwyMDYsMjA5LDFdLFxuICBcImRhcmt2aW9sZXRcIjogWzE0OCwwLDIxMSwxXSwgXCJkZWVwcGlua1wiOiBbMjU1LDIwLDE0NywxXSxcbiAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxuICBcImRpbWdyZXlcIjogWzEwNSwxMDUsMTA1LDFdLCBcImRvZGdlcmJsdWVcIjogWzMwLDE0NCwyNTUsMV0sXG4gIFwiZmlyZWJyaWNrXCI6IFsxNzgsMzQsMzQsMV0sIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwyNTAsMjQwLDFdLFxuICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxuICBcImdhaW5zYm9yb1wiOiBbMjIwLDIyMCwyMjAsMV0sIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LDI0OCwyNTUsMV0sXG4gIFwiZ29sZFwiOiBbMjU1LDIxNSwwLDFdLCBcImdvbGRlbnJvZFwiOiBbMjE4LDE2NSwzMiwxXSxcbiAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcbiAgXCJncmVlbnllbGxvd1wiOiBbMTczLDI1NSw0NywxXSwgXCJncmV5XCI6IFsxMjgsMTI4LDEyOCwxXSxcbiAgXCJob25leWRld1wiOiBbMjQwLDI1NSwyNDAsMV0sIFwiaG90cGlua1wiOiBbMjU1LDEwNSwxODAsMV0sXG4gIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcbiAgXCJpdm9yeVwiOiBbMjU1LDI1NSwyNDAsMV0sIFwia2hha2lcIjogWzI0MCwyMzAsMTQwLDFdLFxuICBcImxhdmVuZGVyXCI6IFsyMzAsMjMwLDI1MCwxXSwgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsMjQwLDI0NSwxXSxcbiAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxuICBcImxpZ2h0Ymx1ZVwiOiBbMTczLDIxNiwyMzAsMV0sIFwibGlnaHRjb3JhbFwiOiBbMjQwLDEyOCwxMjgsMV0sXG4gIFwibGlnaHRjeWFuXCI6IFsyMjQsMjU1LDI1NSwxXSwgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLDI1MCwyMTAsMV0sXG4gIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcbiAgXCJsaWdodGdyZXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0cGlua1wiOiBbMjU1LDE4MiwxOTMsMV0sXG4gIFwibGlnaHRzYWxtb25cIjogWzI1NSwxNjAsMTIyLDFdLCBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLDE3OCwxNzAsMV0sXG4gIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXG4gIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwxMzYsMTUzLDFdLCBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsMTk2LDIyMiwxXSxcbiAgXCJsaWdodHllbGxvd1wiOiBbMjU1LDI1NSwyMjQsMV0sIFwibGltZVwiOiBbMCwyNTUsMCwxXSxcbiAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXG4gIFwibWFnZW50YVwiOiBbMjU1LDAsMjU1LDFdLCBcIm1hcm9vblwiOiBbMTI4LDAsMCwxXSxcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsMjA1LDE3MCwxXSwgXCJtZWRpdW1ibHVlXCI6IFswLDAsMjA1LDFdLFxuICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxuICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwxNzksMTEzLDFdLCBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLDEwNCwyMzgsMV0sXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsMjUwLDE1NCwxXSwgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLDIwOSwyMDQsMV0sXG4gIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxuICBcIm1pbnRjcmVhbVwiOiBbMjQ1LDI1NSwyNTAsMV0sIFwibWlzdHlyb3NlXCI6IFsyNTUsMjI4LDIyNSwxXSxcbiAgXCJtb2NjYXNpblwiOiBbMjU1LDIyOCwxODEsMV0sIFwibmF2YWpvd2hpdGVcIjogWzI1NSwyMjIsMTczLDFdLFxuICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXG4gIFwib2xpdmVcIjogWzEyOCwxMjgsMCwxXSwgXCJvbGl2ZWRyYWJcIjogWzEwNywxNDIsMzUsMV0sXG4gIFwib3JhbmdlXCI6IFsyNTUsMTY1LDAsMV0sIFwib3JhbmdlcmVkXCI6IFsyNTUsNjksMCwxXSxcbiAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxuICBcInBhbGVncmVlblwiOiBbMTUyLDI1MSwxNTIsMV0sIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LDIzOCwyMzgsMV0sXG4gIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LDExMiwxNDcsMV0sIFwicGFwYXlhd2hpcFwiOiBbMjU1LDIzOSwyMTMsMV0sXG4gIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxuICBcInBpbmtcIjogWzI1NSwxOTIsMjAzLDFdLCBcInBsdW1cIjogWzIyMSwxNjAsMjIxLDFdLFxuICBcInBvd2RlcmJsdWVcIjogWzE3NiwyMjQsMjMwLDFdLCBcInB1cnBsZVwiOiBbMTI4LDAsMTI4LDFdLFxuICBcInJlZFwiOiBbMjU1LDAsMCwxXSwgXCJyb3N5YnJvd25cIjogWzE4OCwxNDMsMTQzLDFdLFxuICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxuICBcInNhbG1vblwiOiBbMjUwLDEyOCwxMTQsMV0sIFwic2FuZHlicm93blwiOiBbMjQ0LDE2NCw5NiwxXSxcbiAgXCJzZWFncmVlblwiOiBbNDYsMTM5LDg3LDFdLCBcInNlYXNoZWxsXCI6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxuICBcInNreWJsdWVcIjogWzEzNSwyMDYsMjM1LDFdLCBcInNsYXRlYmx1ZVwiOiBbMTA2LDkwLDIwNSwxXSxcbiAgXCJzbGF0ZWdyYXlcIjogWzExMiwxMjgsMTQ0LDFdLCBcInNsYXRlZ3JleVwiOiBbMTEyLDEyOCwxNDQsMV0sXG4gIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcbiAgXCJzdGVlbGJsdWVcIjogWzcwLDEzMCwxODAsMV0sIFwidGFuXCI6IFsyMTAsMTgwLDE0MCwxXSxcbiAgXCJ0ZWFsXCI6IFswLDEyOCwxMjgsMV0sIFwidGhpc3RsZVwiOiBbMjE2LDE5MSwyMTYsMV0sXG4gIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxuICBcInZpb2xldFwiOiBbMjM4LDEzMCwyMzgsMV0sIFwid2hlYXRcIjogWzI0NSwyMjIsMTc5LDFdLFxuICBcIndoaXRlXCI6IFsyNTUsMjU1LDI1NSwxXSwgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cblxuZnVuY3Rpb24gY2xhbXBfY3NzX2J5dGUoaSkgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgaSA9IE1hdGgucm91bmQoaSk7ICAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikgeyAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcbiAgICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBwYXJzZV9jc3NfZmxvYXQoc3RyKSB7ICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikpO1xufVxuXG5mdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgaWYgKGggPCAwKSBoICs9IDE7XG4gIGVsc2UgaWYgKGggPiAxKSBoIC09IDE7XG5cbiAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcbiAgcmV0dXJuIG0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAgLy8gZHVwLlxuXG4gIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkgcmV0dXJuIG51bGw7ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgcmV0dXJuIFsoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgMV07XG4gICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcbiAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwKSA+PiA4LFxuICAgICAgICAgICAgICBpdiAmIDB4ZmYsXG4gICAgICAgICAgICAgIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKSwgZXAgPSBzdHIuaW5kZXhPZignKScpO1xuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wKzEsIGVwLShvcCsxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cbiAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICBjYXNlICdyZ2JhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBbcGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSxcbiAgICAgICAgICAgICAgICBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuICAgICAgY2FzZSAnaHNsJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MDsgIC8vIDAgLi4gMVxuICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICB2YXIgbCA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgcmV0dXJuIFtjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxuICAgICAgICAgICAgICAgIGFscGhhXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG50cnkgeyBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yIH0gY2F0Y2goZSkgeyB9XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZVR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG5mdW5jdGlvbiBpbmZpeChvcGVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihfLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICckdHlwZScpIHtcbiAgICAgICAgICAgIHJldHVybiAndCcgKyBvcGVyYXRvciArIFZlY3RvclRpbGVGZWF0dXJlVHlwZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3BbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXScgKyBvcGVyYXRvciArIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHN0cmljdEluZml4KG9wZXJhdG9yKSB7XG4gICAgdmFyIG5vbnN0cmljdEluZml4ID0gaW5maXgob3BlcmF0b3IpO1xuICAgIHJldHVybiBmdW5jdGlvbihfLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICckdHlwZScpIHtcbiAgICAgICAgICAgIHJldHVybiBub25zdHJpY3RJbmZpeChfLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndHlwZW9mKHBbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXSkgPT09IHR5cGVvZignICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJykgJiYgJyArXG4gICAgICAgICAgICAgICAgbm9uc3RyaWN0SW5maXgoXywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG52YXIgb3BlcmF0b3JzID0ge1xuICAgICc9PSc6IGluZml4KCc9PT0nKSxcbiAgICAnIT0nOiBpbmZpeCgnIT09JyksXG4gICAgJz4nOiBzdHJpY3RJbmZpeCgnPicpLFxuICAgICc8Jzogc3RyaWN0SW5maXgoJzwnKSxcbiAgICAnPD0nOiBzdHJpY3RJbmZpeCgnPD0nKSxcbiAgICAnPj0nOiBzdHJpY3RJbmZpeCgnPj0nKSxcbiAgICAnaW4nOiBmdW5jdGlvbihfLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJygnICsgb3BlcmF0b3JzWyc9PSddKF8sIGtleSwgdmFsdWUpICsgJyknO1xuICAgICAgICB9KS5qb2luKCd8fCcpIHx8ICdmYWxzZSc7XG4gICAgfSxcbiAgICAnIWluJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnISgnICsgb3BlcmF0b3JzLmluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyAnKSc7XG4gICAgfSxcbiAgICAnYW55JzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLm1hcChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyBjb21waWxlKGZpbHRlcikgKyAnKSc7XG4gICAgICAgIH0pLmpvaW4oJ3x8JykgfHwgJ2ZhbHNlJztcbiAgICB9LFxuICAgICdhbGwnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkubWFwKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuICcoJyArIGNvbXBpbGUoZmlsdGVyKSArICcpJztcbiAgICAgICAgfSkuam9pbignJiYnKSB8fCAndHJ1ZSc7XG4gICAgfSxcbiAgICAnbm9uZSc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJyEoJyArIG9wZXJhdG9ycy5hbnkuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICcpJztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb21waWxlKGZpbHRlcikge1xuICAgIHJldHVybiBvcGVyYXRvcnNbZmlsdGVyWzBdXS5hcHBseShmaWx0ZXIsIGZpbHRlcik7XG59XG5cbmZ1bmN0aW9uIHRydXRoKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICBpZiAoIWZpbHRlcikgcmV0dXJuIHRydXRoO1xuICAgIHZhciBmaWx0ZXJTdHIgPSAndmFyIHAgPSBmLnByb3BlcnRpZXMgfHwgZi50YWdzIHx8IHt9LCB0ID0gZi50eXBlOyByZXR1cm4gJyArIGNvbXBpbGUoZmlsdGVyKSArICc7JztcbiAgICAvLyBqc2hpbnQgZXZpbDogdHJ1ZVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2YnLCBmaWx0ZXJTdHIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwO1xuXG4vKiBjbGlwIGZlYXR1cmVzIGJldHdlZW4gdHdvIGF4aXMtcGFyYWxsZWwgbGluZXM6XG4gKiAgICAgfCAgICAgICAgfFxuICogIF9fX3xfX18gICAgIHwgICAgIC9cbiAqIC8gICB8ICAgXFxfX19ffF9fX18vXG4gKiAgICAgfCAgICAgICAgfFxuICovXG5cbmZ1bmN0aW9uIGNsaXAoZmVhdHVyZXMsIHNjYWxlLCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCkge1xuXG4gICAgazEgLz0gc2NhbGU7XG4gICAgazIgLz0gc2NhbGU7XG5cbiAgICB2YXIgY2xpcHBlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbaV0sXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgICAgICB0eXBlID0gZmVhdHVyZS50eXBlLFxuICAgICAgICAgICAgbWluLCBtYXg7XG5cbiAgICAgICAgaWYgKGZlYXR1cmUubWluKSB7XG4gICAgICAgICAgICBtaW4gPSBmZWF0dXJlLm1pbltheGlzXTtcbiAgICAgICAgICAgIG1heCA9IGZlYXR1cmUubWF4W2F4aXNdO1xuXG4gICAgICAgICAgICBpZiAobWluID49IGsxICYmIG1heCA8PSBrMikgeyAvLyB0cml2aWFsIGFjY2VwdFxuICAgICAgICAgICAgICAgIGNsaXBwZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWluID4gazIgfHwgbWF4IDwgazEpIGNvbnRpbnVlOyAvLyB0cml2aWFsIHJlamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsaWNlcyA9IHR5cGUgPT09IDEgP1xuICAgICAgICAgICAgICAgIGNsaXBQb2ludHMoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcykgOlxuICAgICAgICAgICAgICAgIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIHR5cGUgPT09IDMpO1xuXG4gICAgICAgIGlmIChzbGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiBhIGZlYXR1cmUgZ290IGNsaXBwZWQsIGl0IHdpbGwgbGlrZWx5IGdldCBjbGlwcGVkIG9uIHRoZSBuZXh0IHpvb20gbGV2ZWwgYXMgd2VsbCxcbiAgICAgICAgICAgIC8vIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byByZWNhbGN1bGF0ZSBiYm94ZXNcbiAgICAgICAgICAgIGNsaXBwZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHNsaWNlcyxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmVzW2ldLnRhZ3MgfHwgbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZC5sZW5ndGggPyBjbGlwcGVkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xpcFBvaW50cyhnZW9tZXRyeSwgazEsIGsyLCBheGlzKSB7XG4gICAgdmFyIHNsaWNlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gZ2VvbWV0cnlbaV0sXG4gICAgICAgICAgICBhayA9IGFbYXhpc107XG5cbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2U7XG59XG5cbmZ1bmN0aW9uIGNsaXBHZW9tZXRyeShnZW9tZXRyeSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIGNsb3NlZCkge1xuXG4gICAgdmFyIHNsaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBhayA9IDAsXG4gICAgICAgICAgICBiayA9IDAsXG4gICAgICAgICAgICBiID0gbnVsbCxcbiAgICAgICAgICAgIHBvaW50cyA9IGdlb21ldHJ5W2ldLFxuICAgICAgICAgICAgYXJlYSA9IHBvaW50cy5hcmVhLFxuICAgICAgICAgICAgZGlzdCA9IHBvaW50cy5kaXN0LFxuICAgICAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGEsIGo7XG5cbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiAtIDE7IGorKykge1xuICAgICAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2pdO1xuICAgICAgICAgICAgYiA9IHBvaW50c1tqICsgMV07XG4gICAgICAgICAgICBhayA9IGJrIHx8IGFbYXhpc107XG4gICAgICAgICAgICBiayA9IGJbYXhpc107XG5cbiAgICAgICAgICAgIGlmIChhayA8IGsxKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGJrID4gazIpKSB7IC8vIC0tLXwtLS0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpLCBpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID49IGsxKSBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMSkpOyAvLyAtLS18LS0+ICB8XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWsgPiBrMikge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA8IGsxKSkgeyAvLyA8LS18LS0tLS18LS0tXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsyKSwgaW50ZXJzZWN0KGEsIGIsIGsxKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA8PSBrMikgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTsgLy8gfCAgPC0tfC0tLVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAgICAgICAgIGlmIChiayA8IGsxKSB7IC8vIDwtLXwtLS0gIHxcbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJrID4gazIpIHsgLy8gfCAgLS0tfC0tPlxuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGludGVyc2VjdChhLCBiLCBrMikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkgc2xpY2UgPSBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfCAtLT4gfFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBsYXN0IHBvaW50XG4gICAgICAgIGEgPSBwb2ludHNbbGVuIC0gMV07XG4gICAgICAgIGFrID0gYVtheGlzXTtcbiAgICAgICAgaWYgKGFrID49IGsxICYmIGFrIDw9IGsyKSBzbGljZS5wdXNoKGEpO1xuXG4gICAgICAgIC8vIGNsb3NlIHRoZSBwb2x5Z29uIGlmIGl0cyBlbmRwb2ludHMgYXJlIG5vdCB0aGUgc2FtZSBhZnRlciBjbGlwcGluZ1xuICAgICAgICBpZiAoY2xvc2VkICYmIHNsaWNlWzBdICE9PSBzbGljZVtzbGljZS5sZW5ndGggLSAxXSkgc2xpY2UucHVzaChzbGljZVswXSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBmaW5hbCBzbGljZVxuICAgICAgICBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpY2VzO1xufVxuXG5mdW5jdGlvbiBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0KSB7XG4gICAgaWYgKHNsaWNlLmxlbmd0aCkge1xuICAgICAgICAvLyB3ZSBkb24ndCByZWNhbGN1bGF0ZSB0aGUgYXJlYS9sZW5ndGggb2YgdGhlIHVuY2xpcHBlZCBnZW9tZXRyeSBiZWNhdXNlIHRoZSBjYXNlIHdoZXJlIGl0IGdvZXNcbiAgICAgICAgLy8gYmVsb3cgdGhlIHZpc2liaWxpdHkgdGhyZXNob2xkIGFzIGEgcmVzdWx0IG9mIGNsaXBwaW5nIGlzIHJhcmUsIHNvIHdlIGF2b2lkIGRvaW5nIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgc2xpY2UuYXJlYSA9IGFyZWE7XG4gICAgICAgIHNsaWNlLmRpc3QgPSBkaXN0O1xuXG4gICAgICAgIHNsaWNlcy5wdXNoKHNsaWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG5cbnZhciBzaW1wbGlmeSA9IHJlcXVpcmUoJy4vc2ltcGxpZnknKTtcblxuLy8gY29udmVydHMgR2VvSlNPTiBmZWF0dXJlIGludG8gYW4gaW50ZXJtZWRpYXRlIHByb2plY3RlZCBKU09OIHZlY3RvciBmb3JtYXQgd2l0aCBzaW1wbGlmaWNhdGlvbiBkYXRhXG5cbmZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgdG9sZXJhbmNlKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGRhdGEuZmVhdHVyZXNbaV0sIHRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBkYXRhLCB0b2xlcmFuY2UpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2luZ2xlIGdlb21ldHJ5IG9yIGEgZ2VvbWV0cnkgY29sbGVjdGlvblxuICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywge2dlb21ldHJ5OiBkYXRhfSwgdG9sZXJhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZmVhdHVyZSwgdG9sZXJhbmNlKSB7XG4gICAgdmFyIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICB0eXBlID0gZ2VvbS50eXBlLFxuICAgICAgICBjb29yZHMgPSBnZW9tLmNvb3JkaW5hdGVzLFxuICAgICAgICB0YWdzID0gZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICBpLCBqLCByaW5ncztcblxuICAgIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDEsIFtwcm9qZWN0UG9pbnQoY29vcmRzKV0pKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDEsIHByb2plY3QoY29vcmRzKSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMiwgW3Byb2plY3QoY29vcmRzLCB0b2xlcmFuY2UpXSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJyB8fCB0eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmluZ3MucHVzaChwcm9qZWN0KGNvb3Jkc1tpXSwgdG9sZXJhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgdHlwZSA9PT0gJ1BvbHlnb24nID8gMyA6IDIsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHJpbmdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICByaW5ncy5wdXNoKHByb2plY3QoY29vcmRzW2ldW2pdLCB0b2xlcmFuY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmZWF0dXJlcy5wdXNoKGNyZWF0ZSh0YWdzLCAzLCByaW5ncykpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tLmdlb21ldHJpZXNbaV0sXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogdGFnc1xuICAgICAgICAgICAgfSwgdG9sZXJhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBHZW9KU09OIHR5cGU6ICcgKyBnZW9tLnR5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKHRhZ3MsIHR5cGUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGZlYXR1cmUgPSB7XG4gICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdGFnczogdGFncyB8fCBudWxsLFxuICAgICAgICBtaW46IFsxLCAxXSwgLy8gaW5pdGlhbCBiYm94IHZhbHVlcztcbiAgICAgICAgbWF4OiBbMCwgMF0gIC8vIG5vdGUgdGhhdCBhbGwgY29vcmRzIGFyZSBpbiBbMC4uMV0gcmFuZ2VcbiAgICB9O1xuICAgIGNhbGNCQm94KGZlYXR1cmUpO1xuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0KGxvbmxhdHMsIHRvbGVyYW5jZSkge1xuICAgIHZhciBwcm9qZWN0ZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmxhdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvamVjdGVkLnB1c2gocHJvamVjdFBvaW50KGxvbmxhdHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHRvbGVyYW5jZSkge1xuICAgICAgICBzaW1wbGlmeShwcm9qZWN0ZWQsIHRvbGVyYW5jZSk7XG4gICAgICAgIGNhbGNTaXplKHByb2plY3RlZCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9qZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHByb2plY3RQb2ludChwKSB7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKHBbMV0gKiBNYXRoLlBJIC8gMTgwKSxcbiAgICAgICAgeCA9IChwWzBdIC8gMzYwICsgMC41KSxcbiAgICAgICAgeSA9ICgwLjUgLSAwLjI1ICogTWF0aC5sb2coKDEgKyBzaW4pIC8gKDEgLSBzaW4pKSAvIE1hdGguUEkpO1xuICAgIHJldHVybiBbeCwgeSwgMF07XG59XG5cbi8vIGNhbGN1bGF0ZSBhcmVhIGFuZCBsZW5ndGggb2YgdGhlIHBvbHlcbmZ1bmN0aW9uIGNhbGNTaXplKHBvaW50cykge1xuICAgIHZhciBhcmVhID0gMCxcbiAgICAgICAgZGlzdCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYSwgYjsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgYSA9IGIgfHwgcG9pbnRzW2ldO1xuICAgICAgICBiID0gcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG5cbiAgICAgICAgLy8gdXNlIE1hbmhhdHRhbiBkaXN0YW5jZSBpbnN0ZWFkIG9mIEV1Y2xpZGlhbiBvbmUgdG8gYXZvaWQgZXhwZW5zaXZlIHNxdWFyZSByb290IGNvbXB1dGF0aW9uXG4gICAgICAgIGRpc3QgKz0gTWF0aC5hYnMoYlswXSAtIGFbMF0pICsgTWF0aC5hYnMoYlsxXSAtIGFbMV0pO1xuICAgIH1cbiAgICBwb2ludHMuYXJlYSA9IE1hdGguYWJzKGFyZWEgLyAyKTtcbiAgICBwb2ludHMuZGlzdCA9IGRpc3Q7XG59XG5cbi8vIGNhbGN1bGF0ZSB0aGUgZmVhdHVyZSBib3VuZGluZyBib3ggZm9yIGZhc3RlciBjbGlwcGluZyBsYXRlclxuZnVuY3Rpb24gY2FsY0JCb3goZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnksXG4gICAgICAgIG1pbiA9IGZlYXR1cmUubWluLFxuICAgICAgICBtYXggPSBmZWF0dXJlLm1heDtcblxuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09IDEpIGNhbGNSaW5nQkJveChtaW4sIG1heCwgZ2VvbWV0cnkpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5sZW5ndGg7IGkrKykgY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBnZW9tZXRyeVtpXSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBwb2ludHMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgcDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwID0gcG9pbnRzW2ldO1xuICAgICAgICBtaW5bMF0gPSBNYXRoLm1pbihwWzBdLCBtaW5bMF0pO1xuICAgICAgICBtYXhbMF0gPSBNYXRoLm1heChwWzBdLCBtYXhbMF0pO1xuICAgICAgICBtaW5bMV0gPSBNYXRoLm1pbihwWzFdLCBtaW5bMV0pO1xuICAgICAgICBtYXhbMV0gPSBNYXRoLm1heChwWzFdLCBtYXhbMV0pO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZW9qc29udnQ7XG5cbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnLi9jb252ZXJ0JyksIC8vIEdlb0pTT04gY29udmVyc2lvbiBhbmQgcHJlcHJvY2Vzc2luZ1xuICAgIGNsaXAgPSByZXF1aXJlKCcuL2NsaXAnKSwgICAgICAgLy8gc3RyaXBlIGNsaXBwaW5nIGFsZ29yaXRobVxuICAgIGNyZWF0ZVRpbGUgPSByZXF1aXJlKCcuL3RpbGUnKTsgLy8gZmluYWwgc2ltcGxpZmllZCB0aWxlIGdlbmVyYXRpb25cblxuXG5mdW5jdGlvbiBnZW9qc29udnQoZGF0YSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR2VvSlNPTlZUKGRhdGEsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBHZW9KU09OVlQoZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcblxuICAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgICBpZiAoZGVidWcpIGNvbnNvbGUudGltZSgncHJlcHJvY2VzcyBkYXRhJyk7XG5cbiAgICB2YXIgejIgPSAxIDw8IG9wdGlvbnMuYmFzZVpvb20sIC8vIDJeelxuICAgICAgICBmZWF0dXJlcyA9IGNvbnZlcnQoZGF0YSwgb3B0aW9ucy50b2xlcmFuY2UgLyAoejIgKiBvcHRpb25zLmV4dGVudCkpO1xuXG4gICAgdGhpcy50aWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUudGltZUVuZCgncHJlcHJvY2VzcyBkYXRhJyk7XG4gICAgICAgIGNvbnNvbGUudGltZSgnZ2VuZXJhdGUgdGlsZXMgdXAgdG8geicgKyBvcHRpb25zLm1heFpvb20pO1xuICAgICAgICB0aGlzLnN0YXRzID0ge307XG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IHNsaWNpbmcgZnJvbSB0aGUgdG9wIHRpbGUgZG93blxuICAgIHRoaXMuc3BsaXRUaWxlKGZlYXR1cmVzLCAwLCAwLCAwKTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkJywgdGhpcy50aWxlc1swXS5udW1GZWF0dXJlcywgdGhpcy50aWxlc1swXS5udW1Qb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2dlbmVyYXRlIHRpbGVzIHVwIHRvIHonICsgb3B0aW9ucy5tYXhab29tKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3RpbGVzIGdlbmVyYXRlZDonLCB0aGlzLnRvdGFsLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRzKSk7XG4gICAgfVxufVxuXG5HZW9KU09OVlQucHJvdG90eXBlLm9wdGlvbnMgPSB7XG4gICAgYmFzZVpvb206IDE0LCAgIC8vIG1heCB6b29tIHRvIHByZXNlcnZlIGRldGFpbCBvblxuICAgIG1heFpvb206IDQsICAgICAvLyB6b29tIHRvIHNsaWNlIGRvd24gdG8gb24gZmlyc3QgcGFzc1xuICAgIG1heFBvaW50czogMTAwLCAvLyBzdG9wIHNsaWNpbmcgYSB0aWxlIGJlbG93IHRoaXMgbnVtYmVyIG9mIHBvaW50c1xuICAgIHRvbGVyYW5jZTogMywgICAvLyBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyKVxuICAgIGV4dGVudDogNDA5NiwgICAvLyB0aWxlIGV4dGVudFxuICAgIGJ1ZmZlcjogNjQsICAgICAvLyB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGVcbiAgICBkZWJ1ZzogMCAgICAgICAgLy8gbG9nZ2luZyBsZXZlbCAoMCwgMSBvciAyKVxufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5zcGxpdFRpbGUgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHosIHgsIHksIGN6LCBjeCwgY3kpIHtcblxuICAgIHZhciBzdGFjayA9IFtmZWF0dXJlcywgeiwgeCwgeV0sXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsXG4gICAgICAgIGJ1ZmZlciA9IG9wdGlvbnMuYnVmZmVyO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgcHJvY2Vzc2luZyBxdWV1ZVxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgZmVhdHVyZXMgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICB6ID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgeCA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIHkgPSBzdGFjay5zaGlmdCgpO1xuXG4gICAgICAgIHZhciB6MiA9IDEgPDwgeixcbiAgICAgICAgICAgIGlkID0gdG9JRCh6LCB4LCB5KSxcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLnRpbGVzW2lkXSxcbiAgICAgICAgICAgIHRpbGVUb2xlcmFuY2UgPSB6ID09PSBvcHRpb25zLmJhc2Vab29tID8gMCA6IG9wdGlvbnMudG9sZXJhbmNlIC8gKHoyICogZXh0ZW50KTtcblxuICAgICAgICBpZiAoIXRpbGUpIHtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY3JlYXRpb24nKTtcblxuICAgICAgICAgICAgdGlsZSA9IHRoaXMudGlsZXNbaWRdID0gY3JlYXRlVGlsZShmZWF0dXJlcywgejIsIHgsIHksIHRpbGVUb2xlcmFuY2UsIGV4dGVudCwgeiA9PT0gb3B0aW9ucy5iYXNlWm9vbSk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbGUgeiVkLSVkLSVkIChmZWF0dXJlczogJWQsIHBvaW50czogJWQsIHNpbXBsaWZpZWQ6ICVkKScsXG4gICAgICAgICAgICAgICAgICAgICAgICB6LCB4LCB5LCB0aWxlLm51bUZlYXR1cmVzLCB0aWxlLm51bVBvaW50cywgdGlsZS5udW1TaW1wbGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKCdjcmVhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJ3onICsgeiArICc6JztcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRzW2tleV0gPSAodGhpcy5zdGF0c1trZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN6ICYmICh6ID09PSBvcHRpb25zLm1heFpvb20gfHwgdGlsZS5udW1Qb2ludHMgPD0gb3B0aW9ucy5tYXhQb2ludHMgfHxcbiAgICAgICAgICAgICAgICBpc0NsaXBwZWRTcXVhcmUodGlsZS5mZWF0dXJlcywgZXh0ZW50LCBidWZmZXIpKSB8fCB6ID09PSBvcHRpb25zLmJhc2Vab29tIHx8IHogPT09IGN6KSB7XG4gICAgICAgICAgICB0aWxlLnNvdXJjZSA9IGZlYXR1cmVzO1xuICAgICAgICAgICAgY29udGludWU7IC8vIHN0b3AgdGlsaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3opIHRpbGUuc291cmNlID0gZmVhdHVyZXM7XG4gICAgICAgIGVsc2UgdGlsZS5zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY2xpcHBpbmcnKTtcblxuICAgICAgICAvLyB2YWx1ZXMgd2UnbGwgdXNlIGZvciBjbGlwcGluZ1xuICAgICAgICB2YXIgazEgPSAwLjUgKiBidWZmZXIgLyBleHRlbnQsXG4gICAgICAgICAgICBrMiA9IDAuNSAtIGsxLFxuICAgICAgICAgICAgazMgPSAwLjUgKyBrMSxcbiAgICAgICAgICAgIGs0ID0gMSArIGsxLFxuXG4gICAgICAgICAgICB0bCwgYmwsIHRyLCBiciwgbGVmdCwgcmlnaHQsXG4gICAgICAgICAgICBtLCBnb0xlZnQsIGdvVG9wO1xuXG4gICAgICAgIGlmIChjeikgeyAvLyBpZiB3ZSBoYXZlIGEgc3BlY2lmaWMgdGlsZSB0byBkcmlsbCBkb3duIHRvLCBjYWxjdWxhdGUgd2hlcmUgdG8gZ29cbiAgICAgICAgICAgIG0gPSAxIDw8IChjeiAtIHopO1xuICAgICAgICAgICAgZ29MZWZ0ID0gY3ggLyBtIC0geCA8IDAuNTtcbiAgICAgICAgICAgIGdvVG9wID0gY3kgLyBtIC0geSA8IDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRsID0gYmwgPSB0ciA9IGJyID0gbGVmdCA9IHJpZ2h0ID0gbnVsbDtcblxuICAgICAgICBpZiAoIWN6IHx8ICBnb0xlZnQpIGxlZnQgID0gY2xpcChmZWF0dXJlcywgejIsIHggLSBrMSwgeCArIGszLCAwLCBpbnRlcnNlY3RYKTtcbiAgICAgICAgaWYgKCFjeiB8fCAhZ29MZWZ0KSByaWdodCA9IGNsaXAoZmVhdHVyZXMsIHoyLCB4ICsgazIsIHggKyBrNCwgMCwgaW50ZXJzZWN0WCk7XG5cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIGlmICghY3ogfHwgIGdvVG9wKSB0bCA9IGNsaXAobGVmdCwgejIsIHkgLSBrMSwgeSArIGszLCAxLCBpbnRlcnNlY3RZKTtcbiAgICAgICAgICAgIGlmICghY3ogfHwgIWdvVG9wKSBibCA9IGNsaXAobGVmdCwgejIsIHkgKyBrMiwgeSArIGs0LCAxLCBpbnRlcnNlY3RZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgaWYgKCFjeiB8fCAgZ29Ub3ApIHRyID0gY2xpcChyaWdodCwgejIsIHkgLSBrMSwgeSArIGszLCAxLCBpbnRlcnNlY3RZKTtcbiAgICAgICAgICAgIGlmICghY3ogfHwgIWdvVG9wKSBiciA9IGNsaXAocmlnaHQsIHoyLCB5ICsgazIsIHkgKyBrNCwgMSwgaW50ZXJzZWN0WSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWVFbmQoJ2NsaXBwaW5nJyk7XG5cbiAgICAgICAgaWYgKHRsKSBzdGFjay5wdXNoKHRsLCB6ICsgMSwgeCAqIDIsICAgICB5ICogMik7XG4gICAgICAgIGlmIChibCkgc3RhY2sucHVzaChibCwgeiArIDEsIHggKiAyLCAgICAgeSAqIDIgKyAxKTtcbiAgICAgICAgaWYgKHRyKSBzdGFjay5wdXNoKHRyLCB6ICsgMSwgeCAqIDIgKyAxLCB5ICogMik7XG4gICAgICAgIGlmIChicikgc3RhY2sucHVzaChiciwgeiArIDEsIHggKiAyICsgMSwgeSAqIDIgKyAxKTtcbiAgICB9XG59O1xuXG5HZW9KU09OVlQucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAoeiwgeCwgeSkge1xuICAgIHZhciBpZCA9IHRvSUQoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZXNbaWRdKSByZXR1cm4gdGhpcy50aWxlc1tpZF07XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS5sb2coJ2RyaWxsaW5nIGRvd24gdG8geiVkLSVkLSVkJywgeiwgeCwgeSk7XG5cbiAgICB2YXIgejAgPSB6LFxuICAgICAgICB4MCA9IHgsXG4gICAgICAgIHkwID0geSxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgd2hpbGUgKCFwYXJlbnQgJiYgejAgPiAwKSB7XG4gICAgICAgIHowLS07XG4gICAgICAgIHgwID0gTWF0aC5mbG9vcih4MCAvIDIpO1xuICAgICAgICB5MCA9IE1hdGguZmxvb3IoeTAgLyAyKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aWxlc1t0b0lEKHowLCB4MCwgeTApXTtcbiAgICB9XG5cbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLmxvZygnZm91bmQgcGFyZW50IHRpbGUgeiVkLSVkLSVkJywgejAsIHgwLCB5MCk7XG5cbiAgICAvLyBpZiB3ZSBmb3VuZCBhIHBhcmVudCB0aWxlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGdlb21ldHJ5LCB3ZSBjYW4gZHJpbGwgZG93biBmcm9tIGl0XG4gICAgaWYgKHBhcmVudC5zb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzQ2xpcHBlZFNxdWFyZShwYXJlbnQuZmVhdHVyZXMsIG9wdGlvbnMuZXh0ZW50LCBvcHRpb25zLmJ1ZmZlcikpIHJldHVybiBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKGRlYnVnKSBjb25zb2xlLnRpbWUoJ2RyaWxsaW5nIGRvd24nKTtcbiAgICAgICAgdGhpcy5zcGxpdFRpbGUocGFyZW50LnNvdXJjZSwgejAsIHgwLCB5MCwgeiwgeCwgeSk7XG4gICAgICAgIGlmIChkZWJ1ZykgY29uc29sZS50aW1lRW5kKCdkcmlsbGluZyBkb3duJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGlsZXNbaWRdO1xufTtcblxuLy8gY2hlY2tzIHdoZXRoZXIgYSB0aWxlIGlzIGEgd2hvbGUtYXJlYSBmaWxsIGFmdGVyIGNsaXBwaW5nOyBpZiBpdCBpcywgdGhlcmUncyBubyBzZW5zZSBzbGljaW5nIGl0IGZ1cnRoZXJcbmZ1bmN0aW9uIGlzQ2xpcHBlZFNxdWFyZShmZWF0dXJlcywgZXh0ZW50LCBidWZmZXIpIHtcbiAgICBpZiAoZmVhdHVyZXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzWzBdO1xuICAgIGlmIChmZWF0dXJlLnR5cGUgIT09IDMgfHwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmUuZ2VvbWV0cnlbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBmZWF0dXJlLmdlb21ldHJ5WzBdW2ldO1xuICAgICAgICBpZiAoKHBbMF0gIT09IC1idWZmZXIgJiYgcFswXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSB8fFxuICAgICAgICAgICAgKHBbMV0gIT09IC1idWZmZXIgJiYgcFsxXSAhPT0gZXh0ZW50ICsgYnVmZmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdG9JRCh6LCB4LCB5KSB7XG4gICAgcmV0dXJuICgoKDEgPDwgeikgKiB5ICsgeCkgKiAzMikgKyB6O1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RYKGEsIGIsIHgpIHtcbiAgICByZXR1cm4gW3gsICh4IC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pIC8gKGJbMF0gLSBhWzBdKSArIGFbMV0sIDFdO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0WShhLCBiLCB5KSB7XG4gICAgcmV0dXJuIFsoeSAtIGFbMV0pICogKGJbMF0gLSBhWzBdKSAvIChiWzFdIC0gYVsxXSkgKyBhWzBdLCB5LCAxXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSBkZXN0W2ldID0gc3JjW2ldO1xuICAgIHJldHVybiBkZXN0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuXG4vLyBjYWxjdWxhdGUgc2ltcGxpZmljYXRpb24gZGF0YSB1c2luZyBvcHRpbWl6ZWQgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxuXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IDAsXG4gICAgICAgIGxhc3QgPSBsZW4gLSAxLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBpLCBtYXhTcURpc3QsIHNxRGlzdCwgaW5kZXg7XG5cbiAgICAvLyBhbHdheXMgcmV0YWluIHRoZSBlbmRwb2ludHMgKDEgaXMgdGhlIG1heCB2YWx1ZSlcbiAgICBwb2ludHNbZmlyc3RdWzJdID0gMTtcbiAgICBwb2ludHNbbGFzdF1bMl0gPSAxO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgc3RhY2tcbiAgICB3aGlsZSAobGFzdCkge1xuXG4gICAgICAgIG1heFNxRGlzdCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgICAgICBpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcG9pbnRzW2luZGV4XVsyXSA9IG1heFNxRGlzdDsgLy8gc2F2ZSB0aGUgcG9pbnQgaW1wb3J0YW5jZSBpbiBzcXVhcmVkIHBpeGVscyBhcyBhIHogY29vcmRpbmF0ZVxuICAgICAgICAgICAgc3RhY2sucHVzaChmaXJzdCwgaW5kZXgsIGluZGV4LCBsYXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgZmlyc3QgPSBzdGFjay5wb3AoKTtcbiAgICB9XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgYSwgYikge1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sXG4gICAgICAgIHB4ID0gcFswXSwgcHkgPSBwWzFdLFxuICAgICAgICBkeCA9IGJ4IC0geCxcbiAgICAgICAgZHkgPSBieSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocHggLSB4KSAqIGR4ICsgKHB5IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IGJ4O1xuICAgICAgICAgICAgeSA9IGJ5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHB4IC0geDtcbiAgICBkeSA9IHB5IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaWxlO1xuXG5mdW5jdGlvbiBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgdHgsIHR5LCB0b2xlcmFuY2UsIGV4dGVudCwgbm9TaW1wbGlmeSkge1xuICAgIHZhciB0aWxlID0ge1xuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIG51bVBvaW50czogMCxcbiAgICAgICAgbnVtU2ltcGxpZmllZDogMCxcbiAgICAgICAgbnVtRmVhdHVyZXM6IDAsXG4gICAgICAgIHNvdXJjZTogbnVsbFxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aWxlLm51bUZlYXR1cmVzKys7XG4gICAgICAgIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZXNbaV0sIHoyLCB0eCwgdHksIHRvbGVyYW5jZSwgZXh0ZW50LCBub1NpbXBsaWZ5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGU7XG59XG5cbmZ1bmN0aW9uIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZSwgejIsIHR4LCB0eSwgdG9sZXJhbmNlLCBleHRlbnQsIG5vU2ltcGxpZnkpIHtcblxuICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZSxcbiAgICAgICAgdHJhbnNmb3JtZWQgPSBbXSxcbiAgICAgICAgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2UsXG4gICAgICAgIGksIGosIHJpbmcsIHA7XG5cbiAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWQucHVzaCh0cmFuc2Zvcm1Qb2ludChnZW9tW2ldLCB6MiwgdHgsIHR5LCBleHRlbnQpKTtcbiAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB0aWxlLm51bVNpbXBsaWZpZWQrKztcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBzaW1wbGlmeSBhbmQgdHJhbnNmb3JtIHByb2plY3RlZCBjb29yZGluYXRlcyBmb3IgdGlsZSBnZW9tZXRyeVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmluZyA9IGdlb21baV07XG5cbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdGlueSBwb2x5bGluZXMgJiBwb2x5Z29uc1xuICAgICAgICAgICAgaWYgKCFub1NpbXBsaWZ5ICYmICgodHlwZSA9PT0gMiAmJiByaW5nLmRpc3QgPCB0b2xlcmFuY2UpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09PSAzICYmIHJpbmcuYXJlYSA8IHNxVG9sZXJhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlLm51bVBvaW50cyArPSByaW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUmluZyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHAgPSByaW5nW2pdO1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgcG9pbnRzIHdpdGggaW1wb3J0YW5jZSA+IHRvbGVyYW5jZVxuICAgICAgICAgICAgICAgIGlmIChub1NpbXBsaWZ5IHx8IHBbMl0gPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFJpbmcucHVzaCh0cmFuc2Zvcm1Qb2ludChwLCB6MiwgdHgsIHR5LCBleHRlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbGUubnVtUG9pbnRzKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLnB1c2godHJhbnNmb3JtZWRSaW5nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm1lZC5sZW5ndGgpIHtcbiAgICAgICAgdGlsZS5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiB0cmFuc2Zvcm1lZCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB0YWdzOiBmZWF0dXJlLnRhZ3MgfHwgbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KHAsIHoyLCB0eCwgdHksIGV4dGVudCkge1xuICAgIHZhciB4ID0gTWF0aC5yb3VuZChleHRlbnQgKiAocFswXSAqIHoyIC0gdHgpKSxcbiAgICAgICAgeSA9IE1hdGgucm91bmQoZXh0ZW50ICogKHBbMV0gKiB6MiAtIHR5KSk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbn1cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMi4xXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cblxuKGZ1bmN0aW9uKF9nbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIHNoaW0gPSB7fTtcbiAgaWYgKHR5cGVvZihleHBvcnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZih0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgc2hpbS5leHBvcnRzID0ge307XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzaGltLmV4cG9ydHM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2wtbWF0cml4IGxpdmVzIGluIGEgYnJvd3NlciwgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGdsb2JhbFxuICAgICAgc2hpbS5leHBvcnRzID0gdHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogX2dsb2JhbDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2wtbWF0cml4IGxpdmVzIGluIGNvbW1vbmpzLCBkZWZpbmUgaXRzIG5hbWVzcGFjZXMgaW4gZXhwb3J0c1xuICAgIHNoaW0uZXhwb3J0cyA9IGV4cG9ydHM7XG4gIH1cblxuICAoZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIC8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cblxuaWYoIUdMTUFUX0VQU0lMT04pIHtcbiAgICB2YXIgR0xNQVRfRVBTSUxPTiA9IDAuMDAwMDAxO1xufVxuXG5pZighR0xNQVRfQVJSQVlfVFlQRSkge1xuICAgIHZhciBHTE1BVF9BUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xufVxuXG5pZighR0xNQVRfUkFORE9NKSB7XG4gICAgdmFyIEdMTUFUX1JBTkRPTSA9IE1hdGgucmFuZG9tO1xufVxuXG4vKipcbiAqIEBjbGFzcyBDb21tb24gdXRpbGl0aWVzXG4gKiBAbmFtZSBnbE1hdHJpeFxuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljaWVzXG4gKlxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XG4gKi9cbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBHTE1BVF9BUlJBWV9UWVBFID0gdHlwZTtcbn1cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuZ2xNYXRyaXggPSBnbE1hdHJpeDtcbn1cblxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG5cbi8qKlxuKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cbipcbiogQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIGluIERlZ3JlZXNcbiovXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xuICAgICByZXR1cm4gYSAqIGRlZ3JlZTtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cblxudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc2NhbGVBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXN0ID0gdmVjMi5kaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuc3F1YXJlZERpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3FyRGlzdCA9IHZlYzIuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLmxlbiA9IHZlYzIubGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckxlbiA9IHZlYzIuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzIuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICogTm90ZSB0aGF0IHRoZSBjcm9zcyBwcm9kdWN0IG11c3QgYnkgZGVmaW5pdGlvbiBwcm9kdWNlIGEgM0QgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICAgIG91dFswXSA9IG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAndmVjMignICsgYVswXSArICcsICcgKyBhWzFdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjMiA9IHZlYzI7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAzIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjM1xuICovXG5cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzMuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIHZhciByID0gR0xNQVRfUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciB6ID0gKEdMTUFUX1JBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZTtcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXTtcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLypcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4qIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiogQHJldHVybnMge3ZlYzN9IG91dFxuKi9cbnZlYzMucm90YXRlWCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gICB2YXIgcCA9IFtdLCByPVtdO1xuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblx0ICBwWzBdID0gYVswXSAtIGJbMF07XG5cdCAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuXHQgIC8vcGVyZm9ybSByb3RhdGlvblxuXHQgIHJbMF0gPSBwWzBdO1xuXHQgIHJbMV0gPSBwWzFdKk1hdGguY29zKGMpIC0gcFsyXSpNYXRoLnNpbihjKTtcblx0ICByWzJdID0gcFsxXSpNYXRoLnNpbihjKSArIHBbMl0qTWF0aC5jb3MoYyk7XG5cblx0ICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cdCAgb3V0WzBdID0gclswXSArIGJbMF07XG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XG5cdCAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgXHRyZXR1cm4gb3V0O1xufTtcblxuLypcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4qIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiogQHJldHVybnMge3ZlYzN9IG91dFxuKi9cbnZlYzMucm90YXRlWSA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgYyl7XG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcbiAgXHQvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIFx0cFswXSA9IGFbMF0gLSBiWzBdO1xuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgXHRwWzJdID0gYVsyXSAtIGJbMl07XG4gIFxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxuICBcdHJbMF0gPSBwWzJdKk1hdGguc2luKGMpICsgcFswXSpNYXRoLmNvcyhjKTtcbiAgXHRyWzFdID0gcFsxXTtcbiAgXHRyWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG4gIFxuICBcdC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgXHRvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgXHRvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgXG4gIFx0cmV0dXJuIG91dDtcbn07XG5cbi8qXG4qIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMudmVjMyA9IHZlYzM7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG5cbnZhciB2ZWM0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3ViID0gdmVjNC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5tdWwgPSB2ZWM0Lm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGl2ID0gdmVjNC5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgICAgIG91dFszXSA9IGFbM10gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjNC5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXSxcbiAgICAgICAgYXcgPSBhWzNdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICAgIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcblxuICAgIC8vVE9ETzogVGhpcyBpcyBhIHByZXR0eSBhd2Z1bCB3YXkgb2YgZG9pbmcgdGhpcy4gRmluZCBzb21ldGhpbmcgYmV0dGVyLlxuICAgIG91dFswXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIG91dFsxXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIG91dFsyXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIG91dFszXSA9IEdMTUFUX1JBTkRPTSgpO1xuICAgIHZlYzQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB2ZWM0LnNjYWxlKG91dCwgb3V0LCBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLCB3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICAgIG91dFsyXSA9IG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSAqIHc7XG4gICAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWM0ID0gdmVjNDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xuXG52YXIgbWF0MiA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDIgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTEgPSBhWzFdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzJdO1xuICAgICAgICBvdXRbMl0gPSBhWzFdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgIG91dFswXSA9ICBhMyAqIGRldDtcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWEyICogZGV0O1xuICAgIG91dFszXSA9ICBhMCAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICAgIHZhciBhMCA9IGFbMF07XG4gICAgb3V0WzBdID0gIGFbM107XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gIGEwO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDIuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xuICAgIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MDtcbiAgICBvdXRbMl0gPSBhMiAqIHYxO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQyID0gbWF0Mjtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDJ4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDJkXG4gKiBcbiAqIEBkZXNjcmlwdGlvbiBcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5XVxuICogPC9wcmU+XG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XG4gKiA8cHJlPlxuICogW2EsIGMsIHR4LFxuICogIGIsIGQsIHR5LFxuICogIDAsIDAsIDFdXG4gKiA8L3ByZT5cbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXG4gKi9cblxudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhYSA9IGFbMF0sIGFiID0gYVsxXSwgYWMgPSBhWzJdLCBhZCA9IGFbM10sXG4gICAgICAgIGF0eCA9IGFbNF0sIGF0eSA9IGFbNV07XG5cbiAgICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG4gICAgaWYoIWRldCl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgIG91dFszXSA9IGFhICogZGV0O1xuICAgIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0MmQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0MmQubXVsID0gbWF0MmQubXVsdGlwbHk7XG5cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5tYXQyZCA9IG1hdDJkO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgM3gzIE1hdHJpeFxuICogQG5hbWUgbWF0M1xuICovXG5cbnZhciBtYXQzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29waWVzIHRoZSB1cHBlci1sZWZ0IDN4MyB2YWx1ZXMgaW50byB0aGUgZ2l2ZW4gbWF0My5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSAgIHRoZSBzb3VyY2UgNHg0IG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVs0XTtcbiAgICBvdXRbNF0gPSBhWzVdO1xuICAgIG91dFs1XSA9IGFbNl07XG4gICAgb3V0WzZdID0gYVs4XTtcbiAgICBvdXRbN10gPSBhWzldO1xuICAgIG91dFs4XSA9IGFbMTBdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuZnJvbU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSBhWzJdO1xuICAgIG91dFs0XSA9IGFbM107XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IGFbNF07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFszXSA9IHl4IC0gd3o7XG4gICAgb3V0WzZdID0genggKyB3eTtcblxuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzddID0genkgLSB3eDtcblxuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzVdID0genkgKyB3eDtcbiAgICBvdXRbOF0gPSAxIC0geHggLSB5eTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7bWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLm5vcm1hbEZyb21NYXQ0ID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcblxuICAgIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArIGFbOF0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQzLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpKSlcbn07XG5cblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MyA9IG1hdDM7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyA0eDQgTWF0cml4XG4gKiBAbmFtZSBtYXQ0XG4gKi9cblxudmFyIG1hdDQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5tdWwgPSBtYXQ0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgR0xNQVRfRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgR0xNQVRfRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBHTE1BVF9FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IEdMTUFUX0VQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSArIE1hdGgucG93KGFbOV0sIDIpICsgTWF0aC5wb3coYVsxMF0sIDIpICsgTWF0aC5wb3coYVsxMV0sIDIpICsgTWF0aC5wb3coYVsxMl0sIDIpICsgTWF0aC5wb3coYVsxM10sIDIpICsgTWF0aC5wb3coYVsxNF0sIDIpICsgTWF0aC5wb3coYVsxNV0sIDIpICkpXG59O1xuXG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDQgPSBtYXQ0O1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG5cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICAgICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICAgICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgICAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgICAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgICAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IC1NYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzddLW1bNV0pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVsyXS1tWzZdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bM10tbVsxXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1bayozK2pdIC0gbVtqKjMra10pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5xdWF0ID0gcXVhdDtcbn1cbjtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuICB9KShzaGltLmV4cG9ydHMpO1xufSkodGhpcyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiLCB0KSB7XG4gICAgcmV0dXJuIChhICogKDEgLSB0KSkgKyAoYiAqIHQpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KGEsIGIsIHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IGludGVycG9sYXRlTnVtYmVyKGFbaV0sIGJbaV0sIHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzWydpbnRlcnBvbGF0ZWQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIWYuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50KGYpO1xuICAgIH1cblxuICAgIHZhciBzdG9wcyA9IGYuc3RvcHMsXG4gICAgICAgIGJhc2UgPSBmLmJhc2UgfHwgMSxcbiAgICAgICAgaW50ZXJwb2xhdGUgPSBBcnJheS5pc0FycmF5KHN0b3BzWzBdWzFdKSA/IGludGVycG9sYXRlQXJyYXkgOiBpbnRlcnBvbGF0ZU51bWJlcjtcblxuICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIHR3byBzdG9wcyB3aGljaCB0aGUgY3VycmVudCB6IGlzIGJldHdlZW5cbiAgICAgICAgdmFyIGxvdywgaGlnaDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXG4gICAgICAgICAgICBpZiAoc3RvcFswXSA8PSB6KSB7XG4gICAgICAgICAgICAgICAgbG93ID0gc3RvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0b3BbMF0gPiB6KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IHN0b3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG93ICYmIGhpZ2gpIHtcbiAgICAgICAgICAgIHZhciB6b29tRGlmZiA9IGhpZ2hbMF0gLSBsb3dbMF0sXG4gICAgICAgICAgICAgICAgem9vbVByb2dyZXNzID0geiAtIGxvd1swXSxcblxuICAgICAgICAgICAgICAgIHQgPSBiYXNlID09PSAxID9cbiAgICAgICAgICAgICAgICB6b29tUHJvZ3Jlc3MgLyB6b29tRGlmZiA6XG4gICAgICAgICAgICAgICAgKE1hdGgucG93KGJhc2UsIHpvb21Qcm9ncmVzcykgLSAxKSAvIChNYXRoLnBvdyhiYXNlLCB6b29tRGlmZikgLSAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGxvd1sxXSwgaGlnaFsxXSwgdCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBsb3dbMV07XG5cbiAgICAgICAgfSBlbHNlIGlmIChoaWdoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaFsxXTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5leHBvcnRzWydwaWVjZXdpc2UtY29uc3RhbnQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICBpZiAoIWYuc3RvcHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50KGYpO1xuICAgIH1cblxuICAgIHZhciBzdG9wcyA9IGYuc3RvcHM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RvcHNbaV1bMF0gPiB6KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3BzW2kgPT09IDAgPyAwIDogaSAtIDFdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdWzFdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWZlcmVuY2UgPSByZXF1aXJlKCcuLi8uLi9yZWZlcmVuY2UvbGF0ZXN0LmpzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3BhcnNlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHN0eWxlLCByZWZlcmVuY2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlQ1NTQ29sb3IgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG52YXIgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSwgcmVmZXJlbmNlKSB7XG5cbiAgICB2YXIgY29uc3RhbnRzID0gc3R5bGUuY29uc3RhbnRzIHx8IHt9LFxuICAgICAgICBsYXllcnMgPSB7fSxcbiAgICAgICAgZXJyb3JzID0gW107XG5cbiAgICBmdW5jdGlvbiBlcnJvcihrZXksIHZhbCAvKiwgbWVzc2FnZSwgLi4uKi8pIHtcbiAgICAgICAgdmFyIGVyciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IChrZXkgPyBrZXkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgIGZvcm1hdC5hcHBseShmb3JtYXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwuX19saW5lX18pIHtcbiAgICAgICAgICAgIGVyci5saW5lID0gdmFsLl9fbGluZV9fO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICB9XG5cbiAgICAvLyBNYWluIHJlY3Vyc2l2ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBUcmFja3M6XG4gICAgLy9cbiAgICAvLyAtIGtleTogc3RyaW5nIHJlcHJlc2VudGluZyBsb2NhdGlvbiBvZiB2YWxpZGF0aW9uIGluIHN0eWxlIHRyZWUuIFVzZWQgb25seVxuICAgIC8vICAgZm9yIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgcmVwb3J0aW5nLlxuICAgIC8vIC0gdmFsOiBjdXJyZW50IHZhbHVlIGZyb20gc3R5bGUgYmVpbmcgZXZhbHVhdGVkLiBNYXkgYmUgYW55dGhpbmcgZnJvbSBhXG4gICAgLy8gICBoaWdoIGxldmVsIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGRlc2NlbmRlZCBpbnRvIGRlZXBlciBvciBhIHNpbXBsZVxuICAgIC8vICAgc2NhbGFyIHZhbHVlLlxuICAgIC8vIC0gc3BlYzogY3VycmVudCBzcGVjIGJlaW5nIGV2YWx1YXRlZC4gVHJhY2tzIHZhbC5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuXG4gICAgICAgIC8vIENvbnN0YW50c1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgIGlmICghKHZhbCBpbiBjb25zdGFudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnY29uc3RhbnQgXCIlc1wiIG5vdCBmb3VuZCcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWwgPSBjb25zdGFudHNbdmFsXTtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlb2ZfKHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGdW5jdGlvbnNcbiAgICAgICAgaWYgKHNwZWMuZnVuY3Rpb24gJiYgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZS5mdW5jdGlvbihrZXksIHZhbCwgc3BlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlYy50eXBlKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gdmFsaWRhdGVbc3BlYy50eXBlXTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yKGtleSwgdmFsLCBzcGVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMgPSByZWZlcmVuY2Vbc3BlYy50eXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgc3BlYyk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGUuY29uc3RhbnRzID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2ZfKHZhbCk7XG4gICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHtcbiAgICAgICAgICAgIGlmIChrWzBdICE9PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnLicgKyBrLCB2YWxba10sICdjb25zdGFudHMgbXVzdCBzdGFydCB3aXRoIFwiQFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuc291cmNlID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwudHlwZSkge1xuICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWwudHlwZSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAndmVjdG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3Jhc3Rlcic6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2Uuc291cmNlX3RpbGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCd1cmwnIGluIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFsndHlwZScsICd1cmwnLCAndGlsZVNpemUnXS5pbmRleE9mKHByb3ApIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSArICcuJyArIHByb3AsIHZhbFtwcm9wXSwgJ2Egc291cmNlIHdpdGggYSBcInVybFwiIHByb3BlcnR5IG1heSBub3QgaW5jbHVkZSBhIFwiJXNcIiBwcm9wZXJ0eScsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnZW9qc29uJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZS5vYmplY3Qoa2V5LCB2YWwsIHJlZmVyZW5jZS5zb3VyY2VfZ2VvanNvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUub2JqZWN0KGtleSwgdmFsLCByZWZlcmVuY2Uuc291cmNlX3ZpZGVvKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnLnR5cGUnLCB2YWwudHlwZSwge3ZhbHVlczogWyd2ZWN0b3InLCAncmFzdGVyJywgJ2dlb2pzb24nLCAndmlkZW8nXX0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhbGlkYXRlLmxheWVyID0gZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwudHlwZSAmJiAhdmFsLnJlZikge1xuICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdlaXRoZXIgXCJ0eXBlXCIgb3IgXCJyZWZcIiBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWwudHlwZSksXG4gICAgICAgICAgICByZWYgPSB1bmJ1bmRsZSh2YWwucmVmKTtcblxuICAgICAgICBpZiAodmFsLmlkKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXJzW3ZhbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbC5pZCwgJ2R1cGxpY2F0ZSBsYXllciBpZCBcIiVzXCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lICVkJywgdmFsLmlkLCBsYXllcnNbdmFsLmlkXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyc1t2YWwuaWRdID0gdmFsLmlkLl9fbGluZV9fO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdyZWYnIGluIHZhbCkge1xuICAgICAgICAgICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnZmlsdGVyJywgJ2xheW91dCddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWxbcF0sICdcIiVzXCIgaXMgcHJvaGliaXRlZCBmb3IgcmVmIGxheWVycycsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50O1xuXG4gICAgICAgICAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5pZCA9PSByZWYpIHBhcmVudCA9IGxheWVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwucmVmLCAncmVmIGxheWVyIFwiJXNcIiBub3QgZm91bmQnLCByZWYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQucmVmKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwucmVmLCAncmVmIGNhbm5vdCByZWZlcmVuY2UgYW5vdGhlciByZWYgbGF5ZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgaWYgKCF2YWwuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHN0eWxlLnNvdXJjZXNbdmFsLnNvdXJjZV07XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwuc291cmNlLCAnc291cmNlIFwiJXNcIiBub3QgZm91bmQnLCB2YWwuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS50eXBlID09ICd2ZWN0b3InICYmIHR5cGUgPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwuc291cmNlLCAnbGF5ZXIgXCIlc1wiIHJlcXVpcmVzIGEgcmFzdGVyIHNvdXJjZScsIHZhbC5pZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PSAncmFzdGVyJyAmJiB0eXBlICE9ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLnNvdXJjZSwgJ2xheWVyIFwiJXNcIiByZXF1aXJlcyBhIHZlY3RvciBzb3VyY2UnLCB2YWwuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLmxheWVyLCB7XG4gICAgICAgICAgICBmaWx0ZXI6IHZhbGlkYXRlLmZpbHRlcixcbiAgICAgICAgICAgIGxheW91dDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IHJlZmVyZW5jZVsnbGF5b3V0XycgKyB0eXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSAmJiBzcGVjICYmIHZhbGlkYXRlKGtleSwgdmFsLCBzcGVjKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWludDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IHJlZmVyZW5jZVsncGFpbnRfJyArIHR5cGVdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlICYmIHNwZWMgJiYgdmFsaWRhdGUoa2V5LCB2YWwsIHNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdGUub2JqZWN0ID0gZnVuY3Rpb24gKGtleSwgdmFsLCBzcGVjLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IHt9O1xuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ29iamVjdCBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSB7XG4gICAgICAgICAgICB2YXIgc3BlY2tleSA9IGsuc3BsaXQoJy4nKVswXTsgLy8gdHJlYXQgJ3BhaW50LionIGFzICdwYWludCdcbiAgICAgICAgICAgIHZhciBkZWYgPSBzcGVjW3NwZWNrZXldIHx8IHNwZWNbJyonXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gc3BlY2tleS5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcblxuICAgICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgICAgICh2YWxpZGF0b3JzW3NwZWNrZXldIHx8IHZhbGlkYXRlKSgoa2V5ID8ga2V5ICsgJy4nIDoga2V5KSArIGssIHZhbFtrXSwgZGVmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiAmJiBzcGVjW3RyYW5zaXRpb25bMV1dICYmIHNwZWNbdHJhbnNpdGlvblsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlKChrZXkgPyBrZXkgKyAnLicgOiBrZXkpICsgaywgdmFsW2tdLCByZWZlcmVuY2UudHJhbnNpdGlvbik7XG4gICAgICAgICAgICAvLyB0b2xlcmF0ZSByb290LWxldmVsIGV4dHJhIGtleXMgJiBhcmJpdHJhcnkgbGF5ZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleS5zcGxpdCgnLicpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsW2tdLCAndW5rbm93biBwcm9wZXJ0eSBcIiVzXCInLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGwgaW4gc3BlYykge1xuICAgICAgICAgICAgaWYgKHNwZWNbbF0ucmVxdWlyZWQgJiYgc3BlY1tsXVsnZGVmYXVsdCddID09PSB1bmRlZmluZWQgJiYgdmFsW2xdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCIlc1wiJywgbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuYXJyYXkgPSBmdW5jdGlvbiAoa2V5LCB2YWwsIHNwZWMsIHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodHlwZW9mXyh2YWwpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlb2ZfKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWMubGVuZ3RoICYmIHZhbC5sZW5ndGggIT09IHNwZWMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBsZW5ndGggJWQgZXhwZWN0ZWQsIGxlbmd0aCAlZCBmb3VuZCcsIHNwZWMubGVuZ3RoLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBzcGVjLnZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0eWxlLnZlcnNpb24gPCA3KSB7XG4gICAgICAgICAgICB2YWx1ZS5mdW5jdGlvbiA9IHNwZWMuZnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mXyhzcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3BlYy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAodmFsaWRhdG9yIHx8IHZhbGlkYXRlKShrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5maWx0ZXIgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAodHlwZW9mXyh2YWwpICE9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdhcnJheSBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlb2ZfKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3Ioa2V5LCB2YWwsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnWzBdJywgdmFsWzBdLCByZWZlcmVuY2UuZmlsdGVyX29wZXJhdG9yKTtcblxuICAgICAgICBzd2l0Y2ggKHVuYnVuZGxlKHZhbFswXSkpIHtcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gMiAmJiB2YWxbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ1wiJHR5cGVcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXCIlc1wiJywgdmFsWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggIT0gMykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ2ZpbHRlciBhcnJheSBmb3Igb3BlcmF0b3IgXCIlc1wiIG11c3QgaGF2ZSAzIGVsZW1lbnRzJywgdmFsWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgICBjYXNlICchaW4nOlxuICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGVvZl8odmFsWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzFdJywgdmFsWzFdLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbFsxXVswXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzFdJywgdmFsWzFdLCAnZmlsdGVyIGtleSBjYW5ub3QgYmUgYSBjb25zdGFudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2ZfKHZhbFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUuZW51bShrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sIHJlZmVyZW5jZS5nZW9tZXRyeV90eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWxbaV1bMF0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJ1snICsgaSArICddJywgdmFsW2ldLCAnZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBhIGNvbnN0YW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0sICdzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYW55JzpcbiAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlLmZpbHRlcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5mdW5jdGlvbiA9IGZ1bmN0aW9uKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgIHZhbGlkYXRlLm9iamVjdChrZXksIHZhbCwgcmVmZXJlbmNlLmZ1bmN0aW9uLCB7XG4gICAgICAgICAgICBzdG9wczogZnVuY3Rpb24gKGtleSwgdmFsLCBhcnJheVNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFN0b3AgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUuYXJyYXkoa2V5LCB2YWwsIGFycmF5U3BlYywgZnVuY3Rpb24gdmFsaWRhdGVTdG9wKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2ZfKHZhbCkgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcihrZXksIHZhbCwgJ2FycmF5IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGVvZl8odmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGtleSwgdmFsLCAnYXJyYXkgbGVuZ3RoICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCAyLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGtleSArICdbMF0nLCB2YWxbMF0sIHt0eXBlOiAnbnVtYmVyJ30pO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShrZXkgKyAnWzFdJywgdmFsWzFdLCBzcGVjKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mXyh2YWxbMF0pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWMuZnVuY3Rpb24gPT09ICdwaWVjZXdpc2UtY29uc3RhbnQnICYmIHZhbFswXSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihrZXkgKyAnWzBdJywgdmFsWzBdLCAnem9vbSBsZXZlbCBmb3IgcGllY2V3aXNlLWNvbnN0YW50IGZ1bmN0aW9ucyBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFswXSA8IGxhc3RTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Ioa2V5ICsgJ1swXScsIHZhbFswXSwgJ2FycmF5IHN0b3BzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U3RvcCA9IHZhbFswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZl8odmFsKSA9PT0gJ2FycmF5JyAmJiB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFsaWRhdGUuZW51bSA9IGZ1bmN0aW9uIChrZXksIHZhbCwgc3BlYykge1xuICAgICAgICBpZiAoc3BlYy52YWx1ZXMuaW5kZXhPZih1bmJ1bmRsZSh2YWwpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnZXhwZWN0ZWQgb25lIG9mIFslc10sICVzIGZvdW5kJywgc3BlYy52YWx1ZXMuam9pbignLCAnKSwgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YWxpZGF0ZS5jb2xvciA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yKGtleSwgdmFsLCAnY29sb3IgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyc2VDU1NDb2xvcih2YWwpID09PSBudWxsKSB7XG4gICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJ2NvbG9yIGV4cGVjdGVkLCBcIiVzXCIgZm91bmQnLCB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHR5cGVWYWxpZGF0b3IoZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsLCBzcGVjKSB7XG4gICAgICAgICAgICB2YXIgYWN0dWFsID0gdHlwZW9mXyh2YWwpO1xuICAgICAgICAgICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJyVzIGV4cGVjdGVkLCAlcyBmb3VuZCcsIGV4cGVjdGVkLCBhY3R1YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJ21pbmltdW0nIGluIHNwZWMgJiYgdmFsIDwgc3BlYy5taW5pbXVtKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Ioa2V5LCB2YWwsICclcyBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gdmFsdWUgJXMnLCB2YWwsIHNwZWMubWluaW11bSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnbWF4aW11bScgaW4gc3BlYyAmJiB2YWwgPiBzcGVjLm1heGltdW0pIHtcbiAgICAgICAgICAgICAgICBlcnJvcihrZXksIHZhbCwgJyVzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSAlcycsIHZhbCwgc3BlYy5tYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZS5udW1iZXIgPSB0eXBlVmFsaWRhdG9yKCdudW1iZXInKTtcbiAgICB2YWxpZGF0ZS5zdHJpbmcgPSB0eXBlVmFsaWRhdG9yKCdzdHJpbmcnKTtcbiAgICB2YWxpZGF0ZS5ib29sZWFuID0gdHlwZVZhbGlkYXRvcignYm9vbGVhbicpO1xuXG4gICAgdmFsaWRhdGVbJyonXSA9IGZ1bmN0aW9uKCkge307XG5cbiAgICB2YWxpZGF0ZSgnJywgc3R5bGUsIHJlZmVyZW5jZS4kcm9vdCk7XG5cbiAgICByZXR1cm4gZXJyb3JzO1xufTtcblxuZnVuY3Rpb24gdHlwZW9mXyh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTnVtYmVyKVxuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZylcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKVxuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIGlmICh2YWwgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG59XG5cbmZ1bmN0aW9uIHVuYnVuZGxlKF8pIHtcbiAgICBpZiAoXyBpbnN0YW5jZW9mIE51bWJlciB8fFxuICAgICAgICBfIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgIF8gaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiBfLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXztcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdjcuanNvbicpO1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiR2ZXJzaW9uXCI6IDcsXG4gIFwiJHJvb3RcIjoge1xuICAgIFwidmVyc2lvblwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIDdcbiAgICAgIF0sXG4gICAgICBcImRvY1wiOiBcIlN0eWxlc2hlZXQgdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgNy5cIlxuICAgIH0sXG4gICAgXCJuYW1lXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS5cIlxuICAgIH0sXG4gICAgXCJjb25zdGFudHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29uc3RhbnRzXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIG9iamVjdCBvZiBjb25zdGFudHMgdG8gYmUgcmVmZXJlbmNlZCBpbiBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwic291cmNlc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJzb3VyY2VzXCIsXG4gICAgICBcImRvY1wiOiBcIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zLlwiXG4gICAgfSxcbiAgICBcInNwcml0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBiYXNlIFVSTCBmb3IgcmV0cmlldmluZyB0aGUgc3ByaXRlIGltYWdlIGFuZCBtZXRhZGF0YS4gVGhlIGV4dGVuc2lvbnMgYC5wbmdgLCBgLmpzb25gIGFuZCBzY2FsZSBmYWN0b3IgYEAyeC5wbmdgIHdpbGwgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZC5cIlxuICAgIH0sXG4gICAgXCJnbHlwaHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIkEgVVJMIHRlbXBsYXRlIGZvciBsb2FkaW5nIHNpZ25lZC1kaXN0YW5jZS1maWVsZCBnbHlwaCBzZXRzIGluIFBCRiBmb3JtYXQuIFZhbGlkIHRva2VucyBhcmUge2ZvbnRzdGFja30gYW5kIHtyYW5nZX0uXCJcbiAgICB9LFxuICAgIFwidHJhbnNpdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJ0cmFuc2l0aW9uXCIsXG4gICAgICBcImRvY1wiOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLlwiXG4gICAgfSxcbiAgICBcImxheWVyc1wiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImxheWVyXCIsXG4gICAgICBcImRvY1wiOiBcIkxheWVycyB3aWxsIGJlIGRyYXduIGluIHRoZSBvcmRlciBvZiB0aGlzIGFycmF5LlwiXG4gICAgfVxuICB9LFxuICBcImNvbnN0YW50c1wiOiB7XG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBjb25zdGFudCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgdmVyYmF0aW0gaW4gdGhlIHJlZmVyZW5jaW5nIHBsYWNlLiBUaGlzIGNhbiBiZSBhbnl0aGluZywgaW5jbHVkaW5nIG9iamVjdHMgYW5kIGFycmF5cy4gQWxsIHZhcmlhYmxlIG5hbWVzIG11c3QgYmUgcHJlZml4ZWQgd2l0aCBhbiBgQGAgc3ltYm9sLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZXNcIjoge1xuICAgIFwiKlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzb3VyY2VcIixcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWNhdGlvbiBvZiBhIGRhdGEgc291cmNlLiBGb3IgdmVjdG9yIGFuZCByYXN0ZXIgc291cmNlcywgZWl0aGVyIFRpbGVKU09OIG9yIGEgVVJMIHRvIGEgVGlsZUpTT04gbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gYW5kIHZpZGVvIHNvdXJjZXMsIGEgVVJMIG11c3QgYmUgcHJvdmlkZWQuXCJcbiAgICB9XG4gIH0sXG4gIFwic291cmNlXCI6IFtcbiAgICBcInNvdXJjZV90aWxlXCIsXG4gICAgXCJzb3VyY2VfZ2VvanNvblwiLFxuICAgIFwic291cmNlX3ZpZGVvXCJcbiAgXSxcbiAgXCJzb3VyY2VfdGlsZVwiOiB7XG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwicmVxdWlyZWRcIjogdHJ1ZSxcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2ZWN0b3JcIixcbiAgICAgICAgXCJyYXN0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgc291cmNlLlwiXG4gICAgfSxcbiAgICBcInVybFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQSBVUkwgdG8gYSBUaWxlSlNPTiByZXNvdXJjZS4gU3VwcG9ydGVkIHByb3RvY29scyBhcmUgYGh0dHA6YCwgYGh0dHBzOmAsIGFuZCBgbWFwYm94Oi8vPG1hcGlkPmAuXCJcbiAgICB9LFxuICAgIFwidGlsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiQW4gYXJyYXkgb2Ygb25lIG9yIG1vcmUgdGlsZSBzb3VyY2UgVVJMcywgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gICAgfSxcbiAgICBcIm1heHpvb21cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgICBcImRvY1wiOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcbiAgICB9LFxuICAgIFwidGlsZVNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuICAgIH0sXG4gICAgXCIqXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIixcbiAgICAgIFwiZG9jXCI6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG4gICAgfVxuICB9LFxuICBcInNvdXJjZV9nZW9qc29uXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImdlb2pzb25cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIipcIlxuICAgIH1cbiAgfSxcbiAgXCJzb3VyY2VfdmlkZW9cIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlkZW9cIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ1cmxcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZG9jXCI6IFwiVVJMcyB0byB2aWRlbyBjb250ZW50IGluIG9yZGVyIG9mIHByZWZlcnJlZCBmb3JtYXQuXCJcbiAgICB9LFxuICAgIFwiY29vcmRpbmF0ZXNcIjoge1xuICAgICAgXCJyZXF1aXJlZFwiOiB0cnVlLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwibGVuZ3RoXCI6IDQsXG4gICAgICBcInZhbHVlXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcImxheWVyXCI6IHtcbiAgICBcImlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJVbmlxdWUgbGF5ZXIgbmFtZS5cIlxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwibGluZVwiLFxuICAgICAgICBcInN5bWJvbFwiLFxuICAgICAgICBcInJhc3RlclwiLFxuICAgICAgICBcImJhY2tncm91bmRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIlxuICAgIH0sXG4gICAgXCJyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRvY1wiOiBcIlJlZmVyZW5jZXMgYW5vdGhlciBsYXllciB0byBjb3B5IGB0eXBlYCwgYHNvdXJjZWAsIGBzb3VyY2UtbGF5ZXJgLCBgbWluem9vbWAsIGBtYXh6b29tYCwgYGZpbHRlcmAsIGFuZCBgbGF5b3V0YCBwcm9wZXJ0aWVzIGZyb20uIFRoaXMgYWxsb3dzIHRoZSBsYXllcnMgdG8gc2hhcmUgcHJvY2Vzc2luZyBhbmQgYmUgbW9yZSBlZmZpY2llbnQuXCJcbiAgICB9LFxuICAgIFwic291cmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwic291cmNlLWxheWVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkb2NcIjogXCJMYXllciB0byB1c2UgZnJvbSBhIHZlY3RvciB0aWxlIHNvdXJjZS4gUmVxdWlyZWQgaWYgdGhlIHNvdXJjZSBzdXBwb3J0cyBtdWx0aXBsZSBsYXllcnMuXCJcbiAgICB9LFxuICAgIFwibWluem9vbVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDIyLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIG9uIHdoaWNoIHRoZSBsYXllciBnZXRzIHBhcnNlZCBhbmQgYXBwZWFycyBvbi5cIlxuICAgIH0sXG4gICAgXCJtYXh6b29tXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMjIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwiXG4gICAgfSxcbiAgICBcImludGVyYWN0aXZlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZG9jXCI6IFwiRW5hYmxlIHF1ZXJ5aW5nIG9mIGZlYXR1cmUgZGF0YSBmcm9tIHRoaXMgbGF5ZXIgZm9yIGludGVyYWN0aXZpdHkuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZmlsdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImZpbHRlclwiLFxuICAgICAgXCJkb2NcIjogXCJBIGV4cHJlc3Npb24gc3BlY2lmeWluZyBjb25kaXRpb25zIG9uIHNvdXJjZSBmZWF0dXJlcy4gT25seSBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgYXJlIGRpc3BsYXllZC5cIlxuICAgIH0sXG4gICAgXCJsYXlvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGF5b3V0XCIsXG4gICAgICBcImRvY1wiOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcbiAgICB9LFxuICAgIFwicGFpbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gICAgfSxcbiAgICBcInBhaW50LipcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFpbnRcIixcbiAgICAgIFwiZG9jXCI6IFwiQ2xhc3Mtc3BlY2lmaWMgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci4gVGhlIGNsYXNzIG5hbWUgaXMgdGhlIHBhcnQgYWZ0ZXIgdGhlIGZpcnN0IGRvdC5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRcIjogW1xuICAgIFwibGF5b3V0X2ZpbGxcIixcbiAgICBcImxheW91dF9saW5lXCIsXG4gICAgXCJsYXlvdXRfc3ltYm9sXCIsXG4gICAgXCJsYXlvdXRfcmFzdGVyXCIsXG4gICAgXCJsYXlvdXRfYmFja2dyb3VuZFwiXG4gIF0sXG4gIFwibGF5b3V0X2JhY2tncm91bmRcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2ZpbGxcIjoge1xuICAgIFwidmlzaWJpbGl0eVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwidmlzaWJsZVwiLFxuICAgICAgICBcIm5vbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwibGF5b3V0X2xpbmVcIjoge1xuICAgIFwibGluZS1jYXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcImJ1dHRcIixcbiAgICAgICAgXCJyb3VuZFwiLFxuICAgICAgICBcInNxdWFyZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiYnV0dFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiBsaW5lIGVuZGluZ3MuXCJcbiAgICB9LFxuICAgIFwibGluZS1qb2luXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJiZXZlbFwiLFxuICAgICAgICBcInJvdW5kXCIsXG4gICAgICAgIFwibWl0ZXJcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1pdGVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIGxpbmVzIHdoZW4gam9pbmluZy5cIlxuICAgIH0sXG4gICAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IG1pdGVyIGpvaW5zIHRvIGJldmVsIGpvaW5zIGZvciBzaGFycCBhbmdsZXMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwibGluZS1qb2luXCI6IFwibWl0ZXJcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtcm91bmQtbGltaXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgcm91bmQgam9pbnMgdG8gbWl0ZXIgam9pbnMgZm9yIHNoYWxsb3cgYW5nbGVzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImxpbmUtam9pblwiOiBcInJvdW5kXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfc3ltYm9sXCI6IHtcbiAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICAgIFwicG9pbnRcIixcbiAgICAgICAgICBcImxpbmVcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInBvaW50XCIsXG4gICAgICBcImRvY1wiOiBcIkxhYmVsIHBsYWNlbWVudCByZWxhdGl2ZSB0byBpdHMgZ2VvbWV0cnkuIGBsaW5lYCBjYW4gb25seSBiZSB1c2VkIG9uIExpbmVTdHJpbmdzIGFuZCBQb2x5Z29ucy5cIlxuICAgIH0sXG4gICAgXCJzeW1ib2wtbWluLWRpc3RhbmNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDI1MCxcbiAgICAgIFwibWluaW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdHdvIHN5bWJvbCBhbmNob3JzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgXCJkb2NcIjogXCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzIHRvIGF2b2lkIG11dHVhbCBjb2xsaXNpb25zLiBSZWNvbW1lbmRlZCBpbiBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLlwiXG4gICAgfSxcbiAgICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgaWNvbnMgYW5kIHRleHQuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIGljb24gd29uJ3QgYWZmZWN0IHBsYWNlbWVudCBvZiBvdGhlciBpY29ucyBhbmQgdGV4dC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGV4dCBjYW4gYmUgc2hvd24gd2l0aG91dCBpdHMgY29ycmVzcG9uZGluZyBpY29uLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIGljb24gd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLW1heC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gZmFjdG9yIHRvIHNjYWxlIHRoZSBpY29uLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24taW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRvY1wiOiBcIkEgc3RyaW5nIHdpdGgge3Rva2Vuc30gcmVwbGFjZWQsIHJlZmVyZW5jaW5nIHRoZSBkYXRhIHByb3BlcnR5IHRvIHB1bGwgZnJvbS5cIixcbiAgICAgIFwidG9rZW5zXCI6IHRydWVcbiAgICB9LFxuICAgIFwiaWNvbi1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIGljb24gYm91bmRpbmcgYm94IHRvIGF2b2lkIGljb24gY29sbGlzaW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93blwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1vZmZzZXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJJY29uJ3Mgb2Zmc2V0IGRpc3RhbmNlLiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG4gICAgICBcImRvY1wiOiBcIk9yaWVudGF0aW9uIG9mIGljb24gb3IgdGV4dCB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtZmllbGRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJcIixcbiAgICAgIFwidG9rZW5zXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBGZWF0dXJlIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZCB1c2luZyB0b2tlbnMgbGlrZSB7ZmllbGRfbmFtZX0uXCJcbiAgICB9LFxuICAgIFwidGV4dC1mb250XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiT3BlbiBTYW5zIFJlZ3VsYXIsIEFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiLFxuICAgICAgXCJkb2NcIjogXCJGb250IHN0YWNrIHRvIHVzZSBmb3IgZGlzcGxheWluZyB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIG1heGltdW0gc2l6ZSB0ZXh0IHdpbGwgYmUgbGFpZCBvdXQsIHRvIGNhbGN1bGF0ZSBjb2xsaXNpb25zIHdpdGguXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1tYXgtd2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMTUsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbGluZS1oZWlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMS4yLFxuICAgICAgXCJ1bml0c1wiOiBcImVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlRleHQgbGVhZGluZyB2YWx1ZSBmb3IgbXVsdGktbGluZSB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwidW5pdHNcIjogXCJlbVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGtlcm5pbmcgdmFsdWUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwicmlnaHRcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgICAgXCJkb2NcIjogXCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwiY2VudGVyXCIsXG4gICAgICAgIFwibGVmdFwiLFxuICAgICAgICBcInJpZ2h0XCIsXG4gICAgICAgIFwidG9wXCIsXG4gICAgICAgIFwiYm90dG9tXCIsXG4gICAgICAgIFwidG9wLWxlZnRcIixcbiAgICAgICAgXCJ0b3AtcmlnaHRcIixcbiAgICAgICAgXCJib3R0b20tbGVmdFwiLFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgICBcImRvY1wiOiBcIldoaWNoIHBhcnQgb2YgdGhlIHRleHQgdG8gcGxhY2UgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtbWF4LWFuZ2xlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDQ1LFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiTWF4aW11bSBhbmdsZSBjaGFuZ2UgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwidW5pdHNcIjogXCJkZWdyZWVzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtcGFkZGluZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcImRvY1wiOiBcIlBhZGRpbmcgdmFsdWUgYXJvdW5kIHRleHQgYm91bmRpbmcgYm94IHRvIGF2b2lkIGxhYmVsIGNvbGxpc2lvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IG1heSBiZSBmbGlwcGVkIHZlcnRpY2FsbHkgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2Zvcm1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgXCJsb3dlcmNhc2VcIlxuICAgICAgXSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZG9jXCI6IFwiU3BlY2lmaWVzIGhvdyB0byBjYXBpdGFsaXplIHRleHQsIHNpbWlsYXIgdG8gdGhlIENTUyBgdGV4dC10cmFuc2Zvcm1gIHByb3BlcnR5LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtb2Zmc2V0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgZGlzdGFuY2UgdGhhdCB0ZXh0IGlzIG9mZnNldCBmcm9tIGl0cyBhbmNob3IgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJ1bml0c1wiOiBcImVtc1wiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJsZW5ndGhcIjogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgIF0sXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBpY29ucyBhbmQgbGFiZWxzLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICBcImRvY1wiOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdvbid0IGFmZmVjdCBwbGFjZW1lbnQgb2Ygb3RoZXIgaWNvbnMgYW5kIGxhYmVscy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICAgIFwiZG9jXCI6IFwiSWYgdHJ1ZSwgaWNvbnMgY2FuIGJlIHNob3duIHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwidGV4dC1maWVsZFwiLFxuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ2aXNpYmlsaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJ2aXNpYmxlXCIsXG4gICAgICAgIFwibm9uZVwiXG4gICAgICBdLFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIlxuICAgIH1cbiAgfSxcbiAgXCJsYXlvdXRfcmFzdGVyXCI6IHtcbiAgICBcInZpc2liaWxpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiZW51bVwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcInBpZWNld2lzZS1jb25zdGFudFwiLFxuICAgICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgICBcInZpc2libGVcIixcbiAgICAgICAgXCJub25lXCJcbiAgICAgIF0sXG4gICAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiXG4gICAgfVxuICB9LFxuICBcImZpbHRlclwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICBcInZhbHVlXCI6IFwiKlwiXG4gIH0sXG4gIFwiZmlsdGVyX29wZXJhdG9yXCI6IHtcbiAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgXCJ2YWx1ZXNcIjogW1xuICAgICAgXCI9PVwiLFxuICAgICAgXCIhPVwiLFxuICAgICAgXCI+XCIsXG4gICAgICBcIj49XCIsXG4gICAgICBcIjxcIixcbiAgICAgIFwiPD1cIixcbiAgICAgIFwiaW5cIixcbiAgICAgIFwiIWluXCIsXG4gICAgICBcImFsbFwiLFxuICAgICAgXCJhbnlcIixcbiAgICAgIFwibm9uZVwiXG4gICAgXVxuICB9LFxuICBcImdlb21ldHJ5X3R5cGVcIjoge1xuICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICBcInZhbHVlc1wiOiBbXG4gICAgICBcIlBvaW50XCIsXG4gICAgICBcIkxpbmVTdHJpbmdcIixcbiAgICAgIFwiUG9seWdvblwiXG4gICAgXVxuICB9LFxuICBcImZ1bmN0aW9uXCI6IHtcbiAgICBcInN0b3BzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInJlcXVpcmVkXCI6IHRydWUsXG4gICAgICBcImRvY1wiOiBcIkFuIGFycmF5IG9mIHN0b3BzLlwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImZ1bmN0aW9uX3N0b3BcIlxuICAgIH0sXG4gICAgXCJiYXNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcbiAgICB9XG4gIH0sXG4gIFwiZnVuY3Rpb25fc3RvcFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICBcIm1pbmltdW1cIjogMCxcbiAgICBcIm1heGltdW1cIjogMjIsXG4gICAgXCJ2YWx1ZVwiOiBbXG4gICAgICBcIm51bWJlclwiLFxuICAgICAgXCJjb2xvclwiXG4gICAgXSxcbiAgICBcImxlbmd0aFwiOiAyLFxuICAgIFwiZG9jXCI6IFwiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci5cIlxuICB9LFxuICBcInBhaW50XCI6IFtcbiAgICBcInBhaW50X2ZpbGxcIixcbiAgICBcInBhaW50X2xpbmVcIixcbiAgICBcInBhaW50X3N5bWJvbFwiLFxuICAgIFwicGFpbnRfcmFzdGVyXCIsXG4gICAgXCJwYWludF9iYWNrZ3JvdW5kXCJcbiAgXSxcbiAgXCJwYWludF9maWxsXCI6IHtcbiAgICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJXaGV0aGVyIG9yIG5vdCB0aGUgZmlsbCBzaG91bGQgYmUgYW50aWFsaWFzZWQuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBnaXZlbiB0byB0aGUgZmlsbCBjb2xvci5cIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcImZpbGwtY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGNvbG9yIG9mIHRoZSBmaWxsLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImZpbGwtaW1hZ2VcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJmaWxsLWFudGlhbGlhc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCJcbiAgICB9LFxuICAgIFwiZmlsbC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJmaWxsLXRyYW5zbGF0ZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImZpbGwtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGZpbGxzLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2xpbmVcIjoge1xuICAgIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwibGluZS1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImxpbmUtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImxlbmd0aFwiOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFtcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgICAgXSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgfSxcbiAgICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwibGluZS10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJTdHJva2UgdGhpY2tuZXNzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZG9jXCI6IFwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIlxuICAgIH0sXG4gICAgXCJsaW5lLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLlwiXG4gICAgfSxcbiAgICBcImxpbmUtZGFzaGFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlNwZWNpZmllcyB0aGUgbGVuZ3RocyBvZiB0aGUgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzIHRoYXQgZm9ybSB0aGUgZGFzaCBwYXR0ZXJuLiBUaGUgbGVuZ3RocyBhcmUgbGF0ZXIgc2NhbGVkIGJ5IHRoZSBsaW5lIHdpZHRoLiBUbyBjb252ZXJ0IGEgZGFzaCBsZW5ndGggdG8gcGl4ZWxzLCBtdWx0aXBseSB0aGUgbGVuZ3RoIGJ5IHRoZSBjdXJyZW50IGxpbmUgd2lkdGguXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImxpbmUgd2lkdGhzXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImxpbmUtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImxpbmUtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGxpbmVzLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X3N5bWJvbFwiOiB7XG4gICAgXCJpY29uLW9wYWNpdHlcIjoge1xuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaWNvbiB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLXNpemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJTY2FsZSBmYWN0b3IgZm9yIGljb24uIDEgaXMgb3JpZ2luYWwgc2l6ZSwgMyB0cmlwbGVzIHRoZSBzaXplLlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcImljb24taW1hZ2VcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcInBpeGVsc1wiLFxuICAgICAgXCJkb2NcIjogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJpY29uLWltYWdlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkFuIGljb24ncyBvZmZzZXQgZGlzdGFuY2UuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiXG4gICAgICBdXG4gICAgfSxcbiAgICBcImljb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJlbnVtXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInZhbHVlc1wiOiBbXG4gICAgICAgIFwibWFwXCIsXG4gICAgICAgIFwidmlld3BvcnRcIlxuICAgICAgXSxcbiAgICAgIFwiZG9jXCI6IFwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgXCJyZXF1aXJlc1wiOiBbXG4gICAgICAgIFwiaWNvbi1pbWFnZVwiLFxuICAgICAgICBcImljb24tdHJhbnNsYXRlXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC1zaXplXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDE2LFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiRm9udCBzaXplLiBJZiB1bnNwZWNpZmllZCwgdGhlIHRleHQgd2lsbCBiZSBhcyBiaWcgYXMgYWxsb3dlZCBieSB0aGUgbGF5ZXIgZGVmaW5pdGlvbi5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWNvbG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImNvbG9yXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tY29sb3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8td2lkdGhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcbiAgICAgIFwicmVxdWlyZXNcIjogW1xuICAgICAgICBcInRleHQtZmllbGRcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJ0ZXh0LWhhbG8tYmx1clwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwidW5pdHNcIjogXCJwaXhlbHNcIixcbiAgICAgIFwiZG9jXCI6IFwiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwidmFsdWVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibGVuZ3RoXCI6IDIsXG4gICAgICBcImRlZmF1bHRcIjogW1xuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICBdLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwicGl4ZWxzXCIsXG4gICAgICBcImRvY1wiOiBcIkxhYmVsIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGV4dC10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImVudW1cIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJwaWVjZXdpc2UtY29uc3RhbnRcIixcbiAgICAgIFwidmFsdWVzXCI6IFtcbiAgICAgICAgXCJtYXBcIixcbiAgICAgICAgXCJ2aWV3cG9ydFwiXG4gICAgICBdLFxuICAgICAgXCJkb2NcIjogXCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAgXCJ0ZXh0LWZpZWxkXCIsXG4gICAgICAgIFwidGV4dC10cmFuc2xhdGVcIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgXCJwYWludF9yYXN0ZXJcIjoge1xuICAgIFwicmFzdGVyLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpbWFnZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwibWF4aW11bVwiOiAxLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWVcbiAgICB9LFxuICAgIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIFwicGVyaW9kXCI6IDM2MCxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlLFxuICAgICAgXCJ1bml0c1wiOiBcImRlZ3JlZXNcIixcbiAgICAgIFwiZG9jXCI6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCJcbiAgICB9LFxuICAgIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJkb2NcIjogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1icmlnaHRuZXNzLW1heFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZG9jXCI6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IC0xLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRvY1wiOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBcIm1pbmltdW1cIjogLTEsXG4gICAgICBcIm1heGltdW1cIjogMSxcbiAgICAgIFwiZnVuY3Rpb25cIjogXCJpbnRlcnBvbGF0ZWRcIixcbiAgICAgIFwidHJhbnNpdGlvblwiOiB0cnVlXG4gICAgfSxcbiAgICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiXG4gICAgfVxuICB9LFxuICBcInBhaW50X2JhY2tncm91bmRcIjoge1xuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJjb2xvclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgICAgXCJkb2NcIjogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgICAgXCJmdW5jdGlvblwiOiBcImludGVycG9sYXRlZFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uXCI6IHRydWUsXG4gICAgICBcInJlcXVpcmVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImJhY2tncm91bmQtaW1hZ2VcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwicGllY2V3aXNlLWNvbnN0YW50XCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZSxcbiAgICAgIFwiZG9jXCI6IFwiT3B0aW9uYWxseSBhbiBpbWFnZSB3aGljaCBpcyBkcmF3biBhcyB0aGUgYmFja2dyb3VuZC5cIlxuICAgIH0sXG4gICAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJtYXhpbXVtXCI6IDEsXG4gICAgICBcImRvY1wiOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgICBcImZ1bmN0aW9uXCI6IFwiaW50ZXJwb2xhdGVkXCIsXG4gICAgICBcInRyYW5zaXRpb25cIjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgXCJ0cmFuc2l0aW9uXCI6IHtcbiAgICBcImR1cmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDMwMCxcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJ1bml0c1wiOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgICAgXCJkb2NcIjogXCJUaW1lIGFsbG90dGVkIGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZS5cIlxuICAgIH0sXG4gICAgXCJkZWxheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcInVuaXRzXCI6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBcImRvY1wiOiBcIkxlbmd0aCBvZiB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwiXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGxpZ2h0d2VpZ2h0IEJ1ZmZlciBzaGltIGZvciBwYmYgYnJvd3NlciBidWlsZFxuLy8gYmFzZWQgb24gY29kZSBmcm9tIGdpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlciAoTUlULWxpY2Vuc2VkKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcblxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0Jyk7XG5cbnZhciBCdWZmZXJNZXRob2RzO1xuXG5mdW5jdGlvbiBCdWZmZXIobGVuZ3RoKSB7XG4gICAgdmFyIGFycjtcbiAgICBpZiAobGVuZ3RoICYmIGxlbmd0aC5sZW5ndGgpIHtcbiAgICAgICAgYXJyID0gbGVuZ3RoO1xuICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoIHx8IDApO1xuICAgIGlmIChhcnIpIGJ1Zi5zZXQoYXJyKTtcblxuICAgIGJ1Zi5yZWFkVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLnJlYWRVSW50MzJMRTtcbiAgICBidWYud3JpdGVVSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVVSW50MzJMRTtcbiAgICBidWYucmVhZEludDMyTEUgPSBCdWZmZXJNZXRob2RzLnJlYWRJbnQzMkxFO1xuICAgIGJ1Zi53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlSW50MzJMRTtcbiAgICBidWYucmVhZEZsb2F0TEUgPSBCdWZmZXJNZXRob2RzLnJlYWRGbG9hdExFO1xuICAgIGJ1Zi53cml0ZUZsb2F0TEUgPSBCdWZmZXJNZXRob2RzLndyaXRlRmxvYXRMRTtcbiAgICBidWYucmVhZERvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy5yZWFkRG91YmxlTEU7XG4gICAgYnVmLndyaXRlRG91YmxlTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlRG91YmxlTEU7XG4gICAgYnVmLnRvU3RyaW5nID0gQnVmZmVyTWV0aG9kcy50b1N0cmluZztcbiAgICBidWYud3JpdGUgPSBCdWZmZXJNZXRob2RzLndyaXRlO1xuICAgIGJ1Zi5zbGljZSA9IEJ1ZmZlck1ldGhvZHMuc2xpY2U7XG4gICAgYnVmLmNvcHkgPSBCdWZmZXJNZXRob2RzLmNvcHk7XG5cbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZTtcbiAgICByZXR1cm4gYnVmO1xufVxuXG52YXIgbGFzdFN0ciwgbGFzdFN0ckVuY29kZWQ7XG5cbkJ1ZmZlck1ldGhvZHMgPSB7XG4gICAgcmVhZFVJbnQzMkxFOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcmV0dXJuICgodGhpc1twb3NdKSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAyXSA8PCAxNikpICtcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDNdICogMHgxMDAwMDAwKTtcbiAgICB9LFxuXG4gICAgd3JpdGVVSW50MzJMRTogZnVuY3Rpb24odmFsLCBwb3MpIHtcbiAgICAgICAgdGhpc1twb3NdID0gdmFsO1xuICAgICAgICB0aGlzW3BvcyArIDFdID0gKHZhbCA+Pj4gOCk7XG4gICAgICAgIHRoaXNbcG9zICsgMl0gPSAodmFsID4+PiAxNik7XG4gICAgICAgIHRoaXNbcG9zICsgM10gPSAodmFsID4+PiAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRJbnQzMkxFOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgcmV0dXJuICgodGhpc1twb3NdKSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAodGhpc1twb3MgKyAyXSA8PCAxNikpICtcbiAgICAgICAgICAgICh0aGlzW3BvcyArIDNdIDw8IDI0KTtcbiAgICB9LFxuXG4gICAgcmVhZEZsb2F0TEU6ICBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDIzLCA0KTsgfSxcbiAgICByZWFkRG91YmxlTEU6IGZ1bmN0aW9uKHBvcykgeyByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIHBvcywgdHJ1ZSwgNTIsIDgpOyB9LFxuXG4gICAgd3JpdGVGbG9hdExFOiAgZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDIzLCA0KTsgfSxcbiAgICB3cml0ZURvdWJsZUxFOiBmdW5jdGlvbih2YWwsIHBvcykgeyByZXR1cm4gaWVlZTc1NC53cml0ZSh0aGlzLCB2YWwsIHBvcywgdHJ1ZSwgNTIsIDgpOyB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBzdHIgPSAnJyxcbiAgICAgICAgICAgIHRtcCA9ICcnO1xuXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sZW5ndGgsIGVuZCB8fCB0aGlzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHRoaXNbaV07XG4gICAgICAgICAgICBpZiAoY2ggPD0gMHg3Rikge1xuICAgICAgICAgICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgICAgIHRtcCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bXAgKz0gJyUnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IGRlY29kZVVSSUNvbXBvbmVudCh0bXApO1xuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHdyaXRlOiBmdW5jdGlvbihzdHIsIHBvcykge1xuICAgICAgICB2YXIgYnl0ZXMgPSBzdHIgPT09IGxhc3RTdHIgPyBsYXN0U3RyRW5jb2RlZCA6IGVuY29kZVN0cmluZyhzdHIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3BvcyArIGldID0gYnl0ZXNbaV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKGJ1ZiwgcG9zKSB7XG4gICAgICAgIHBvcyA9IHBvcyB8fCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHRoaXNbaV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5CdWZmZXJNZXRob2RzLndyaXRlSW50MzJMRSA9IEJ1ZmZlck1ldGhvZHMud3JpdGVVSW50MzJMRTtcblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbihzdHIpIHtcbiAgICBsYXN0U3RyID0gc3RyO1xuICAgIGxhc3RTdHJFbmNvZGVkID0gZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIGxhc3RTdHJFbmNvZGVkLmxlbmd0aDtcbn07XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHJldHVybiAhIShidWYgJiYgYnVmLl9pc0J1ZmZlcik7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcoc3RyKSB7XG4gICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGgsXG4gICAgICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYywgbGVhZDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gY29kZSBwb2ludFxuXG4gICAgICAgIGlmIChjID4gMHhEN0ZGICYmIGMgPCAweEUwMDApIHtcblxuICAgICAgICAgICAgaWYgKGxlYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA8IDB4REMwMCkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgICAgICAgICBsZWFkID0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjID0gbGVhZCAtIDB4RDgwMCA8PCAxMCB8IGMgLSAweERDMDAgfCAweDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBsZWFkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiAweERCRkYgfHwgKGkgKyAxID09PSBsZW5ndGgpKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgICAgIGVsc2UgbGVhZCA9IGM7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGxlYWQpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICBsZWFkID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHg4MCkgYnl0ZXMucHVzaChjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSBieXRlcy5wdXNoKGMgPj4gMHg2IHwgMHhDMCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4MTAwMDApIGJ5dGVzLnB1c2goYyA+PiAweEMgfCAweEUwLCBjID4+IDB4NiAmIDB4M0YgfCAweDgwLCBjICYgMHgzRiB8IDB4ODApO1xuICAgICAgICBlbHNlIGJ5dGVzLnB1c2goYyA+PiAweDEyIHwgMHhGMCwgYyA+PiAweEMgJiAweDNGIHwgMHg4MCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBiZjtcblxudmFyIEJ1ZmZlciA9IGdsb2JhbC5CdWZmZXIgfHwgcmVxdWlyZSgnLi9idWZmZXInKTtcblxuZnVuY3Rpb24gUGJmKGJ1Zikge1xuICAgIHRoaXMuYnVmID0gIUJ1ZmZlci5pc0J1ZmZlcihidWYpID8gbmV3IEJ1ZmZlcihidWYgfHwgMCkgOiBidWY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoO1xufVxuXG5QYmYuVmFyaW50ICA9IDA7IC8vIHZhcmludDogaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cblBiZi5GaXhlZDY0ID0gMTsgLy8gNjQtYml0OiBkb3VibGUsIGZpeGVkNjQsIHNmaXhlZDY0XG5QYmYuQnl0ZXMgICA9IDI7IC8vIGxlbmd0aC1kZWxpbWl0ZWQ6IHN0cmluZywgYnl0ZXMsIGVtYmVkZGVkIG1lc3NhZ2VzLCBwYWNrZWQgcmVwZWF0ZWQgZmllbGRzXG5QYmYuRml4ZWQzMiA9IDU7IC8vIDMyLWJpdDogZmxvYXQsIGZpeGVkMzIsIHNmaXhlZDMyXG5cbnZhciBTSElGVF9MRUZUXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpLFxuICAgIFNISUZUX1JJR0hUXzMyID0gMSAvIFNISUZUX0xFRlRfMzIsXG4gICAgUE9XXzJfNjMgPSBNYXRoLnBvdygyLCA2Myk7XG5cblBiZi5wcm90b3R5cGUgPSB7XG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5idWYgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyA9PT0gUkVBRElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgcmVhZEZpZWxkczogZnVuY3Rpb24ocmVhZEZpZWxkLCByZXN1bHQsIGVuZCkge1xuICAgICAgICBlbmQgPSBlbmQgfHwgdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50KCksXG4gICAgICAgICAgICAgICAgdGFnID0gdmFsID4+IDMsXG4gICAgICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnBvcztcblxuICAgICAgICAgICAgcmVhZEZpZWxkKHRhZywgcmVzdWx0LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBzdGFydFBvcykgdGhpcy5za2lwKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcmVhZE1lc3NhZ2U6IGZ1bmN0aW9uKHJlYWRGaWVsZCwgcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWVsZHMocmVhZEZpZWxkLCByZXN1bHQsIHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MpO1xuICAgIH0sXG5cbiAgICByZWFkRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICAvLyA2NC1iaXQgaW50IGhhbmRsaW5nIGlzIGJhc2VkIG9uIGdpdGh1Yi5jb20vZHB3L25vZGUtYnVmZmVyLW1vcmUtaW50cyAoTUlULWxpY2Vuc2VkKVxuXG4gICAgcmVhZEZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKSArIHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcyArIDQpICogU0hJRlRfTEVGVF8zMjtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcykgKyB0aGlzLmJ1Zi5yZWFkSW50MzJMRSh0aGlzLnBvcyArIDQpICogU0hJRlRfTEVGVF8zMjtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZEZsb2F0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRGbG9hdExFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZERvdWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkRG91YmxlTEUodGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG5cbiAgICByZWFkVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuYnVmLFxuICAgICAgICAgICAgdmFsLCBiLCBiMCwgYjEsIGIyLCBiMztcblxuICAgICAgICBiMCA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIwIDwgMHg4MCkgcmV0dXJuIGIwOyAgICAgICAgICAgICAgICAgYjAgPSBiMCAmIDB4N2Y7XG4gICAgICAgIGIxID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjEgPCAweDgwKSByZXR1cm4gYjAgfCBiMSA8PCA3OyAgICAgICBiMSA9IChiMSAmIDB4N2YpIDw8IDc7XG4gICAgICAgIGIyID0gYnVmW3RoaXMucG9zKytdOyBpZiAoYjIgPCAweDgwKSByZXR1cm4gYjAgfCBiMSB8IGIyIDw8IDE0OyBiMiA9IChiMiAmIDB4N2YpIDw8IDE0O1xuICAgICAgICBiMyA9IGJ1Zlt0aGlzLnBvcysrXTsgaWYgKGIzIDwgMHg4MCkgcmV0dXJuIGIwIHwgYjEgfCBiMiB8IGIzIDw8IDIxO1xuXG4gICAgICAgIHZhbCA9IGIwIHwgYjEgfCBiMiB8IChiMyAmIDB4N2YpIDw8IDIxO1xuXG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgxMDAwMDAwMDsgICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg4MDAwMDAwMDA7ICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg0MDAwMDAwMDAwMDsgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgyMDAwMDAwMDAwMDAwOyAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgxMDAwMDAwMDAwMDAwMDA7ICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg4MDAwMDAwMDAwMDAwMDAwOyBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YXJpbnQgbm90IG1vcmUgdGhhbiAxMCBieXRlcycpO1xuICAgIH0sXG5cbiAgICByZWFkVmFyaW50NjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvcyxcbiAgICAgICAgICAgIHZhbCA9IHRoaXMucmVhZFZhcmludCgpO1xuXG4gICAgICAgIGlmICh2YWwgPCBQT1dfMl82MykgcmV0dXJuIHZhbDtcblxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3MgLSAyO1xuICAgICAgICB3aGlsZSAodGhpcy5idWZbcG9zXSA9PT0gMHhmZikgcG9zLS07XG4gICAgICAgIGlmIChwb3MgPCBzdGFydFBvcykgcG9zID0gc3RhcnRQb3M7XG5cbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3MgLSBzdGFydFBvcyArIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGIgPSB+dGhpcy5idWZbc3RhcnRQb3MgKyBpXSAmIDB4N2Y7XG4gICAgICAgICAgICB2YWwgKz0gaSA8IDQgPyBiIDw8IGkgKiA3IDogYiAqIE1hdGgucG93KDIsIGkgKiA3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtdmFsIC0gMTtcbiAgICB9LFxuXG4gICAgcmVhZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbnVtID0gdGhpcy5yZWFkVmFyaW50KCk7XG4gICAgICAgIHJldHVybiBudW0gJSAyID09PSAxID8gKG51bSArIDEpIC8gLTIgOiBudW0gLyAyOyAvLyB6aWd6YWcgZW5jb2RpbmdcbiAgICB9LFxuXG4gICAgcmVhZEJvb2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnJlYWRWYXJpbnQoKSk7XG4gICAgfSxcblxuICAgIHJlYWRTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyxcbiAgICAgICAgICAgIHN0ciA9IHRoaXMuYnVmLnRvU3RyaW5nKCd1dGY4JywgdGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICByZWFkQnl0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyxcbiAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCBlbmQpO1xuICAgICAgICB0aGlzLnBvcyA9IGVuZDtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9LFxuXG4gICAgLy8gdmVyYm9zZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczsgZG9lc24ndCBhZmZlY3QgZ3ppcHBlZCBzaXplXG5cbiAgICByZWFkUGFja2VkVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTVmFyaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNWYXJpbnQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRCb29sZWFuKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZsb2F0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZsb2F0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZERvdWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWREb3VibGUoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQzMjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDMyKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDMyKCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZEZpeGVkNjQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQ2NCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuXG4gICAgc2tpcDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciB0eXBlID0gdmFsICYgMHg3O1xuICAgICAgICBpZiAodHlwZSA9PT0gUGJmLlZhcmludCkgd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdID4gMHg3Zikge31cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkJ5dGVzKSB0aGlzLnBvcyA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3M7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDMyKSB0aGlzLnBvcyArPSA0O1xuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuRml4ZWQ2NCkgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgdHlwZTogJyArIHR5cGUpO1xuICAgIH0sXG5cbiAgICAvLyA9PT0gV1JJVElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgd3JpdGVUYWc6IGZ1bmN0aW9uKHRhZywgdHlwZSkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KCh0YWcgPDwgMykgfCB0eXBlKTtcbiAgICB9LFxuXG4gICAgcmVhbGxvYzogZnVuY3Rpb24obWluKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAxNjtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoIDwgdGhpcy5wb3MgKyBtaW4pIGxlbmd0aCAqPSAyO1xuXG4gICAgICAgIGlmIChsZW5ndGggIT09IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWYuY29weShidWYpO1xuICAgICAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQzMjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVTRml4ZWQzMjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg0KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZUZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDY0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCB0aGlzLnBvcyArIDQpO1xuICAgICAgICB0aGlzLnBvcyArPSA4O1xuICAgIH0sXG5cbiAgICB3cml0ZVZhcmludDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhbCA9ICt2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9IHZhbDtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweDNmZmYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYygyKTtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDApICYgMHg3ZikgfCAweDgwO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gNykgJiAweDdmKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDMpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDE0KSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDB4ZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj4gMCkgJiAweDdmKSB8IDB4ODA7XG4gICAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+PiA3KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDE0KSAmIDB4N2YpIHwgMHg4MDtcbiAgICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+IDIxKSAmIDB4N2YpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB3aGlsZSAodmFsID49IDB4ODApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWxsb2MoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAodmFsICYgMHhmZikgfCAweDgwO1xuICAgICAgICAgICAgICAgIHZhbCAvPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFsbG9jKDEpO1xuICAgICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSB2YWwgfCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zIC0gcG9zID4gMTApIHRocm93IG5ldyBFcnJvcignR2l2ZW4gdmFyaW50IGRvZXNuXFwndCBmaXQgaW50byAxMCBieXRlcycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdyaXRlU1ZhcmludDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsIDwgMCA/IC12YWwgKiAyIC0gMSA6IHZhbCAqIDIpO1xuICAgIH0sXG5cbiAgICB3cml0ZUJvb2xlYW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KEJvb2xlYW4odmFsKSk7XG4gICAgfSxcblxuICAgIHdyaXRlU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cik7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgICAgICB0aGlzLnJlYWxsb2MoYnl0ZXMpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZShzdHIsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgfSxcblxuICAgIHdyaXRlRmxvYXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRmxvYXRMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRG91YmxlTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnJlYWxsb2MobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpcy5idWZbdGhpcy5wb3MrK10gPSBidWZmZXJbaV07XG4gICAgfSxcblxuICAgIHdyaXRlTWVzc2FnZTogZnVuY3Rpb24odGFnLCBmbiwgb2JqKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuQnl0ZXMpO1xuXG4gICAgICAgIHRoaXMucG9zKys7IC8vIHJlc2VydmUgMSBieXRlIGZvciBzaG9ydCBtZXNzYWdlIGxlbmd0aFxuXG4gICAgICAgIC8vIHdyaXRlIHRoZSBtZXNzYWdlIGRpcmVjdGx5IHRvIHRoZSBidWZmZXIgYW5kIHNlZSBob3cgbXVjaCB3YXMgd3JpdHRlblxuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvcztcbiAgICAgICAgZm4ob2JqLCB0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucG9zIC0gc3RhcnRQb3M7XG5cbiAgICAgICAgdmFyIHZhcmludExlbiA9XG4gICAgICAgICAgICBsZW4gPD0gMHg3ZiA/IDEgOlxuICAgICAgICAgICAgbGVuIDw9IDB4M2ZmZiA/IDIgOlxuICAgICAgICAgICAgbGVuIDw9IDB4MWZmZmZmID8gMyA6XG4gICAgICAgICAgICBsZW4gPD0gMHhmZmZmZmZmID8gNCA6IE1hdGguY2VpbChNYXRoLmxvZyhsZW4pIC8gKE1hdGguTE4yICogNykpO1xuXG4gICAgICAgIC8vIGlmIDEgYnl0ZSBpc24ndCBlbm91Z2ggZm9yIGVuY29kaW5nIG1lc3NhZ2UgbGVuZ3RoLCBzaGlmdCB0aGUgZGF0YSB0byB0aGUgcmlnaHRcbiAgICAgICAgaWYgKHZhcmludExlbiA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhbGxvYyh2YXJpbnRMZW4gLSAxKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBvcyAtIDE7IGkgPj0gc3RhcnRQb3M7IGktLSkgdGhpcy5idWZbaSArIHZhcmludExlbiAtIDFdID0gdGhpcy5idWZbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5LCB3cml0ZSB0aGUgbWVzc2FnZSBsZW5ndGggaW4gdGhlIHJlc2VydmVkIHBsYWNlIGFuZCByZXN0b3JlIHRoZSBwb3NpdGlvblxuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zIC0gMTtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgfSxcblxuICAgIHdyaXRlUGFja2VkVmFyaW50OiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRWYXJpbnQsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZFNWYXJpbnQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU1ZhcmludCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRCb29sZWFuOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEJvb2xlYW4sIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkRmxvYXQ6ICAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGbG9hdCwgYXJyKTsgICAgfSxcbiAgICB3cml0ZVBhY2tlZERvdWJsZTogICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRG91YmxlLCBhcnIpOyAgIH0sXG4gICAgd3JpdGVQYWNrZWRGaXhlZDMyOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkMzIsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTRml4ZWQzMiwgYXJyKTsgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkNjQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQ2NCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDY0LCBhcnIpOyB9LFxuXG4gICAgd3JpdGVCeXRlc0ZpZWxkOiBmdW5jdGlvbih0YWcsIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZUJ5dGVzKGJ1ZmZlcik7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDMyKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDY0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU1ZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVTVmFyaW50KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbih0YWcsIHN0cikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyhzdHIpO1xuICAgIH0sXG4gICAgd3JpdGVGbG9hdEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRmxvYXQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRG91YmxlRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVEb3VibGUodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlQm9vbGVhbkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50RmllbGQodGFnLCBCb29sZWFuKHZhbCkpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHdyaXRlUGFja2VkVmFyaW50KGFyciwgcGJmKSAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVZhcmludChhcnJbaV0pOyAgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkU1ZhcmludChhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNWYXJpbnQoYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRmxvYXQoYXJyLCBwYmYpICAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZsb2F0KGFycltpXSk7ICAgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRG91YmxlKGFyciwgcGJmKSAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZURvdWJsZShhcnJbaV0pOyAgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkQm9vbGVhbihhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUJvb2xlYW4oYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQzMihhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZpeGVkMzIoYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkMzIoYXJyLCBwYmYpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNGaXhlZDMyKGFycltpXSk7IH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQ2NChhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZpeGVkNjQoYXJyW2ldKTsgIH1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkNjQoYXJyLCBwYmYpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNGaXhlZDY0KGFycltpXSk7IH1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIGFkZDogICAgIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fYWRkKHApOyAgICAgfSxcbiAgICBzdWI6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3N1YihwKTsgICAgIH0sXG4gICAgbXVsdDogICAgZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tdWx0KGspOyAgICB9LFxuICAgIGRpdjogICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2KGspOyAgICAgfSxcbiAgICByb3RhdGU6ICBmdW5jdGlvbihhKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdGF0ZShhKTsgIH0sXG4gICAgbWF0TXVsdDogZnVuY3Rpb24obSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9tYXRNdWx0KG0pOyB9LFxuICAgIHVuaXQ6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl91bml0KCk7IH0sXG4gICAgcGVycDogICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3BlcnAoKTsgfSxcbiAgICByb3VuZDogICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fcm91bmQoKTsgfSxcblxuICAgIG1hZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHAueCAmJlxuICAgICAgICAgICAgICAgdGhpcy55ID09PSBwLnk7XG4gICAgfSxcblxuICAgIGRpc3Q6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RTcXIocCkpO1xuICAgIH0sXG5cbiAgICBkaXN0U3FyOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueCxcbiAgICAgICAgICAgIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuICAgIH0sXG5cbiAgICBhbmdsZVRvOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSAtIGIueSwgdGhpcy54IC0gYi54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVXaXRoOiBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuZ2xlV2l0aFNlcChiLngsIGIueSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGFuZ2xlIG9mIHRoZSB0d28gdmVjdG9ycywgc29sdmluZyB0aGUgZm9ybXVsYSBmb3IgdGhlIGNyb3NzIHByb2R1Y3QgYSB4IGIgPSB8YXx8YnxzaW4ozrgpIGZvciDOuC5cbiAgICBhbmdsZVdpdGhTZXA6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoXG4gICAgICAgICAgICB0aGlzLnggKiB5IC0gdGhpcy55ICogeCxcbiAgICAgICAgICAgIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5KTtcbiAgICB9LFxuXG4gICAgX21hdE11bHQ6IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdmFyIHggPSBtWzBdICogdGhpcy54ICsgbVsxXSAqIHRoaXMueSxcbiAgICAgICAgICAgIHkgPSBtWzJdICogdGhpcy54ICsgbVszXSAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hZGQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54ICs9IHAueDtcbiAgICAgICAgdGhpcy55ICs9IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zdWI6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy54IC09IHAueDtcbiAgICAgICAgdGhpcy55IC09IHAueTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9tdWx0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAqPSBrO1xuICAgICAgICB0aGlzLnkgKj0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9kaXY6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdGhpcy54IC89IGs7XG4gICAgICAgIHRoaXMueSAvPSBrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3VuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXYodGhpcy5tYWcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcGVycDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnkgPSB0aGlzLng7XG4gICAgICAgIHRoaXMueCA9IC15O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIHggPSBjb3MgKiB0aGlzLnggLSBzaW4gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gc2luICogdGhpcy54ICsgY29zICogdGhpcy55O1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIGNvbnN0cnVjdHMgUG9pbnQgZnJvbSBhbiBhcnJheSBpZiBuZWNlc3NhcnlcblBvaW50LmNvbnZlcnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoYVswXSwgYVsxXSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcbiIsIi8qXG4gKGMpIDIwMTMsIFZsYWRpbWlyIEFnYWZvbmtpblxuIFJCdXNoLCBhIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgaGlnaC1wZXJmb3JtYW5jZSAyRCBzcGF0aWFsIGluZGV4aW5nIG9mIHBvaW50cyBhbmQgcmVjdGFuZ2xlcy5cbiBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaFxuKi9cblxuKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcblxuICAgIC8vIGpzaGludCBuZXdjYXA6IGZhbHNlLCB2YWxpZHRoaXM6IHRydWVcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZS5iYm94KSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3g7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHN0cmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgIGJib3g6IGVtcHR5KCksXG4gICAgICAgICAgICBsZWFmOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBub2RlLmNoaWxkcmVuLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLmJib3gsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSxcbiAgICBjb21wYXJlTWluWTogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgYmJveDogbnVsbCxcbiAgICAgICAgICAgICAgICBsZWFmOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIGVsaW1pbmF0ZSByZWN1cnNpb24/XG5cbiAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgYmJveDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZC5iYm94KTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZC5iYm94KSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgYmJveCA9IGlzTm9kZSA/IGl0ZW0uYmJveCA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLmJib3gsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLnNwbGljZSh0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pKSxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobm9kZS5sZWFmKSBuZXdOb2RlLmxlYWYgPSB0cnVlO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtub2RlLCBuZXdOb2RlXSxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQgKyAxXG4gICAgICAgIH07XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0uYmJveCwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgLy8ganNoaW50IGV2aWw6IHRydWVcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLCAncmV0dXJuIFthJyArIGZvcm1hdC5qb2luKCcsIGEnKSArICddOycpO1xuICAgIH1cbn07XG5cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZSwgdG9CQm94KSB7XG4gICAgbm9kZS5iYm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gpIHtcbiAgICB2YXIgYmJveCA9IGVtcHR5KCk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoYmJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94O1xufVxuXG5mdW5jdGlvbiBlbXB0eSgpIHsgcmV0dXJuIFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTsgfVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGFbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBhWzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgYVsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIGFbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEuYmJveFswXSAtIGIuYmJveFswXTsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEuYmJveFsxXSAtIGIuYmJveFsxXTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhWzJdIC0gYVswXSkgKiAoYVszXSAtIGFbMV0pOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhWzJdIC0gYVswXSkgKyAoYVszXSAtIGFbMV0pOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiWzJdLCBhWzJdKSAtIE1hdGgubWluKGJbMF0sIGFbMF0pKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiWzNdLCBhWzNdKSAtIE1hdGgubWluKGJbMV0sIGFbMV0pKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhWzBdLCBiWzBdKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYVsyXSwgYlsyXSksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA8PSBiWzBdICYmXG4gICAgICAgICAgIGFbMV0gPD0gYlsxXSAmJlxuICAgICAgICAgICBiWzJdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgYlszXSA8PSBhWzNdO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYlswXSA8PSBhWzJdICYmXG4gICAgICAgICAgIGJbMV0gPD0gYVszXSAmJlxuICAgICAgICAgICBiWzJdID49IGFbMF0gJiZcbiAgICAgICAgICAgYlszXSA+PSBhWzFdO1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgbWlkO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG1pZCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cblxuLy8gc29ydCBhcnJheSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0IChpbmNsdXNpdmUpIHNvIHRoYXQgdGhlIHNtYWxsZXN0IGsgZWxlbWVudHMgY29tZSBmaXJzdCAodW5vcmRlcmVkKVxuZnVuY3Rpb24gc2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIGssIGNvbXBhcmUpIHtcbiAgICB2YXIgbiwgaSwgeiwgcywgc2QsIG5ld0xlZnQsIG5ld1JpZ2h0LCB0LCBqO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGkgPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKGkgLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIGkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIGkpICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgc2VsZWN0KGFyciwgbmV3TGVmdCwgbmV3UmlnaHQsIGssIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IGFycltrXTtcbiAgICAgICAgaSA9IGxlZnQ7XG4gICAgICAgIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuXG4vLyBleHBvcnQgYXMgQU1EL0NvbW1vbkpTIG1vZHVsZSBvciBnbG9iYWwgdmFyaWFibGVcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZSgncmJ1c2gnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJidXNoOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xuZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnJidXNoID0gcmJ1c2g7XG5lbHNlIHdpbmRvdy5yYnVzaCA9IHJidXNoO1xuXG59KSgpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFBvcnRlZCBmcm9tIFdlYmtpdFxuICogaHR0cDovL3N2bi53ZWJraXQub3JnL3JlcG9zaXRvcnkvd2Via2l0L3RydW5rL1NvdXJjZS9XZWJDb3JlL3BsYXRmb3JtL2dyYXBoaWNzL1VuaXRCZXppZXIuaFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVW5pdEJlemllcjtcblxuZnVuY3Rpb24gVW5pdEJlemllcihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLCBpbXBsaWNpdCBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50cyBhcmUgKDAsMCkgYW5kICgxLDEpLlxuICAgIHRoaXMuY3ggPSAzLjAgKiBwMXg7XG4gICAgdGhpcy5ieCA9IDMuMCAqIChwMnggLSBwMXgpIC0gdGhpcy5jeDtcbiAgICB0aGlzLmF4ID0gMS4wIC0gdGhpcy5jeCAtIHRoaXMuYng7XG5cbiAgICB0aGlzLmN5ID0gMy4wICogcDF5O1xuICAgIHRoaXMuYnkgPSAzLjAgKiAocDJ5IC0gcDF5KSAtIHRoaXMuY3k7XG4gICAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5O1xuXG4gICAgdGhpcy5wMXggPSBwMXg7XG4gICAgdGhpcy5wMXkgPSBwMnk7XG4gICAgdGhpcy5wMnggPSBwMng7XG4gICAgdGhpcy5wMnkgPSBwMnk7XG59XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAvLyBgYXggdF4zICsgYnggdF4yICsgY3ggdCcgZXhwYW5kZWQgdXNpbmcgSG9ybmVyJ3MgcnVsZS5cbiAgICByZXR1cm4gKCh0aGlzLmF4ICogdCArIHRoaXMuYngpICogdCArIHRoaXMuY3gpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gKCh0aGlzLmF5ICogdCArIHRoaXMuYnkpICogdCArIHRoaXMuY3kpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgzLjAgKiB0aGlzLmF4ICogdCArIDIuMCAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICBpZiAodHlwZW9mIGVwc2lsb24gPT09ICd1bmRlZmluZWQnKSBlcHNpbG9uID0gMWUtNjtcblxuICAgIHZhciB0MCwgdDEsIHQyLCB4MiwgaTtcblxuICAgIC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG4gICAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyhkMikgPCAxZS02KSBicmVhaztcblxuICAgICAgICB0MiA9IHQyIC0geDIgLyBkMjtcbiAgICB9XG5cbiAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGJpc2VjdGlvbiBtZXRob2QgZm9yIHJlbGlhYmlsaXR5LlxuICAgIHQwID0gMC4wO1xuICAgIHQxID0gMS4wO1xuICAgIHQyID0geDtcblxuICAgIGlmICh0MiA8IHQwKSByZXR1cm4gdDA7XG4gICAgaWYgKHQyID4gdDEpIHJldHVybiB0MTtcblxuICAgIHdoaWxlICh0MCA8IHQxKSB7XG5cbiAgICAgICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgICAgIGlmICh4ID4geDIpIHtcbiAgICAgICAgICAgIHQwID0gdDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0MSA9IHQyO1xuICAgICAgICB9XG5cbiAgICAgICAgdDIgPSAodDEgLSB0MCkgKiAwLjUgKyB0MDtcbiAgICB9XG5cbiAgICAvLyBGYWlsdXJlLlxuICAgIHJldHVybiB0Mjtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuICAgIHJldHVybiB0aGlzLnNhbXBsZUN1cnZlWSh0aGlzLnNvbHZlQ3VydmVYKHgsIGVwc2lsb24pKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cy5WZWN0b3JUaWxlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL2xpYi92ZWN0b3J0aWxlZmVhdHVyZS5qcycpO1xubW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWxheWVyLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlTGF5ZXIgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVsYXllcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGUocGJmLCBlbmQpIHtcbiAgICB0aGlzLmxheWVycyA9IHBiZi5yZWFkRmllbGRzKHJlYWRUaWxlLCB7fSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gcmVhZFRpbGUodGFnLCBsYXllcnMsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbmV3IFZlY3RvclRpbGVMYXllcihwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKTtcbiAgICAgICAgaWYgKGxheWVyLmxlbmd0aCkgbGF5ZXJzW2xheWVyLm5hbWVdID0gbGF5ZXI7XG4gICAgfVxufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUZlYXR1cmU7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVGZWF0dXJlKHBiZiwgZW5kLCBleHRlbnQsIGtleXMsIHZhbHVlcykge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICAgIHRoaXMudHlwZSA9IDA7XG5cbiAgICAvLyBQcml2YXRlXG4gICAgdGhpcy5fcGJmID0gcGJmO1xuICAgIHRoaXMuX2dlb21ldHJ5ID0gLTE7XG4gICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuXG4gICAgcGJmLnJlYWRGaWVsZHMocmVhZEZlYXR1cmUsIHRoaXMsIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGZWF0dXJlKHRhZywgZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PSAxKSBmZWF0dXJlLl9pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDIpIHJlYWRUYWcocGJmLCBmZWF0dXJlKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gMykgZmVhdHVyZS50eXBlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT0gNCkgZmVhdHVyZS5fZ2VvbWV0cnkgPSBwYmYucG9zO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnKHBiZiwgZmVhdHVyZSkge1xuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcztcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIHZhciBrZXkgPSBmZWF0dXJlLl9rZXlzW3BiZi5yZWFkVmFyaW50KCldLFxuICAgICAgICAgICAgdmFsdWUgPSBmZWF0dXJlLl92YWx1ZXNbcGJmLnJlYWRWYXJpbnQoKV07XG4gICAgICAgIGZlYXR1cmUucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gICAgfVxufVxuXG5WZWN0b3JUaWxlRmVhdHVyZS50eXBlcyA9IFsnVW5rbm93bicsICdQb2ludCcsICdMaW5lU3RyaW5nJywgJ1BvbHlnb24nXTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYmYgPSB0aGlzLl9wYmY7XG4gICAgcGJmLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIGxpbmVzID0gW10sXG4gICAgICAgIGxpbmU7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcblxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gMSkgeyAvLyBtb3ZlVG9cbiAgICAgICAgICAgICAgICBpZiAobGluZSkgbGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUucHVzaChuZXcgUG9pbnQoeCwgeSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kID09PSA3KSB7XG4gICAgICAgICAgICBsaW5lLnB1c2gobGluZVswXS5jbG9uZSgpKTsgLy8gY2xvc2VQb2x5Z29uXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBjb21tYW5kICcgKyBjbWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG59O1xuXG5WZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUuYmJveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYmYgPSB0aGlzLl9wYmY7XG4gICAgcGJmLnBvcyA9IHRoaXMuX2dlb21ldHJ5O1xuXG4gICAgdmFyIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zLFxuICAgICAgICBjbWQgPSAxLFxuICAgICAgICBsZW5ndGggPSAwLFxuICAgICAgICB4ID0gMCxcbiAgICAgICAgeSA9IDAsXG4gICAgICAgIHgxID0gSW5maW5pdHksXG4gICAgICAgIHgyID0gLUluZmluaXR5LFxuICAgICAgICB5MSA9IEluZmluaXR5LFxuICAgICAgICB5MiA9IC1JbmZpbml0eTtcblxuICAgIHdoaWxlIChwYmYucG9zIDwgZW5kKSB7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY21kTGVuID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgICAgIGNtZCA9IGNtZExlbiAmIDB4NztcbiAgICAgICAgICAgIGxlbmd0aCA9IGNtZExlbiA+PiAzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gMSB8fCBjbWQgPT09IDIpIHtcbiAgICAgICAgICAgIHggKz0gcGJmLnJlYWRTVmFyaW50KCk7XG4gICAgICAgICAgICB5ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgaWYgKHggPCB4MSkgeDEgPSB4O1xuICAgICAgICAgICAgaWYgKHggPiB4MikgeDIgPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCB5MSkgeTEgPSB5O1xuICAgICAgICAgICAgaWYgKHkgPiB5MikgeTIgPSB5O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY21kICE9PSA3KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLnRvR2VvSlNPTiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZXh0ZW50ICogTWF0aC5wb3coMiwgeiksXG4gICAgICAgIHgwID0gdGhpcy5leHRlbnQgKiB4LFxuICAgICAgICB5MCA9IHRoaXMuZXh0ZW50ICogeSxcbiAgICAgICAgY29vcmRzID0gdGhpcy5sb2FkR2VvbWV0cnkoKSxcbiAgICAgICAgdHlwZSA9IFZlY3RvclRpbGVGZWF0dXJlLnR5cGVzW3RoaXMudHlwZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGNvb3Jkc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGxpbmVbal0sIHkyID0gMTgwIC0gKHAueSArIHkwKSAqIDM2MCAvIHNpemU7XG4gICAgICAgICAgICBsaW5lW2pdID0gW1xuICAgICAgICAgICAgICAgIChwLnggKyB4MCkgKiAzNjAgLyBzaXplIC0gMTgwLFxuICAgICAgICAgICAgICAgIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnUG9pbnQnICYmIGNvb3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29vcmRzID0gY29vcmRzWzBdWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgICAgIHR5cGUgPSAnTXVsdGlQb2ludCc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycgJiYgY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWN0b3JUaWxlRmVhdHVyZSA9IHJlcXVpcmUoJy4vdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlTGF5ZXI7XG5cbmZ1bmN0aW9uIFZlY3RvclRpbGVMYXllcihwYmYsIGVuZCkge1xuICAgIC8vIFB1YmxpY1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmV4dGVudCA9IDQwOTY7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgdGhpcy5fZmVhdHVyZXMgPSBbXTtcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRMYXllciwgdGhpcywgZW5kKTtcblxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZmVhdHVyZXMubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXIodGFnLCBsYXllciwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMTUpIGxheWVyLnZlcnNpb24gPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMSkgbGF5ZXIubmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSA1KSBsYXllci5leHRlbnQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgbGF5ZXIuX2ZlYXR1cmVzLnB1c2gocGJmLnBvcyk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSBsYXllci5fa2V5cy5wdXNoKHBiZi5yZWFkU3RyaW5nKCkpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgbGF5ZXIuX3ZhbHVlcy5wdXNoKHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRWYWx1ZU1lc3NhZ2UocGJmKSB7XG4gICAgdmFyIHZhbHVlID0gbnVsbCxcbiAgICAgICAgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIgdGFnID0gcGJmLnJlYWRWYXJpbnQoKSA+PiAzO1xuXG4gICAgICAgIHZhbHVlID0gdGFnID09PSAxID8gcGJmLnJlYWRTdHJpbmcoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDIgPyBwYmYucmVhZEZsb2F0KCkgOlxuICAgICAgICAgICAgdGFnID09PSAzID8gcGJmLnJlYWREb3VibGUoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDQgPyBwYmYucmVhZFZhcmludDY0KCkgOlxuICAgICAgICAgICAgdGFnID09PSA1ID8gcGJmLnJlYWRWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDYgPyBwYmYucmVhZFNWYXJpbnQoKSA6XG4gICAgICAgICAgICB0YWcgPT09IDcgPyBwYmYucmVhZEJvb2xlYW4oKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyByZXR1cm4gZmVhdHVyZSBgaWAgZnJvbSB0aGlzIGxheWVyIGFzIGEgYFZlY3RvclRpbGVGZWF0dXJlYFxuVmVjdG9yVGlsZUxheWVyLnByb3RvdHlwZS5mZWF0dXJlID0gZnVuY3Rpb24oaSkge1xuICAgIGlmIChpIDwgMCB8fCBpID49IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlIGluZGV4IG91dCBvZiBib3VuZHMnKTtcblxuICAgIHRoaXMuX3BiZi5wb3MgPSB0aGlzLl9mZWF0dXJlc1tpXTtcblxuICAgIHZhciBlbmQgPSB0aGlzLl9wYmYucmVhZFZhcmludCgpICsgdGhpcy5fcGJmLnBvcztcbiAgICByZXR1cm4gbmV3IFZlY3RvclRpbGVGZWF0dXJlKHRoaXMuX3BiZiwgZW5kLCB0aGlzLmV4dGVudCwgdGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzKTtcbn07XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiJdfQ==</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
